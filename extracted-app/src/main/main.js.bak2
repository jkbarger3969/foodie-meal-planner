const path = require('path');
const { app, BrowserWindow, ipcMain, dialog, Menu, globalShortcut } = require('electron');
const { createDb, getDbPathDefault, setDbPath } = require('./db');
const { handleApiCall } = require('./api');
const WebSocket = require('ws');
const os = require('os');
const fs = require('fs');

// Error logging for production
const logPath = path.join(app.getPath('userData'), 'error.log');
function logError(message, error) {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}\n${error ? error.stack || error : ''}\n\n`;
  console.error(logMessage);
  
  try {
    fs.appendFileSync(logPath, logMessage);
  } catch (e) {
    console.error('Failed to write to log file:', e);
  }
}

// Catch unhandled errors
process.on('uncaughtException', (error) => {
  logError('Uncaught Exception:', error);
  dialog.showErrorBox('Error', `An error occurred: ${error.message}\n\nCheck ${logPath} for details.`);
});

process.on('unhandledRejection', (reason, promise) => {
  logError('Unhandled Rejection:', reason);
});

// Set consistent app name for userData folder
// This ensures dev and production use the same folder
app.setName('Foodie Meal Planner');

let StoreCtor = null;
async function getStoreCtor() {
  if (StoreCtor) return StoreCtor;
  const mod = await import('electron-store');
  StoreCtor = mod.default;
  return StoreCtor;
}

let store = null;
async function initStore() {
  const Store = await getStoreCtor();
  store = new Store({
    name: 'foodie-settings',
    defaults: {
      dbPath: '',
      calendarName: 'Foodie Meal Planner',
      googleCalendarId: 'primary',
    },
  });
  return store;
}

// ========================================
// COMPANION SERVER (WebSocket)
// ========================================

class CompanionServer {
  constructor() {
    this.wss = null;
    this.clients = new Map(); // deviceId -> { ws, deviceType, ip }
    this.mainWindow = null;
  }

  // Send log to both console and renderer window
  log(level, ...args) {
    const message = args.join(' ');
    console.log(...args);
    
    // Also send to renderer if window exists
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send('companion-log', { level, message });
    }
  }

  // Serialize recipe object for safe JSON transmission
  serializeRecipe(recipe) {
    if (!recipe) return null;
    
    return {
      RecipeId: recipe.RecipeId || '',
      Title: recipe.Title || '',
      URL: recipe.URL || '',
      Cuisine: recipe.Cuisine || '',
      MealType: recipe.MealType || '',
      Notes: recipe.Notes || '',
      Instructions: recipe.Instructions || '',
      Image_Name: recipe.Image_Name || ''
    };
  }

  // Serialize ingredient object for safe JSON transmission
  serializeIngredient(ing) {
    if (!ing) return null;
    
    return {
      idx: ing.idx || 0,
      IngredientNorm: ing.IngredientNorm || '',
      IngredientRaw: ing.IngredientRaw || '',
      QtyText: ing.QtyText || '',
      QtyNum: ing.QtyNum || null,
      Unit: ing.Unit || '',
      Category: ing.Category || '',
      StoreId: ing.StoreId || ''
    };
  }

  start(port = 8080) {
    try {
      this.wss = new WebSocket.Server({ port });

      console.log(`ðŸ“± Companion server started on port ${port}`);
      this.logLocalIPs();

      this.wss.on('connection', (ws, req) => {
        const clientIp = req.socket.remoteAddress;
        const deviceId = req.headers['x-device-id'] || `device-${Date.now()}`;
        const deviceType = req.headers['x-device-type'] || 'unknown';

        this.clients.set(deviceId, { ws, deviceType, ip: clientIp });
        console.log(`ðŸ“± ${deviceType} connected: ${deviceId} (${clientIp})`);

        // Send initial connection success
        ws.send(JSON.stringify({
          type: 'connected',
          serverId: os.hostname(),
          timestamp: new Date().toISOString()
        }));

        ws.on('message', (message) => {
          try {
            const data = JSON.parse(message.toString());
            this.handleMessage(deviceId, data);
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        });

        ws.on('close', () => {
          this.clients.delete(deviceId);
          console.log(`ðŸ“± ${deviceType} disconnected: ${deviceId}`);
          this.notifyDevicesChanged();
        });

        ws.on('error', (error) => {
          console.error(`WebSocket error for ${deviceId}:`, error);
        });

        this.notifyDevicesChanged();
      });

      this.wss.on('error', (error) => {
        console.error('WebSocket server error:', error);
      });

    } catch (error) {
      console.error('Failed to start companion server:', error);
    }
  }

  async handleMessage(deviceId, message) {
    const client = this.clients.get(deviceId);
    if (!client) return;

    try {
      switch (message.type) {
        case 'ping':
          client.ws.send(JSON.stringify({ type: 'pong', timestamp: Date.now() }));
          break;

        case 'request_shopping_list':
          await this.sendShoppingList(deviceId);
          break;

        case 'request_meal_plan':
          await this.sendMealPlan(deviceId, message.date);
          break;

        case 'request_recipe':
          await this.sendRecipe(deviceId, message.recipeId);
          break;

        case 'load_recipe':
          // iPad sends this when user taps a recipe from meal slots
          const recipeId = message.data?.recipeId || message.recipeId;
          if (recipeId) {
            await this.sendRecipe(deviceId, recipeId);
          }
          break;

        case 'sync_changes':
          await this.handleSyncChanges(deviceId, message.data);
          break;

        default:
          console.log(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error(`Error handling message from ${deviceId}:`, error);
    }
  }

  async sendShoppingList(deviceId) {
    const client = this.clients.get(deviceId);
    if (!client) return;

    try {
      // Generate shopping list from today's meal plan
      const today = new Date().toISOString().split('T')[0];
      
      const planResult = await handleApiCall({
        fn: 'getPlansRange',
        payload: { start: today, end: today },
        store
      });

      let items = [];

      if (planResult && planResult.ok && Array.isArray(planResult.plans) && planResult.plans.length > 0) {
        const plan = planResult.plans[0];
        const recipeIds = [];
        
        if (plan.Breakfast?.RecipeId) recipeIds.push(plan.Breakfast.RecipeId);
        if (plan.Lunch?.RecipeId) recipeIds.push(plan.Lunch.RecipeId);
        if (plan.Dinner?.RecipeId) recipeIds.push(plan.Dinner.RecipeId);

        for (const recipeId of recipeIds) {
          const ingredientsResult = await handleApiCall({
            fn: 'listRecipeIngredients',
            payload: { recipeId },
            store
          });

          if (ingredientsResult && ingredientsResult.ok && Array.isArray(ingredientsResult.items)) {
            // Serialize each ingredient to ensure clean data
            const serializedIngredients = ingredientsResult.items.map(ing => {
              const serialized = this.serializeIngredient(ing);
              return {
                ItemId: `${recipeId}-${ing.idx || 0}`,  // iOS expects "ItemId"
                IngredientName: serialized.IngredientNorm || serialized.IngredientRaw || 'Unknown',  // iOS expects "IngredientName"
                QtyText: serialized.QtyText || (serialized.QtyNum ? String(serialized.QtyNum) : ''),  // iOS expects "QtyText"
                Unit: serialized.Unit || '',
                Category: serialized.Category || '',
                StoreName: serialized.StoreId || 'kroger',  // iOS expects "StoreName"
                RecipeId: recipeId,
                is_purchased: 0  // iOS expects "is_purchased" as int
              };
            });
            items.push(...serializedIngredients);
          }
        }
      }
      
      client.ws.send(JSON.stringify({
        type: 'shopping_list',
        data: items,
        timestamp: new Date().toISOString()
      }));
      console.log(`ðŸ“¤ Sent ${items.length} shopping items to ${client.deviceType}`);
    } catch (error) {
      console.error('Error sending shopping list:', error);
    }
  }

  async sendMealPlan(deviceId, date = new Date().toISOString().split('T')[0]) {
    const client = this.clients.get(deviceId);
    if (!client) return;

    try {
      const planResult = await handleApiCall({ 
        fn: 'getPlansRange', 
        payload: { 
          start: date,
          end: date
        }, 
        store 
      });

      let meals = [];
      if (planResult && planResult.ok && Array.isArray(planResult.plans) && planResult.plans.length > 0) {
        const plan = planResult.plans[0];
        
        for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
          const meal = plan[slot];
          if (meal && meal.RecipeId) {
            // Fetch additional items for this slot
            const additionalResult = await handleApiCall({
              fn: 'getAdditionalItems',
              payload: { date, slot },
              store
            });

            const additionalItems = [];
            if (additionalResult && additionalResult.ok && Array.isArray(additionalResult.items)) {
              for (const item of additionalResult.items) {
                additionalItems.push({
                  recipeId: item.RecipeId,
                  title: item.Title,
                  itemType: item.ItemType || 'side'
                });
              }
            }

            meals.push({
              slot: slot.toLowerCase(),
              recipeId: meal.RecipeId,
              title: meal.Title,
              additionalItems
            });
          }
        }
      }

      client.ws.send(JSON.stringify({
        type: 'meal_plan',
        date: date,
        data: meals,
        timestamp: new Date().toISOString()
      }));
    } catch (error) {
      console.error('Error sending meal plan:', error);
    }
  }

  async sendRecipe(deviceId, recipeId) {
    const client = this.clients.get(deviceId);
    if (!client) return;

    try {
      const recipeResult = await handleApiCall({ 
        fn: 'getRecipe', 
        payload: { recipeId }, 
        store 
      });

      const ingredientsResult = await handleApiCall({ 
        fn: 'listRecipeIngredients', 
        payload: { recipeId }, 
        store 
      });

      if (recipeResult && recipeResult.ok && ingredientsResult && ingredientsResult.ok) {
        const serializedRecipe = this.serializeRecipe(recipeResult.recipe);
        const serializedIngredients = (ingredientsResult.items || []).map(ing => {
          const s = this.serializeIngredient(ing);
          return {
            IngredientId: `${recipeId}-${ing.idx || 0}`,
            IngredientName: s.IngredientNorm || s.IngredientRaw || 'Unknown',
            QtyText: s.QtyText || '',
            QtyNum: s.QtyNum,
            Unit: s.Unit || '',
            Category: s.Category || 'Other'
          };
        });
        
        client.ws.send(JSON.stringify({
          type: 'recipe',
          data: {
            ...serializedRecipe,
            ingredients: serializedIngredients
          },
          timestamp: new Date().toISOString()
        }));
        console.log(`ðŸ“¤ Sent recipe "${recipeResult.recipe.Title}" to ${client.deviceType}`);
      }
    } catch (error) {
      console.error('Error sending recipe:', error);
    }
  }

  async handleSyncChanges(deviceId, changes) {
    const client = this.clients.get(deviceId);
    if (!client || !Array.isArray(changes)) return;

    console.log(`ðŸ“¥ Syncing ${changes.length} changes from ${client.deviceType}`);

    let updatedCount = 0;
    let addedCount = 0;
    let deletedCount = 0;

    for (const change of changes) {
      try {
        const { id, isPurchased, isManuallyAdded, isDeleted, name, quantity, category } = change;

        if (isDeleted) {
          const result = await handleApiCall({
            fn: 'deleteShoppingItem',
            payload: { itemId: id },
            store
          });
          if (result && result.ok) deletedCount++;
          continue;
        }

        if (isManuallyAdded) {
          // Try to add new item
          const result = await handleApiCall({
            fn: 'addShoppingItem',
            payload: {
              itemId: id,
              ingredientName: name,
              qtyText: quantity || '',
              category: category || 'Other',
              isPurchased: isPurchased ? 1 : 0
            },
            store
          });
          if (result && result.ok) {
            addedCount++;
          } else {
            // Item might exist, try update
            const updateResult = await handleApiCall({
              fn: 'updateShoppingItem',
              payload: {
                itemId: id,
                isPurchased: isPurchased ? 1 : 0
              },
              store
            });
            if (updateResult && updateResult.ok) updatedCount++;
          }
        } else {
          // Update existing item
          const result = await handleApiCall({
            fn: 'updateShoppingItem',
            payload: {
              itemId: id,
              isPurchased: isPurchased ? 1 : 0
            },
            store
          });
          if (result && result.ok) updatedCount++;
        }
      } catch (error) {
        console.error(`Error syncing change:`, error);
      }
    }

    console.log(`âœ… Sync complete: ${updatedCount} updated, ${addedCount} added, ${deletedCount} deleted`);

    // Send confirmation
    client.ws.send(JSON.stringify({
      type: 'sync_confirmed',
      data: {
        updated: updatedCount,
        added: addedCount,
        deleted: deletedCount
      },
      timestamp: new Date().toISOString()
    }));

    // Notify desktop UI
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send('shopping-list-updated', {
        updated: updatedCount,
        added: addedCount,
        deleted: deletedCount
      });
    }
  }

  pushToDeviceType(deviceType, data) {
    const targetType = deviceType.toLowerCase();
    let sentCount = 0;
    
    this.log('info', `ðŸ” pushToDeviceType('${deviceType}') called - checking ${this.clients.size} connected client(s)`);
    
    for (const [deviceId, client] of this.clients.entries()) {
      if (client.deviceType.toLowerCase() === targetType) {
        if (client.ws.readyState === WebSocket.OPEN) {
          try {
            const payload = JSON.stringify(data);
            // Log message preview (first 200 chars)
            const preview = payload.length > 200 ? payload.substring(0, 200) + '...' : payload;
            this.log('info', `ðŸ“¤ Sending to ${deviceId}: ${preview}`);
            
            client.ws.send(payload);
            sentCount++;
            this.log('success', `âœ… Sent to ${deviceType} device: ${deviceId}`);
          } catch (error) {
            this.log('error', `âŒ Failed to send to ${deviceId}:`, error.message);
          }
        } else {
          this.log('warn', `âš ï¸  Skipping ${deviceId} - WebSocket not OPEN (state: ${client.ws.readyState})`);
        }
      }
    }
    
    this.log('info', `ðŸ“Š pushToDeviceType('${deviceType}'): Sent to ${sentCount} device(s)`);
    return sentCount;
  }

  async pushShoppingListToPhones() {
    console.log('ðŸ” pushShoppingListToPhones: Starting...');
    try {
      // Generate shopping list from today's meal plan
      const today = new Date().toISOString().split('T')[0];
      console.log(`ðŸ” pushShoppingListToPhones: Today is ${today}`);
      
      // Get today's meal plan
      const planResult = await handleApiCall({
        fn: 'getPlansRange',
        payload: { start: today, end: today },
        store
      });

      if (!planResult || !planResult.ok || !Array.isArray(planResult.plans) || planResult.plans.length === 0) {
        // No meal plan for today - send empty list
        const sentCount = this.pushToDeviceType('iphone', {
          type: 'shopping_list_update',
          data: [],
          timestamp: new Date().toISOString()
        });
        console.log(`ðŸ“¤ Pushed empty shopping list (no meal plan for today)`);
        return sentCount;
      }

      const plan = planResult.plans[0];
      const recipeIds = [];
      
      // Collect all recipe IDs from today's meals
      if (plan.Breakfast?.RecipeId) recipeIds.push(plan.Breakfast.RecipeId);
      if (plan.Lunch?.RecipeId) recipeIds.push(plan.Lunch.RecipeId);
      if (plan.Dinner?.RecipeId) recipeIds.push(plan.Dinner.RecipeId);

      if (recipeIds.length === 0) {
        // Meal plan exists but no recipes - send empty list
        const sentCount = this.pushToDeviceType('iphone', {
          type: 'shopping_list_update',
          data: [],
          timestamp: new Date().toISOString()
        });
        console.log(`ðŸ“¤ Pushed empty shopping list (no recipes in today's plan)`);
        return sentCount;
      }

      // Get all ingredients for all recipes
      const allIngredients = [];
      for (const recipeId of recipeIds) {
        const ingredientsResult = await handleApiCall({
          fn: 'listRecipeIngredients',
          payload: { recipeId },
          store
        });

        if (ingredientsResult && ingredientsResult.ok && Array.isArray(ingredientsResult.items)) {
          // Serialize each ingredient to ensure clean data
          const serializedIngredients = ingredientsResult.items.map(ing => {
            const serialized = this.serializeIngredient(ing);
            return {
              ItemId: `${recipeId}-${ing.idx || 0}`,  // iOS expects "ItemId"
              IngredientName: serialized.IngredientNorm || serialized.IngredientRaw || 'Unknown',  // iOS expects "IngredientName"
              QtyText: serialized.QtyText || (serialized.QtyNum ? String(serialized.QtyNum) : ''),  // iOS expects "QtyText"
              Unit: serialized.Unit || '',
              Category: serialized.Category || '',
              StoreName: serialized.StoreId || 'kroger',  // iOS expects "StoreName"
              RecipeId: recipeId,
              is_purchased: 0  // iOS expects "is_purchased" as int
            };
          });
          allIngredients.push(...serializedIngredients);
        }
      }

      const sentCount = this.pushToDeviceType('iphone', {
        type: 'shopping_list_update',
        data: allIngredients,
        timestamp: new Date().toISOString()
      });
      
      console.log(`ðŸ“¤ Pushed shopping list (${allIngredients.length} items from ${recipeIds.length} recipes) to all iPhones`);
      
      return sentCount;
    } catch (error) {
      console.error('Error pushing shopping list:', error);
      throw error;
    }
  }

  async pushTodaysMealsToTablets() {
    console.log('ðŸ” pushTodaysMealsToTablets: Starting...');
    try {
      const today = new Date().toISOString().split('T')[0];
      console.log(`ðŸ” pushTodaysMealsToTablets: Today is ${today}`);
      
      // Get today's meal plan using the correct API
      const planResult = await handleApiCall({ 
        fn: 'getPlansRange', 
        payload: { 
          start: today,
          end: today
        }, 
        store 
      });

      if (!planResult || !planResult.ok || !Array.isArray(planResult.plans) || planResult.plans.length === 0) {
        // No meal plan - send empty array
        const sentCount = this.pushToDeviceType('ipad', {
          type: 'todays_meals',
          data: { data: [] },  // iOS expects nested data structure even when empty
          timestamp: new Date().toISOString()
        });
        console.log(`ðŸ“¤ Pushed empty meal plan (no plan for today)`);
        return sentCount;
      }

      const plan = planResult.plans[0];
      const meals = [];

      // Process each meal slot
      for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
        const meal = plan[slot];
        if (!meal || !meal.RecipeId) continue;
        
        const recipeId = meal.RecipeId;
        const title = meal.Title;

        // Get recipe details
        const recipeResult = await handleApiCall({ 
          fn: 'getRecipe', 
          payload: { recipeId }, 
          store 
        });

        // Get ingredients
        const ingredientsResult = await handleApiCall({ 
          fn: 'listRecipeIngredients', 
          payload: { recipeId }, 
          store 
        });

        // Format recipe for iOS with ingredients embedded
        if (recipeResult && recipeResult.ok) {
          const serializedRecipe = this.serializeRecipe(recipeResult.recipe);
          const serializedIngredients = ingredientsResult && ingredientsResult.ok 
            ? (ingredientsResult.items || []).map(ing => {
                const s = this.serializeIngredient(ing);
                return {
                  IngredientId: `${recipeId}-${ing.idx || 0}`,
                  IngredientName: s.IngredientNorm || s.IngredientRaw || 'Unknown',
                  QtyText: s.QtyText || '',
                  QtyNum: s.QtyNum,
                  Unit: s.Unit || '',
                  Category: s.Category || 'Other'
                };
              })
            : [];
          
          meals.push({
            slot: slot.toLowerCase(),
            recipe: {
              ...serializedRecipe,
              ingredients: serializedIngredients
            }
          });
        }
      }

      const sentCount = this.pushToDeviceType('ipad', {
        type: 'todays_meals',
        data: { data: meals },  // iOS expects nested data structure
        date: today,
        timestamp: new Date().toISOString()
      });
      
      console.log(`ðŸ“¤ Pushed ${meals.length} meals for today to all iPads`);
      return sentCount;
    } catch (error) {
      console.error('Error pushing meals:', error);
      throw error;
    }
  }

  async pushRecipeToTablet(recipeId) {
    try {
      const recipeResult = await handleApiCall({ 
        fn: 'getRecipe', 
        payload: { recipeId }, 
        store 
      });

      const ingredientsResult = await handleApiCall({ 
        fn: 'listRecipeIngredients', 
        payload: { recipeId }, 
        store 
      });

      if (recipeResult && recipeResult.ok && ingredientsResult && ingredientsResult.ok) {
        const serializedRecipe = this.serializeRecipe(recipeResult.recipe);
        const serializedIngredients = (ingredientsResult.items || []).map(ing => {
          const s = this.serializeIngredient(ing);
          return {
            IngredientId: `${recipeId}-${ing.idx || 0}`,
            IngredientName: s.IngredientNorm || s.IngredientRaw || 'Unknown',
            QtyText: s.QtyText || '',
            QtyNum: s.QtyNum,
            Unit: s.Unit || '',
            Category: s.Category || 'Other'
          };
        });
        
        this.pushToDeviceType('ipad', {
          type: 'recipe',
          data: {
            ...serializedRecipe,
            ingredients: serializedIngredients
          },
          timestamp: new Date().toISOString()
        });
        console.log(`ðŸ“¤ Pushed recipe to all iPads`);
        return true;
      }
    } catch (error) {
      console.error('Error pushing recipe:', error);
      return false;
    }
  }

  logLocalIPs() {
    const interfaces = os.networkInterfaces();
    console.log('\nðŸ“± Connect iOS devices to:');

    for (const name of Object.keys(interfaces)) {
      for (const iface of interfaces[name]) {
        if (iface.family === 'IPv4' && !iface.internal) {
          console.log(`   ws://${iface.address}:8080`);
        }
      }
    }
    console.log('');
  }

  getConnectedDevices() {
    return Array.from(this.clients.entries()).map(([id, client]) => ({
      id,
      type: client.deviceType,
      ip: client.ip
    }));
  }

  notifyDevicesChanged() {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      const devices = this.getConnectedDevices();
      this.mainWindow.webContents.send('companion:devices-changed', devices);
    }
  }

  setMainWindow(win) {
    this.mainWindow = win;
  }

  stop() {
    if (this.wss) {
      this.wss.close();
      console.log('ðŸ“± Companion server stopped');
    }
  }
}

// Global companion server instance
let companionServer = null;

function getIndexPath() {
  // Support either src/renderer/index.html (common) or src/index.html
  const candidates = [
    path.join(__dirname, '..', 'renderer', 'index.html'),
    path.join(__dirname, '..', 'index.html'),
    path.join(__dirname, 'index.html'),
  ];
  for (const p of candidates) {
    try {
      // eslint-disable-next-line no-sync
      require('fs').accessSync(p);
      return p;
    } catch (_) {}
  }
  // Fall back to renderer path
  return candidates[0];
}

function buildMenu(win) {
  const template = [
    ...(process.platform === 'darwin'
      ? [{
          label: app.name,
          submenu: [
            { role: 'about' },
            { type: 'separator' },
            { role: 'services' },
            { type: 'separator' },
            { role: 'hide' },
            { role: 'hideOthers' },
            { role: 'unhide' },
            { type: 'separator' },
            { role: 'quit' },
          ],
        }]
      : []),
    {
      label: 'File',
      submenu: [
        {
          label: 'Select Database Folderâ€¦',
          accelerator: 'CmdOrCtrl+O',
          click: async () => {
            const res = await dialog.showOpenDialog(win, {
              title: 'Select Foodie data folder',
              properties: ['openDirectory', 'createDirectory'],
            });
            if (res.canceled || !res.filePaths || !res.filePaths[0]) return;
            const folder = res.filePaths[0];
            const filePath = path.join(folder, 'foodie.sqlite');
            setDbPath(filePath);
            if (store) store.set('dbPath', filePath);
            win.webContents.send('foodie-db-path-changed', { dbPath: filePath });
          },
        },
        { type: 'separator' },
        { role: 'close' },
      ],
    },
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        { role: 'pasteAndMatchStyle' },
        { role: 'delete' },
        { role: 'selectAll' },
      ],
    },
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        { role: 'togglefullscreen' },
        { type: 'separator' },
        {
          label: 'Toggle Developer Tools',
          accelerator: 'Alt+Command+I',
          click: () => {
            if (!win) return;
            win.webContents.toggleDevTools();
          },
        },
      ],
    },
    { role: 'windowMenu' },
  ];

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
}

async function createWindow() {
  console.log('ðŸªŸ Creating window...');
  const win = new BrowserWindow({
    width: 1280,
    height: 820,
    show: false,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: false,
    },
  });
  console.log('âœ… BrowserWindow created');

  buildMenu(win);
  console.log('âœ… Menu built');

  // Always provide shortcuts (menu sometimes fails to appear in custom builds)
  try {
    globalShortcut.register('CommandOrControl+Shift+I', () => win.webContents.toggleDevTools());
    globalShortcut.register('F12', () => win.webContents.toggleDevTools());
  } catch (_) {}

  const indexPath = getIndexPath();
  console.log('ðŸ“„ Loading index from:', indexPath);
  await win.loadFile(indexPath);
  console.log('âœ… File loaded');

  // Show and focus window after content is loaded
  console.log('ðŸ‘ï¸  Showing window...');
  win.show();
  win.focus();
  if (process.platform === 'darwin') {
    app.dock.show();
  }
  console.log('âœ… Window should be visible now!');
  console.log('   - Bounds:', win.getBounds());
  console.log('   - Visible:', win.isVisible());
  console.log('   - Minimized:', win.isMinimized());

  win.on('closed', () => {
    try { globalShortcut.unregisterAll(); } catch (_) {}
  });

  return win;
}

async function bootstrap() {
  await initStore();

  // Initialize DB location
  // SIMPLIFIED: Use ./data/foodie.sqlite directly as both seed and user database
  const dbPath = getDbPathDefault(app);
  try { store.set('dbPath', dbPath); } catch (_) {}
  setDbPath(dbPath);

  // Open DB and run migrations (db.js handles idempotence)
  createDb();

  // Initialize companion server for iOS apps
  companionServer = new CompanionServer();
  companionServer.start(8080);

  // IPC: API bridge
  ipcMain.handle('foodie-api', async (_evt, { fn, payload }) => {
    return await handleApiCall({ fn, payload, store });
  });

  
  // IPC: Print recipe (native macOS dialog)
  ipcMain.handle('foodie-print-recipe', async (_evt, { recipeId }) => {
    try {
      const rid = String(recipeId || '').trim();
      if (!rid) return { ok: false, error: 'Missing recipeId' };

      const rRes = await handleApiCall({ fn: 'getRecipe', payload: { recipeId: rid }, store });
      if (!rRes || !rRes.ok) return { ok: false, error: rRes?.error || 'getRecipe failed' };
      const iRes = await handleApiCall({ fn: 'listRecipeIngredients', payload: { recipeId: rid }, store });
      const recipe = rRes.recipe || {};
      const ingredients = (iRes && iRes.ok && Array.isArray(iRes.items)) ? iRes.items : [];

      const esc = (s) => String(s ?? '')
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;').replace(/'/g, '&#39;');

      const html = `<!doctype html><html><head><meta charset="utf-8" />
        <title>${esc(recipe.Title || 'Recipe')}</title>
        <style>
          body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;margin:24px;}
          h1{margin:0 0 8px 0;font-size:22px;}
          .meta{color:#555;margin-bottom:16px;}
          h2{margin:18px 0 8px;font-size:16px;}
          ul{padding-left:18px;}
          li{margin:4px 0;}
          pre{white-space:pre-wrap;}
          .muted{color:#666;}
        </style></head><body>
        <h1>${esc(recipe.Title || '')}</h1>
        <div class="meta">
          <span>${esc(recipe.MealType || 'Any')}</span>
          ${recipe.Cuisine ? ` â€¢ <span>${esc(recipe.Cuisine)}</span>` : ``}
          ${recipe.URL ? ` â€¢ <span class="muted">${esc(recipe.URL)}</span>` : ``}
        </div>
        <h2>Ingredients</h2>
        ${ingredients.length ? `<ul>${ingredients.map(it => {
          const qty = [it.QtyText || it.QtyNum || '', it.Unit || ''].filter(Boolean).join(' ').trim();
          const storeName = it.StoreName ? ` (${esc(it.StoreName)})` : '';
          const name = it.IngredientRaw || it.IngredientNorm || it.Name || '';
          return `<li>${esc((qty ? qty + ' ' : '') + name)}${storeName}</li>`;
        }).join('')}</ul>` : `<div class="muted">No ingredients.</div>`}
        <h2>Instructions</h2>
        ${recipe.Instructions ? `<pre>${esc(recipe.Instructions)}</pre>` : `<div class="muted">No instructions.</div>`}
        ${recipe.Notes ? `<h2>Notes</h2><pre>${esc(recipe.Notes)}</pre>` : ``}
        </body></html>`;

      const win = new BrowserWindow({ width: 900, height: 700, show: false, webPreferences: { sandbox: false } });
      await win.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(html));

      return await new Promise((resolve) => {
        win.webContents.print({ silent: false, printBackground: true }, (success, failureReason) => {
          try { win.close(); } catch (_) {}
          if (!success) resolve({ ok: false, error: failureReason || 'Print failed' });
          else resolve({ ok: true });
        });
      });
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  // IPC: Export / Import DB file for syncing across installations
  

  // IPC: Print shopping list (native macOS dialog)
  ipcMain.handle('foodie-print-shopping', async (_evt, { storeName, items }) => {
    try {
      const sn = String(storeName || '').trim() || 'Shopping List';
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) return { ok: false, error: 'No items to print.' };

      const esc = (s) => String(s ?? '')
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;').replace(/'/g, '&#39;');

      const rows = arr.map(it => {
        const name = esc(it.IngredientNorm || '');
        const qty = esc(it.QtyDisplay || it.QtyText || '');
        const unit = esc(it.Unit || '');
        const right = [qty, unit].filter(Boolean).join(' ').trim();
        return `<tr><td>${name}</td><td style="text-align:right; white-space:nowrap;">${right}</td></tr>`;
      }).join('');

      const html = `<!doctype html><html><head><meta charset="utf-8" />
        <title>${esc(sn)}</title>
        <style>
          body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;margin:24px;}
          h1{margin:0 0 12px 0;font-size:20px;}
          table{width:100%;border-collapse:collapse;}
          th,td{padding:8px 6px;border-bottom:1px solid #ddd;vertical-align:top;}
          th{text-align:left;color:#444;font-weight:600;}
        </style></head><body>
        <h1>${esc(sn)}</h1>
        <table>
          <thead><tr><th>Item</th><th style="text-align:right;">Qty</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
        </body></html>`;

      const win = new BrowserWindow({ width: 900, height: 700, show: false, webPreferences: { sandbox: false } });
      await win.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(html));

      return await new Promise((resolve) => {
        win.webContents.print({ silent: false, printBackground: true }, (success, failureReason) => {
          try { win.close(); } catch (_) {}
          if (!success) resolve({ ok: false, error: failureReason || 'Print failed' });
          else resolve({ ok: true });
        });
      });
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  ipcMain.handle('foodie-print-pantry', async (_evt, { byCategory, title }) => {
    try {
      const printTitle = String(title || '').trim() || 'Pantry Inventory';
      const categories = byCategory || {};
      
      const esc = (s) => String(s ?? '')
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;').replace(/'/g, '&#39;');

      const categoryBlocks = Object.keys(categories).sort().map(cat => {
        const items = categories[cat] || [];
        const rows = items.map(it => `
          <tr>
            <td>${esc(it.Name)}</td>
            <td style="text-align:right;">${esc(it.Qty)}</td>
            <td>${esc(it.Store)}</td>
            <td style="font-size:0.85em;color:#666;">${esc(it.Notes)}</td>
          </tr>
        `).join('');
        
        return `
          <div style="margin-bottom:20px;">
            <h2 style="font-size:16px;margin:12px 0 8px 0;color:#333;border-bottom:2px solid #4da3ff;padding-bottom:4px;">${esc(cat)}</h2>
            <table>
              <thead>
                <tr>
                  <th>Item</th>
                  <th style="text-align:right;">Quantity</th>
                  <th>Store</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
        `;
      }).join('');

      const html = `<!doctype html><html><head><meta charset="utf-8" />
        <title>${esc(printTitle)}</title>
        <style>
          body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;margin:24px;}
          h1{margin:0 0 16px 0;font-size:22px;color:#111;}
          h2{font-size:16px;margin:12px 0 8px 0;color:#333;}
          table{width:100%;border-collapse:collapse;margin-bottom:12px;}
          th,td{padding:6px 8px;border-bottom:1px solid #e0e0e0;vertical-align:top;text-align:left;}
          th{color:#555;font-weight:600;background:#f5f5f5;}
          @media print { body { margin: 12px; } }
        </style></head><body>
        <h1>${esc(printTitle)}</h1>
        <div style="font-size:0.9em;color:#666;margin-bottom:16px;">Generated: ${new Date().toLocaleString()}</div>
        ${categoryBlocks}
        </body></html>`;

      const win = new BrowserWindow({ width: 900, height: 700, show: false, webPreferences: { sandbox: false } });
      await win.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(html));

      return await new Promise((resolve) => {
        win.webContents.print({ silent: false, printBackground: true }, (success, failureReason) => {
          try { win.close(); } catch (_) {}
          if (!success) resolve({ ok: false, error: failureReason || 'Print failed' });
          else resolve({ ok: true });
        });
      });
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

ipcMain.handle('foodie-export-data', async () => {
    try {
      const dbPathNow = String(store.get('dbPath') || '');
      const source = dbPathNow || getDbPathDefault(app);
      const res = await dialog.showSaveDialog({
        title: 'Export Foodie data',
        defaultPath: 'foodie.sqlite',
        filters: [{ name: 'SQLite Database', extensions: ['sqlite', 'db'] }, { name: 'All Files', extensions: ['*'] }],
      });
      if (res.canceled || !res.filePath) return { ok: false, error: 'Export canceled.' };
      require('fs').copyFileSync(source, res.filePath);
      return { ok: true };
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  ipcMain.handle('foodie-import-data', async () => {
    try {
      const pick = await dialog.showOpenDialog({
        title: 'Import Foodie data',
        properties: ['openFile'],
        filters: [{ name: 'SQLite Database', extensions: ['sqlite', 'db'] }, { name: 'All Files', extensions: ['*'] }],
      });
      if (pick.canceled || !pick.filePaths || !pick.filePaths[0]) return { ok: false, error: 'Import canceled.' };
      const src = pick.filePaths[0];
      const dest = String(store.get('dbPath') || '') || getDbPathDefault(app);
      require('fs').copyFileSync(src, dest);
      setDbPath(dest);
      createDb();
      return { ok: true };
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });


// IPC: settings
  ipcMain.handle('foodie-get-settings', async () => {
    return {
      ok: true,
      dbPath: store.get('dbPath') || '',
      calendarName: store.get('calendarName') || 'Foodie Meal Planner',
      googleCalendarId: store.get('googleCalendarId') || 'primary',
    };
  });

  ipcMain.handle('foodie-set-db-path', async () => {
    // same as menu action
    return { ok: true, dbPath: store.get('dbPath') || '' };
  });

  ipcMain.handle('foodie-set-calendar-name', async (_evt, { calendarName }) => {
    const v = String(calendarName || '').trim() || 'Foodie Meal Planner';
    store.set('calendarName', v);
    return { ok: true, calendarName: v };
  });

  ipcMain.handle('foodie-set-google-calendar-id', async (_evt, { calendarId }) => {
    const v = String(calendarId || '').trim() || 'primary';
    store.set('googleCalendarId', v);
    return { ok: true, calendarId: v };
  });

  // IPC: Companion server actions
  ipcMain.handle('companion:send-shopping-list', async () => {
    console.log('ðŸ“± IPC: companion:send-shopping-list called');
    if (!companionServer) {
      console.error('âŒ Companion server not initialized');
      return { ok: false, error: 'Companion server not initialized' };
    }
    try {
      console.log('ðŸ“± Calling pushShoppingListToPhones()...');
      const count = await companionServer.pushShoppingListToPhones();
      console.log(`ðŸ“± pushShoppingListToPhones() returned count: ${count}`);
      return { ok: true, count };
    } catch (e) {
      console.error('âŒ Error in pushShoppingListToPhones:', e);
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  ipcMain.handle('companion:send-todays-meals', async () => {
    console.log('ðŸ“± IPC: companion:send-todays-meals called');
    if (!companionServer) {
      console.error('âŒ Companion server not initialized');
      return { ok: false, error: 'Companion server not initialized' };
    }
    try {
      console.log('ðŸ“± Calling pushTodaysMealsToTablets()...');
      const count = await companionServer.pushTodaysMealsToTablets();
      console.log(`ðŸ“± pushTodaysMealsToTablets() returned count: ${count}`);
      return { ok: true, count };
    } catch (e) {
      console.error('âŒ Error in pushTodaysMealsToTablets:', e);
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  ipcMain.handle('companion:send-recipe', async (_evt, { recipeId }) => {
    if (!companionServer) return { ok: false, error: 'Companion server not initialized' };
    try {
      const success = await companionServer.pushRecipeToTablet(recipeId);
      return { ok: true, success };
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  ipcMain.handle('companion:get-devices', async () => {
    if (!companionServer) return { ok: false, error: 'Companion server not initialized', devices: [] };
    try {
      const devices = companionServer.getConnectedDevices();
      return { ok: true, devices };
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e), devices: [] };
    }
  });

  ipcMain.handle('companion:get-server-ip', async () => {
    try {
      const interfaces = os.networkInterfaces();
      const ips = [];
      
      for (const name of Object.keys(interfaces)) {
        for (const iface of interfaces[name]) {
          if (iface.family === 'IPv4' && !iface.internal) {
            ips.push(iface.address);
          }
        }
      }
      
      return { ok: true, ip: ips[0] || null, allIps: ips };
    } catch (e) {
      return { ok: false, error: e && e.message ? e.message : String(e) };
    }
  });

  const win = await createWindow();
  
  // Set main window reference for companion server notifications
  if (companionServer) {
    companionServer.setMainWindow(win);
  }
}

app.whenReady().then(() => {
  bootstrap().catch(err => {
    console.error('Bootstrap failed:', err);
    app.quit();
  });

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('will-quit', () => {
  if (companionServer) {
    companionServer.stop();
  }
});
