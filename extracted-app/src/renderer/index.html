<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --card:#121926; --muted:#8aa0b6; --text:#e8eef6; --accent:#4da3ff; --danger:#ff6b6b; --line:rgba(255,255,255,0.10); }
    [data-theme="light"] { --bg:#f8f9fa; --card:#ffffff; --muted:#6c757d; --text:#212529; --accent:#0d6efd; --danger:#dc3545; --line:rgba(0,0,0,0.10); }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); }
    header { padding: 14px 16px; border-bottom: 1px solid var(--line); position: sticky; top:0; background: var(--card); backdrop-filter: blur(8px); z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { font-size: 16px; margin:0; }
    .muted { color: var(--muted); font-size: 12px; }
    .wrap { padding: 14px; max-width: 1200px; margin: 0 auto; }
    .tabs { display:flex; gap:8px; flex-wrap: wrap; margin-top: 10px; }
    .tab { padding: 8px 10px; border-radius: 999px; border:1px solid var(--line); background: rgba(255,255,255,0.03); cursor:pointer; font-size: 13px; }
    .tab.active { background: rgba(77,163,255,0.22); border-color: rgba(77,163,255,0.55); }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 16px; padding: 14px; box-shadow: 0 8px 20px rgba(0,0,0,0.25); }
    .row { display:grid; grid-template-columns: repeat(12, minmax(0, 1fr)); gap:10px; align-items:end; }
    .row.align-top { align-items:start; }

    .col-12{grid-column:span 12} .col-8{grid-column:span 12} .col-6{grid-column:span 12} .col-4{grid-column:span 12} .col-3{grid-column:span 12} .col-2{grid-column:span 12}
    @media (min-width: 720px){ .col-8{grid-column:span 8} .col-6{grid-column:span 6} .col-4{grid-column:span 4} .col-3{grid-column:span 3} .col-2{grid-column:span 2} }
    label { font-size:12px; color: var(--muted); display:block; margin-bottom:6px; }
    input, select, textarea {
      width: 100%; padding: 10px 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04); color: var(--text);
      box-sizing: border-box; min-height: 42px; color-scheme: dark;
    }
    textarea { min-height: 90px; resize: vertical; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(77,163,255,0.18); color: var(--text); cursor:pointer; }
    button.primary { background: var(--accent); color: #06111f; font-weight: 700; border: none; }
    button.ghost { background: rgba(255,255,255,0.04); }
    button.danger { background: rgba(255,107,107,0.18); border-color: rgba(255,107,107,0.30); }
    button:disabled { opacity: 0.5; cursor:not-allowed; }
    .hr { height:1px; background: var(--line); margin: 12px 0; }
    .list { display:flex; flex-direction:column; gap:10px; }
    .item { padding:10px; border-radius:12px; border:1px solid var(--line); background: rgba(255,255,255,0.03); }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,0.12); margin-right:6px; }
    .pill.accent { border-color: rgba(77,163,255,0.55); background: rgba(77,163,255,0.14); }
    a { color: var(--accent); text-decoration: none; }

    details { border: 1px solid var(--line); border-radius: 14px; padding: 10px; background: rgba(255,255,255,0.02); }
    summary { cursor:pointer; user-select:none; font-weight:700; }
    summary { list-style: none; cursor: pointer; }
    summary::-webkit-details-marker { display:none; }
    summary::marker { display:none; }
    summary:before { content:"‚ñ∂"; display:inline-block; margin-right:8px; color: rgba(255,255,255,0.7); transform: translateY(-1px); }
    details[open] summary:before { content:"‚ñº"; }

    .modalBack { position: fixed; inset:0; background: rgba(0,0,0,0.55); display:none; align-items:center; justify-content:center; padding: 16px; z-index: 100; }
    
    /* Ensure the Recipe modal appears above the Meal Picker when both are open */
    #recipeModalBack { z-index: 110; }
    #mealPickerBack { z-index: 100; }

    .modal { width: min(1020px, 100%); background: var(--card); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 14px; box-shadow: 0 16px 40px rgba(0,0,0,0.45); max-height: 92vh; overflow:auto; }
    .modalHead { display:flex; justify-content:space-between; align-items:center; gap:10px; position: sticky; top: 0; background: var(--card); padding-bottom: 8px; z-index: 2; }
    .storeBadge { display:inline-block; padding:3px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.03); color: var(--text); margin-left:8px; }
    .mini { font-size: 12px; padding: 7px 10px; border-radius: 10px; }
  
/* ========== PROFESSIONAL PREMIUM STYLING (Option A) ========== */

/* Enhanced Card System */
.card {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  position: relative;
  overflow: hidden;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--accent) 0%, rgba(77,163,255,0.3) 100%);
  opacity: 0.6;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 32px rgba(0,0,0,0.4);
}

.card h2 {
  font-size: 18px;
  font-weight: 700;
  margin: 0 0 12px 0;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card h2::before {
  content: '';
  width: 4px;
  height: 20px;
  background: linear-gradient(135deg, var(--accent) 0%, rgba(77,163,255,0.5) 100%);
  border-radius: 2px;
}

/* Enhanced Buttons */
button {
  padding: 11px 16px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(77,163,255,0.18);
  color: var(--text);
  cursor: pointer;
  font-weight: 500;
  font-size: 14px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

button::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255,255,255,0.1);
  transform: translate(-50%, -50%);
  transition: width 0.4s ease, height 0.4s ease;
}

button:hover::before {
  width: 300px;
  height: 300px;
}

button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(77,163,255,0.3);
  border-color: rgba(77,163,255,0.4);
}

button.primary {
  background: linear-gradient(135deg, var(--accent) 0%, #3d8fdb 100%);
  color: #ffffff;
  font-weight: 700;
  border: none;
  box-shadow: 0 4px 12px rgba(77,163,255,0.4);
}

button.primary:hover {
  background: linear-gradient(135deg, #5eb3ff 0%, #4da3ff 100%);
  box-shadow: 0 6px 16px rgba(77,163,255,0.5);
  transform: translateY(-2px);
}

button.ghost {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.15);
}

button.ghost:hover {
  background: rgba(255,255,255,0.08);
  border-color: rgba(255,255,255,0.25);
}

button.danger {
  background: linear-gradient(135deg, rgba(255,107,107,0.25) 0%, rgba(255,107,107,0.15) 100%);
  border-color: rgba(255,107,107,0.4);
}

button.danger:hover {
  background: linear-gradient(135deg, rgba(255,107,107,0.35) 0%, rgba(255,107,107,0.25) 100%);
  box-shadow: 0 4px 12px rgba(255,107,107,0.3);
}

/* Enhanced Form Controls */
input, select, textarea {
  width: 100%;
  padding: 12px 14px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.05);
  color: var(--text);
  box-sizing: border-box;
  min-height: 44px;
  color-scheme: dark;
  transition: all 0.2s ease;
  font-size: 14px;
}

input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: var(--accent);
  background: rgba(255,255,255,0.08);
  box-shadow: 0 0 0 3px rgba(77,163,255,0.15);
}

textarea {
  min-height: 100px;
  resize: vertical;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
}

/* Enhanced Items/List */
.item {
  padding: 14px 16px;
  border-radius: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,0.04);
  transition: all 0.2s ease;
  position: relative;
}

.item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background: linear-gradient(180deg, var(--accent) 0%, rgba(77,163,255,0.3) 100%);
  border-radius: 12px 0 0 12px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.item:hover {
  background: rgba(255,255,255,0.06);
  border-color: rgba(77,163,255,0.3);
  transform: translateX(2px);
}

.item:hover::before {
  opacity: 1;
}

/* Enhanced Pills/Badges */
.pill {
  display: inline-block;
  padding: 5px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 600;
  border: 1px solid rgba(255,255,255,0.15);
  margin-right: 6px;
  background: rgba(255,255,255,0.05);
  transition: all 0.2s ease;
}

.pill.accent {
  border-color: rgba(77,163,255,0.6);
  background: rgba(77,163,255,0.2);
  color: #5eb3ff;
  box-shadow: 0 2px 8px rgba(77,163,255,0.2);
}

/* Section Headers */
.card > label:first-of-type,
.card h3 {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  margin: 16px 0 10px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.card h3::before {
  content: '';
  width: 3px;
  height: 16px;
  background: linear-gradient(135deg, var(--accent) 0%, rgba(77,163,255,0.5) 100%);
  border-radius: 2px;
}

/* Horizontal Divider */
.hr {
  height: 1px;
  background: linear-gradient(90deg, transparent 0%, var(--line) 20%, var(--line) 80%, transparent 100%);
  margin: 20px 0;
  border: none;
}

/* Details/Accordion Enhancement */
details {
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 14px;
  background: rgba(255,255,255,0.03);
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

details:hover {
  background: rgba(255,255,255,0.05);
  border-color: rgba(77,163,255,0.3);
}

details[open] {
  background: rgba(255,255,255,0.06);
  border-color: rgba(77,163,255,0.4);
}

summary {
  cursor: pointer;
  user-select: none;
  font-weight: 600;
  font-size: 14px;
  padding: 4px 0;
  transition: color 0.2s ease;
}

summary:hover {
  color: var(--accent);
}

/* Tab Enhancement */
.tab {
  padding: 10px 16px;
  border-radius: 999px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,0.04);
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s ease;
  position: relative;
}

.tab:hover {
  background: rgba(255,255,255,0.08);
  border-color: rgba(77,163,255,0.3);
  transform: translateY(-1px);
}

.tab.active {
  background: linear-gradient(135deg, rgba(77,163,255,0.3) 0%, rgba(77,163,255,0.15) 100%);
  border-color: rgba(77,163,255,0.7);
  color: #5eb3ff;
  font-weight: 600;
  box-shadow: 0 2px 8px rgba(77,163,255,0.2);
}

/* Status Messages */
.muted {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.5;
}

#recipeStatus, #storeStatus, #calStatus, #clearStatus, #generateWeekStatus,
#cuisineManageStatus, #mealPlannerPrefsStatus {
  font-size: 13px;
  padding: 4px 0;
  font-weight: 500;
}

/* ========== END PROFESSIONAL STYLING ========== */

.ingGrid select, .ingGrid input { width:100%; box-sizing:border-box; }
.ingGrid .row { align-items:flex-end; }

/* Letter headers for recipe list - NOT sticky */
.letter-header {
  padding: 10px 12px;
  font-size: 14px;
  font-weight: 700;
  color: #ffffff;
  background: #1a4d7c;
  border-bottom: 2px solid var(--accent);
  border-radius: 6px;
  margin-bottom: 12px;
  margin-top: 16px;
}

/* Ensure recipe items don't overlap sticky headers */
#recipesList .item {
  position: relative;
  z-index: 1;
}

/* Recipe scaling controls */
.scale-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  background: linear-gradient(135deg, rgba(77,163,255,0.15) 0%, rgba(77,163,255,0.05) 100%);
  border: 1px solid rgba(77,163,255,0.4);
  border-radius: 10px;
  margin-bottom: 14px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}
.scale-controls label {
  margin: 0;
  color: var(--text);
  font-size: 13px;
  font-weight: 600;
}
.scale-controls button {
  padding: 8px 14px;
  font-size: 16px;
  font-weight: 600;
  background: rgba(77,163,255,0.25);
  border: 1px solid rgba(77,163,255,0.5);
  border-radius: 6px;
  min-width: 40px;
  color: var(--accent);
}
.scale-controls button:hover {
  background: rgba(77,163,255,0.4);
}
.scale-value {
  font-weight: 700;
  min-width: 50px;
  text-align: center;
  font-size: 18px;
  color: var(--accent);
  text-shadow: 0 0 10px rgba(77,163,255,0.5);
}

/* Auto-classification indicator */
.auto-cat-indicator {
  font-size: 11px;
  color: var(--muted);
  margin-left: 4px;
}
.auto-cat-active {
  color: #22c55e;
}

/* Calendar Grid View */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
  margin-top: 12px;
}
.grid-day {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 8px;
  min-height: 200px;
}
.grid-day-header {
  font-weight: 700;
  font-size: 12px;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid var(--line);
  color: var(--accent);
}
.grid-meal {
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.10);
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 8px;
  font-size: 13px;
  cursor: grab;
  transition: all 0.2s;
  min-height: 60px;
}
.grid-meal:hover {
  background: rgba(77,163,255,0.15);
  border-color: rgba(77,163,255,0.4);
}
.grid-meal.dragging {
  opacity: 0.5;
  cursor: grabbing;
}
.grid-meal-label {
  font-weight: 600;
  font-size: 11px;
  color: var(--muted);
  margin-bottom: 4px;
}
.grid-meal-title {
  font-size: 13px;
  line-height: 1.4;
}
.grid-meal.breakfast {
  border-left: 3px solid #f59e0b;
}
.grid-meal.lunch {
  border-left: 3px solid #10b981;
}
.grid-meal.dinner {
  border-left: 3px solid #8b5cf6;
}
.grid-meal.cuisine-italian { background: rgba(76, 175, 80, 0.1); }
.grid-meal.cuisine-chinese { background: rgba(244, 67, 54, 0.1); }
.grid-meal.cuisine-mexican { background: rgba(255, 152, 0, 0.1); }
.grid-meal.cuisine-indian { background: rgba(156, 39, 176, 0.1); }
.grid-meal.cuisine-japanese { background: rgba(233, 30, 99, 0.1); }
.grid-meal.cuisine-american { background: rgba(63, 81, 181, 0.1); }

/* Grid view additional items */
.grid-meal[data-has-additional="true"] {
  position: relative;
}

.grid-additional-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: #4da3ff;
  color: white;
  font-size: 10px;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 10px;
  line-height: 1.2;
}

.grid-expand-btn {
  position: absolute;
  bottom: 4px;
  right: 4px;
  background: rgba(77,163,255,0.2);
  color: var(--accent);
  border: 1px solid rgba(77,163,255,0.3);
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  padding: 2px 6px;
  line-height: 1;
  transition: all 0.2s;
}

.grid-expand-btn:hover {
  background: rgba(77,163,255,0.3);
  border-color: rgba(77,163,255,0.5);
}

.grid-additional-popover {
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.2);
  min-width: 250px;
  max-width: 400px;
}

.grid-empty-slot {
  background: rgba(255,255,255,0.02);
  border: 1px dashed rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 6px;
  margin-bottom: 6px;
  font-size: 11px;
  color: var(--muted);
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
}
.grid-empty-slot:hover {
  background: rgba(77,163,255,0.1);
  border-color: rgba(77,163,255,0.3);
  color: var(--accent);
}

/* Drag and drop states */
.drag-over {
  background: rgba(77,163,255,0.2) !important;
  border-color: rgba(77,163,255,0.6) !important;
}

/* Meal Planner Preferences Modal Styling */
.prefs-section {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
}

.prefs-section-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.prefs-section-title span {
  display: flex;
  align-items: center;
  gap: 8px;
}

.prefs-section-title span::before {
  content: '';
  width: 4px;
  height: 18px;
  background: linear-gradient(135deg, var(--accent) 0%, rgba(77,163,255,0.5) 100%);
  border-radius: 2px;
}

.cuisine-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 10px;
}

.cuisine-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin: 0;
}

.cuisine-option:hover {
  background: rgba(77,163,255,0.08);
  border-color: rgba(77,163,255,0.3);
  transform: translateY(-1px);
}

.cuisine-option input[type="checkbox"] {
  width: 18px;
  height: 18px;
  min-height: 18px;
  margin: 0;
  cursor: pointer;
  accent-color: var(--accent);
}

.cuisine-option span {
  font-size: 14px;
  color: var(--text);
  user-select: none;
}

.cuisine-option input[type="checkbox"]:checked + span {
  color: var(--accent);
  font-weight: 500;
}

.variety-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.variety-option {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin: 0;
}

.variety-option:hover {
  background: rgba(77,163,255,0.08);
  border-color: rgba(77,163,255,0.3);
}

.variety-option input[type="checkbox"] {
  width: 18px;
  height: 18px;
  min-height: 18px;
  margin-top: 2px;
  cursor: pointer;
  accent-color: var(--accent);
  flex-shrink: 0;
}

.variety-option-content {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.variety-option-title {
  font-size: 14px;
  color: var(--text);
  user-select: none;
}

.variety-option-desc {
  font-size: 12px;
  color: var(--muted);
  user-select: none;
}

.variety-option input[type="checkbox"]:checked ~ .variety-option-content .variety-option-title {
  color: var(--accent);
  font-weight: 500;
}

.breakfast-select-wrapper {
  position: relative;
}

.breakfast-select-wrapper select {
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%238aa0b6' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
  padding-right: 36px;
  font-size: 14px;
}

.prefs-save-section {
  display: flex;
  align-items: center;
  gap: 12px;
  padding-top: 8px;
}

.prefs-save-section button {
  min-width: 180px;
}

/* Companion Panel Styles */
.companion-float-btn {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  border: none;
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(77,163,255,0.4);
  z-index: 999;
  transition: transform 0.2s;
}

.companion-float-btn:hover {
  transform: scale(1.1);
}

.companion-panel {
  position: fixed;
  bottom: 90px;
  right: 24px;
  width: 320px;
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  z-index: 998;
  display: none;
}

.companion-panel.show {
  display: block;
}

.companion-status {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 13px;
}

.companion-status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #10b981;
}

.companion-status-dot.offline {
  background: #6b7280;
}

.companion-device {
  padding: 8px;
  background: rgba(255,255,255,0.04);
  border: 1px solid var(--line);
  border-radius: 8px;
  margin-bottom: 8px;
  font-size: 13px;
}

.companion-action-btn {
  width: 100%;
  margin-bottom: 8px;
  background: rgba(77,163,255,0.18);
  border: 1px solid rgba(77,163,255,0.3);
  padding: 10px;
  border-radius: 10px;
  color: var(--text);
  cursor: pointer;
  transition: background 0.2s;
}

.companion-action-btn:hover {
  background: rgba(77,163,255,0.28);
}

.companion-action-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

</style>
</head>
<body>
  <header>
    <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
      <div>
        <h1>Foodie Meal Planner</h1>
        <div class="muted">Local desktop app (Planner + Bulk Planner + Recipes + Shopping List + Pantry + Admin) ‚Ä¢ SQLite + Apple Calendar</div>
      </div>
      <div style="display:flex; align-items:center; gap:12px;">
        <button id="btnThemeToggle" class="ghost" style="padding:8px 12px; font-size:20px; line-height:1;" title="Toggle light/dark mode">üåì</button>
        <div class="muted" id="topStatus"></div>
      </div>
    </div>
    <div class="tabs" id="tabs">
      <div class="tab active" data-tab="planner">Planner</div>
      <div class="tab" data-tab="recipes">Recipes</div>
      <div class="tab" data-tab="collections">Collections</div>
      <div class="tab" data-tab="shop">Shopping List</div>
      <div class="tab" data-tab="pantry">Pantry</div>
      <div class="tab" data-tab="admin">Admin</div>
    </div>
  </header>

  <div class="wrap">
    <!-- PLANNER -->
    <section id="tab-planner" class="grid">
      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Planner</h2>
        <div class="muted">Set meals per day. Pick/replace and clear meals. (Uses plans/{YYYY-MM-DD})</div>

        <div class="hr"></div>

        <div class="row">
          <div class="col-4">
            <label>Start date</label>
            <input type="date" id="planStart">
          </div>
          <div class="col-4">
            <label>End date</label>
            <input type="date" id="planEnd">
            <input type="number" id="planDays" min="1" max="60" value="1" style="display:none;">
          </div>
          <div class="col-4">
            <label>Actions</label>
            <div class="actions">
              <button class="ghost" id="btnPlanCollapseAll">Collapse all</button>
              <button class="ghost" id="btnPlanExpandAll">Expand all</button>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <!-- View Toggle -->
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <button class="ghost" id="btnPlanViewList">üìã List View</button>
          <button class="ghost" id="btnPlanViewGrid" style="border-color:rgba(77,163,255,0.55);">üìÖ Grid View</button>
        </div>

        <!-- List View -->
        <div id="planList" class="list" style="display:none;"></div>

        <!-- Grid View -->
        <div id="planGrid"></div>
      </div>

      <!-- Bulk Meal Operations -->
      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Bulk Meal Operations</h2>
        <div class="muted">Quick operations for managing multiple meals at once.</div>
        <div class="hr"></div>

        <div class="row">
          <div class="col-12">
            <label>Copy Week</label>
            <div class="actions">
              <button class="ghost" id="btnCopyWeekForward" title="Copy this week's meals to next week">Copy This Week ‚Üí Next Week</button>
              <button class="ghost" id="btnCopyWeekBack" title="Copy this week's meals to previous week">Copy This Week ‚Üí Previous Week</button>
              <span class="muted" id="copyWeekStatus"></span>
            </div>
          </div>

          <div class="col-12">
            <label>Auto-Fill Breakfast</label>
            <div class="actions" style="align-items:flex-start;">
              <div style="position:relative; width:300px;">
                <input type="text" id="autoFillBreakfastSearch" placeholder="Search breakfast recipes..." style="width:100%; padding:8px; box-sizing:border-box;">
                <div id="autoFillBreakfastDropdown" style="display:none; position:absolute; top:100%; left:0; right:0; background:var(--card); border:1px solid var(--line); border-radius:8px; max-height:200px; overflow-y:auto; z-index:10; margin-top:4px;"></div>
                <input type="hidden" id="autoFillBreakfastRecipe">
              </div>
              <button class="ghost" id="btnAutoFillBreakfast">Auto-Fill Empty Breakfasts</button>
              <span class="muted" id="autoFillStatus"></span>
            </div>
          </div>

          <div class="col-12">
            <label>Meal Pattern Templates</label>
            <div class="actions">
              <button class="ghost" id="btnSaveMealPattern">Save Current Week as Template</button>
              <button class="ghost" id="btnLoadMealPattern">Load Template</button>
              <span class="muted" id="templateStatus"></span>
            </div>
          </div>

          <div class="col-12">
            <div class="hr"></div>
            <label>ü§ñ Smart Weekly Meal Planner</label>
            <div class="muted" style="margin-bottom:12px;">Automatically generate a balanced week of meals based on your preferences</div>
            
            <div class="row" style="margin-bottom:12px;">
              <div class="col-3">
                <label>Start Date</label>
                <input type="date" id="genStartDate">
              </div>
              <div class="col-3">
                <label>End Date</label>
                <input type="date" id="genEndDate">
              </div>
              <div class="col-6">
                <label>Actions</label>
                <div class="actions">
                  <button class="primary" id="btnGenerateWeek" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">‚ú® Generate This Week</button>
                  <button class="ghost" id="btnMealPlannerSettings">‚öôÔ∏è Preferences</button>
                  <span class="muted" id="generateWeekStatus"></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Calendar Sync</h2>
        <div class="muted">Sync planned meals to Apple Calendar (macOS). The app will ask for permission the first time.</div>
        <div class="hr"></div>

        <div class="row align-top">
          <div class="col-6">
            <label>Calendar name</label>
            <input id="calId" value="Foodie Meal Planner">
            <div class="muted">Enter the Apple Calendar name exactly as it appears in the Calendar app.</div>
          </div>
          <div class="col-6">
            <label>Range</label>
            <div class="actions">
              <button class="primary" id="btnCalSync">Sync current range</button>
            </div>
            <div class="muted" id="calStatus"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">üåê Google Calendar Sync (Direct)</h2>
        <div class="muted">Sync meals directly to Google Calendar - no Apple Calendar needed. Syncs to YOUR Google account from any computer.</div>
        <div class="hr"></div>

        <!-- Setup Section -->
        <div id="googleCalSetup" style="margin-bottom: 20px;">
          <div style="font-weight: 600; margin-bottom: 12px;">Initial Setup (One-Time)</div>
          
          <div class="row">
            <div class="col-6">
              <label>1. Upload Google Credentials</label>
              <input type="file" id="googleCredentialsFile" accept=".json" style="margin-bottom: 8px;">
              <div class="muted">Download from Google Cloud Console (see setup guide)</div>
              <button class="ghost" id="btnUploadGoogleCreds" style="margin-top: 8px;">Load Credentials File</button>
            </div>
            <div class="col-6">
              <label>Status</label>
              <div id="googleCredsStatus" class="muted">Not configured</div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="row">
            <div class="col-12">
              <label>2. Authorize Google Account</label>
              <div class="actions" style="margin-bottom: 8px;">
                <button class="primary" id="btnGoogleAuthorize" disabled>Open Authorization Page</button>
                <a id="googleAuthLink" href="#" target="_blank" style="display:none;">Or click here</a>
              </div>
              <div class="muted">Sign in with YOUR Google account and grant calendar permissions</div>
            </div>
          </div>

          <div class="row" id="googleAuthCodeRow" style="display:none; margin-top: 12px;">
            <div class="col-8">
              <label>3. Enter Authorization Code</label>
              <input type="text" id="googleAuthCode" placeholder="Paste code from Google">
            </div>
            <div class="col-4">
              <label>Submit</label>
              <button class="primary" id="btnGoogleAuthSubmit">Complete Authorization</button>
            </div>
          </div>

          <div id="googleAuthStatus" class="muted" style="margin-top: 8px;"></div>
        </div>

        <div class="hr"></div>

        <!-- Calendar Selection & Sync -->
        <div id="googleCalSync">
          <div style="font-weight: 600; margin-bottom: 12px;">Sync Settings</div>
          
          <div class="row" style="align-items: flex-end;">
            <div class="col-2">
              <label>Start Date</label>
              <input type="date" id="googleSyncStart">
            </div>
            <div class="col-2">
              <label>End Date</label>
              <input type="date" id="googleSyncEnd">
            </div>
            <div class="col-5">
              <label>Target Google Calendar</label>
              <select id="googleCalendarSelect" disabled>
                <option value="">-- Select calendar --</option>
                <option value="primary">Primary</option>
              </select>
            </div>
            <div class="col-3">
              <label>&nbsp;</label>
              <button class="primary" id="btnGoogleCalSync" disabled style="background: linear-gradient(135deg, #4285f4 0%, #34a853 100%); width: 100%;">üåê Sync to Google Calendar</button>
            </div>
          </div>
          
          <div class="row" style="margin-top: 12px;">
            <div class="col-12">
              <button class="ghost" id="btnListGoogleCals" disabled>Refresh Calendar List</button>
              <button class="ghost" id="btnCheckDuplicates" disabled style="margin-left: 8px;">üîç Check for Duplicates</button>
              <div class="muted" id="googleSyncStatus" style="margin-top: 8px;"></div>
              <div class="muted" id="googleDuplicateStatus" style="margin-top: 8px;"></div>
            </div>
          </div>

          <div class="hr" style="margin-top: 16px;"></div>

          <div class="row">
            <div class="col-12">
              <details>
                <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">Advanced Options</summary>
                <div style="margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px;">
                  <button class="danger" id="btnRevokeGoogleCal">Revoke Google Calendar Access</button>
                  <div class="muted" style="margin-top: 8px;">Remove Foodie's access to your Google Calendar. You'll need to re-authorize to sync again.</div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Clear Meals</h2>
        <div class="muted">Remove meals from the planner. Use with caution - this action cannot be undone.</div>
        <div class="hr"></div>

        <div class="row">
          <div class="col-4">
            <label>Clear Start Date</label>
            <input type="date" id="clearStart">
          </div>
          <div class="col-4">
            <label>Clear End Date</label>
            <input type="date" id="clearEnd">
          </div>
          <div class="col-4">
            <label>Actions</label>
            <div class="actions">
              <button class="danger" id="btnClearRange">Clear Date Range</button>
              <button class="danger" id="btnClearAll">Clear All Meals</button>
            </div>
          </div>
        </div>
        <div class="muted" id="clearStatus" style="margin-top:8px;"></div>
      </div>
    </section>

    <!-- BULK PLANNER -->
    <section id="tab-bulk" class="grid" style="display:none;">
      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Bulk Planner</h2>
        <div class="muted">Same data as Planner, but optimized for quick multi-day planning and swapping.</div>
        <div class="hr"></div>

        <div class="row">
          <div class="col-4">
            <label>Start date</label>
            <input type="date" id="bulkStart">
          </div>
          <div class="col-4">
            <label>End date</label>
            <input type="date" id="bulkEnd">
            <input type="number" id="bulkDays" min="1" max="60" value="14" style="display:none;">
          </div>
          <div class="col-4">
            <label>Actions</label>
            <div class="actions">
              <button class="primary" id="btnBulkLoad">Load</button>
              <button class="ghost" id="btnBulkCollapseAll">Collapse all</button>
              <button class="ghost" id="btnBulkExpandAll">Expand all</button>
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <div id="bulkList" class="list"></div>
      </div>
    </section>

    <!-- RECIPES -->
    <section id="tab-recipes" class="grid" style="display:none;">
      <div class="card">
        <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
          <h2 style="margin:0; font-size:16px;">Recipe Manager</h2>
          <div>
            <span class="pill accent" id="pillCount">Loaded: 0</span>
            <span class="pill" id="pillMode">Local search</span>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="col-12">
            <label>Search recipes (searches the entire collection; not just loaded ones)</label>
            <input id="recipeSearch" placeholder="Type to search..." />
            <div style="margin-top:8px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; margin:0;">
                <input type="checkbox" id="recipeFavoritesOnly" style="cursor:pointer;" />
                <span style="color:var(--muted); font-size:13px;">Favorites only</span>
              </label>
              <select id="recipeCuisineFilter" style="width:auto; padding:6px 10px; min-height:auto;">
                <option value="">All Cuisines</option>
              </select>
              <div class="muted" id="recipeStatus"></div>
            </div>
          </div>

          <div class="col-12">
            <div class="actions">
              <button class="primary" id="btnAddRecipe">Add Recipe</button>
              <button class="primary" id="btnImportRecipe" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üîó Import from URL</button>
              <button class="ghost" id="btnRefresh">Reset</button>
              <select id="jumpLetter" class="mini">
                <option value="">Jump A‚ÄìZ</option>
              </select>
            </div>
          </div>
        </div>

        <div class="list" id="recipesList" style="max-height: 650px; overflow:auto;"></div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Stores</h2>
        <div class="muted">Stores appear in ingredient Store dropdown. Add a store and it will be available immediately. Use the Delete button to remove stores.</div>
        <div class="hr"></div>
        
        <h3 style="margin:12px 0 8px 0;font-size:14px;font-weight:600;">Add New Store</h3>
        <div class="row">
          <div class="col-8">
            <label>Store name</label>
            <input id="newStoreName" placeholder="e.g., Costco">
          </div>
          <div class="col-4">
            <label>Priority (lower = earlier)</label>
            <input id="newStorePriority" type="number" value="10">
          </div>
          <div class="col-12">
            <div class="actions">
              <button class="primary" id="btnAddStore">Add Store</button>
              <button class="ghost" id="btnReloadStores">Reload</button>
              <span class="muted" id="storeStatus"></span>
            </div>
          </div>
        </div>
        
        <div class="hr"></div>
        
        <h3 style="margin:12px 0 8px 0;font-size:14px;font-weight:600;">Existing Stores</h3>
        <div id="storeList" class="list"></div>
      </div>
    </section>

    <!-- RECIPE COLLECTIONS -->
    <section id="tab-collections" class="grid" style="display:none;">
      <div class="card">
        <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
          <h2 style="margin:0; font-size:16px;">Recipe Collections</h2>
          <button class="primary" id="btnCreateCollection">Create Collection</button>
        </div>
        <div class="muted">Organize recipes into custom collections (e.g., Quick Weeknight Dinners, Holiday Recipes)</div>

        <div class="hr"></div>

        <div class="row">
          <div class="col-12">
            <label>Filter by Collection</label>
            <select id="collectionFilter" style="margin-bottom:12px;">
              <option value="">All Recipes</option>
            </select>
          </div>
        </div>

        <div id="collectionsList" class="list"></div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Recipes in Selected Collection</h2>
        <div class="muted" id="collectionRecipesSubtitle">Select a collection above to view recipes</div>
        <div class="hr"></div>
        <div id="collectionRecipesList" class="list"></div>
      </div>
    </section>

    <!-- SHOPPING LIST -->
    <section id="tab-shop" class="grid" style="display:none;">
      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Shopping List</h2>
        <div class="muted">Generates from planned meals in a date range.</div>
        <div class="hr"></div>
        <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 4px;">
            <span style="font-size: 0.9em;">Start:</span>
            <input type="date" id="shopStart" style="padding: 6px 8px;">
          </label>
          <label style="display: flex; align-items: center; gap: 4px;">
            <span style="font-size: 0.9em;">End:</span>
            <input type="date" id="shopEnd" style="padding: 6px 8px;">
          </label>
          <button class="primary" id="btnBuildShop">Generate</button>
          <button class="ghost" id="btnPrintShopAll">Print all stores</button>
          <button class="danger" id="btnClearShop">Clear list</button>
          <label style="display: flex; align-items: center; gap: 4px; margin-left: auto; font-size: 0.85em; cursor: pointer; font-weight: normal;">
            <input type="checkbox" id="shopIncludeLowStock" style="cursor: pointer; width: 14px; height: 14px;">
            <span style="color: #666;">Add low-stock pantry items</span>
          </label>
        </div>
        
        <!-- Collection Inclusion Section -->
        <div class="hr"></div>
        <div class="item" style="background: rgba(77,163,255,0.08);">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 600; font-size: 14px; margin-bottom: 0;">
            <input type="checkbox" id="shopIncludeCollections" style="cursor: pointer; width: 16px; height: 16px;">
            <span style="color: var(--text);">Include collections in shopping list</span>
          </label>
          
          <div id="collectionInclusionOptions" style="display:none; margin-top:16px;">
            <div style="margin-bottom:12px;">
              <label style="display:block; margin-bottom:8px; font-size:12px; color: var(--muted);">Select Collections:</label>
              <select id="shopCollectionSelect" multiple size="4" style="min-height: 100px;">
                <!-- Populated dynamically -->
              </select>
              <div class="muted" style="margin-top:6px;">Hold Cmd/Ctrl to select multiple</div>
            </div>
            
            <div style="margin-bottom:12px;">
              <div style="font-size:13px; font-weight:600; color: var(--text); margin-bottom:8px;">Inclusion Mode:</div>
              <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                <input type="radio" name="shopCollectionMode" value="independent" checked style="cursor:pointer; width:16px; height:16px;">
                <span style="font-size:13px; color: var(--text);">Independent (add to shopping list, no date tie)</span>
              </label>
              <div class="muted" style="margin-left:24px; margin-bottom:8px;">
                Collections will be added to the shopping list regardless of planned meals
              </div>
            </div>
            
            <div class="item" style="background:rgba(255,193,7,0.14); border-color: rgba(255,193,7,0.30);">
              <div class="muted" style="color: var(--text); opacity: 0.9;">
                <strong>üí° Note:</strong> If collection recipes are already in your date range, ingredients won't be duplicated.
              </div>
            </div>
          </div>
        </div>
        
        <div class="hr"></div>
        <div id="shopOut" class="list"></div>
      </div>
    </section>

    <!-- PANTRY -->
    <section id="tab-pantry" class="grid" style="display:none;">
      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Pantry</h2>
        <div class="muted">Simple pantry tracker (add/edit/remove).</div>
        <div class="hr"></div>
        <div class="row">
          <div class="col-4">
            <label>Search pantry</label>
            <input id="pantrySearch" placeholder="e.g., rice">
          </div>
          <div class="col-4">
            <label>Filter</label>
            <select id="pantryFilter">
              <option value="all">All Items</option>
              <option value="low">Low Stock Only</option>
            </select>
          </div>
          <div class="col-4">
            <label>Actions</label>
            <div class="actions">
              <button class="primary" id="btnPantryAdd">Add item</button>
              <button class="ghost" id="btnPantryPrint">Print</button>
            </div>
          </div>
        </div>
        <div class="hr"></div>
        
        <!-- Expiring Soon Widget -->
        <div id="expiringItemsWidget" style="display:none; background:rgba(255,193,7,0.15); border:1px solid rgba(255,193,7,0.4); border-radius:10px; padding:12px; margin-bottom:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div style="font-weight:600; color:#ffb300;">‚ö†Ô∏è Expiring Soon</div>
            <button id="btnDismissExpiring" class="ghost" style="padding:4px 8px; font-size:11px;">Dismiss</button>
          </div>
          <div id="expiringItemsList" style="font-size:13px;"></div>
        </div>
        
        <div id="pantryList" class="list"></div>
      </div>
    </section>

    <!-- ADMIN -->
    <section id="tab-admin" class="grid" style="display:none;">
      <div class="card" id="adminIngredientCategories" style="margin-top:12px;">
        <h2 style="margin:0 0 8px 0;">Ingredient Categories</h2>
        <div class="muted" style="margin-bottom:8px;">
          These categories populate the Category dropdown on recipe ingredients and control shopping list category ordering.
          Existing ingredients keep their current Category text even if you remove a category from this list.
        </div>
        <label>One category per line</label>
        <textarea id="adminCategoriesText" rows="8" style="width:100%;"></textarea>
        <div class="actions" style="margin-top:8px;">
          <button id="btnSaveIngredientCategories" class="primary">Save Categories</button>
          <button id="btnResetIngredientCategories">Reset to Defaults</button>
        </div>
        <div class="muted" id="adminCategoriesStatus" style="margin-top:6px;"></div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0; font-size:16px;">Admin</h2>
        <div class="muted">Import/Export your data to sync across multiple installations.</div>
        <div class="hr"></div>

        <div class="row">
          <div class="col-12">
            <label>Data sync</label>
            <div class="actions">
              <button class="primary" id="btnExportData">Export data‚Ä¶</button>
              <button class="ghost" id="btnImportData">Import data‚Ä¶</button>
              <span class="muted" id="adminStatus"></span>
            </div>
            <div class="muted" style="margin-top:8px;">
              Export creates a copy of your sqlite database. Import replaces your current local database with the selected file.
            </div>
          </div>
        </div>
        
        <div class="hr"></div>
        
        <div class="row">
          <div class="col-12">
            <label>Recipe Categories</label>
            <div class="actions">
              <button class="ghost" id="btnFixCategories" style="border-color: var(--accent); color: var(--accent);">Fix All Recipe Categories</button>
              <span class="muted" id="fixCategoriesStatus"></span>
            </div>
            <div class="muted" style="margin-top:8px;">
              Re-categorize all ingredients in all recipes and save to database. Use this if shopping list categories aren't working.
            </div>
          </div>
        </div>

        <div class="hr"></div>
        
        
        <div class="row">
          <div class="col-12">
            <label>Manage Cuisines</label>
            <div class="muted" style="margin-bottom:12px;">
              Add new cuisines, rename existing ones, or clear them from recipes.
            </div>
            
            <!-- Add new cuisine -->
            <div style="display:flex; gap:8px; margin-bottom:12px; align-items:center;">
              <input type="text" id="newCuisineName" placeholder="Add new cuisine..." style="flex:1; min-width:200px;" />
              <button class="primary" id="btnAddCuisine">Add Cuisine</button>
            </div>
            
            <div id="cuisineManageList" class="list" style="max-height:400px; overflow-y:auto;">
              <!-- Dynamically populated -->
            </div>
            <div class="muted" id="cuisineManageStatus" style="margin-top:8px;"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- RECIPE MODAL -->
  <div class="modalBack" id="recipeModalBack">
    <div class="modal">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;" id="rmTitle">Recipe</div>
          <div class="muted" id="rmSub">View/Edit recipe + instructions + ingredients.</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnModalToggleEdit">Edit</button>
          <button class="ghost" id="btnModalClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Recipe title</label>
          <input id="rTitle" placeholder="e.g., Cold Sesame Noodles" tabindex="1">
        </div>

        <div class="col-12">
          <label>Recipe URL</label>
          <input id="rUrl" placeholder="https://..." tabindex="2">
          <div class="muted" id="rUrlView" style="margin-top:6px;"></div>
        </div>

        <div class="col-6">
          <label>Cuisine</label>
          <select id="rCuisine" tabindex="3"></select>
        </div>

        <div class="col-6">
          <label>MealType</label>
          <select id="rMealType" tabindex="4">
            <option value="Any">Any</option>
            <option value="Breakfast">Breakfast</option>
            <option value="Brunch">Brunch</option>
            <option value="Lunch">Lunch</option>
            <option value="Dinner">Dinner</option>
            <option value="Side Dish">Side Dish</option>
            <option value="Appetizer">Appetizer</option>
            <option value="Snack">Snack</option>
            <option value="Dessert">Dessert</option>
            <option value="Beverage">Beverage</option>
          </select>
        </div>

        <div class="col-12">
          <label>Instructions</label>
          <textarea id="rInstructions" placeholder="Step-by-step..." tabindex="5"></textarea>
        </div>

        <div class="col-12">
          <label>Notes</label>
          <textarea id="rNotes" placeholder="Any notes" tabindex="6"></textarea>
        </div>
      </div>

      <div class="hr"></div>

      <!-- Recipe Scaling Controls - Always Visible -->
      <div class="scale-controls" id="scaleControls">
        <label>Scale Recipe:</label>
        <button class="ghost" data-action="scale-down" title="Decrease serving size">‚àí</button>
        <span class="scale-value" id="scaleValue">1.0x</span>
        <button class="ghost" data-action="scale-up" title="Increase serving size">+</button>
        <button class="ghost" data-action="scale-reset" title="Reset to original">Reset</button>
      </div>

      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
        <div>
          <div style="font-weight:700;">Ingredients <span class="muted" style="font-weight:400;font-size:12px;">(Type name to auto-categorize)</span></div>
          <div class="muted">We show a clean "Ingredient" input (raw). Normalized is hidden by default for UX.</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnCategorizeAll" title="Categorize all uncategorized ingredients">Categorize All</button>
          <button class="ghost" id="btnAddIngredientRow">Add row</button>
        </div>
      </div>

      <div class="hr"></div>
      <div id="ingTableWrap"></div>

      <div class="hr"></div>

      <div class="actions" id="modalActions">
        <button class="primary" id="btnPrintRecipe">Print Recipe</button>
        <button class="primary" id="btnSaveRecipeFull">Save Recipe + Ingredients</button>
        <button class="danger" id="btnDeleteRecipe">Delete Recipe</button>
        <span class="muted" id="rmStatus"></span>
      </div>

      <!-- View Mode Actions (visible only in view mode) -->
      <div class="actions" id="viewModeActions" style="display:none;">
        <button class="primary" id="btnPrintRecipeView">Print Recipe</button>
      </div>
    </div>
  </div>

  <!-- MEAL PICKER MODAL -->
  <div class="modalBack" id="mealPickerBack">
    <div class="modal">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;" id="mpTitle">Pick a recipe</div>
          <div class="muted" id="mpSub"></div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnMealPickerClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Search recipes</label>
          <input id="mpSearch" placeholder="type to search...">
          <div class="muted" id="mpStatus" style="margin-top:6px;"></div>
        </div>
        <div class="col-12">
          <div class="actions">
            <button class="danger" id="mpClearMeal">Clear meal</button>
            <button class="ghost" id="mpUseLeftovers">Use Leftovers</button>
            <button class="ghost" id="mpUseCollection">Use Collection Recipe</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>
      <div id="mpList" class="list" style="max-height: 70vh; overflow:auto;"></div>
    </div>
  </div>

  <!-- LEFTOVERS PICKER MODAL -->
  <div class="modalBack" id="leftoverPickerBack" style="z-index: 105;">
    <div class="modal" style="max-width: 600px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">Pick Leftovers</div>
          <div class="muted">Select a meal from the past 3 days</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnLeftoverPickerClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>
      <div id="leftoverList" class="list" style="max-height: 60vh; overflow:auto;"></div>
    </div>
  </div>

  <!-- COLLECTION RECIPE PICKER MODAL -->
  <div class="modalBack" id="collectionRecipePickerBack" style="z-index: 105;">
    <div class="modal" style="max-width: 700px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">Pick Collection Recipe</div>
          <div class="muted">Select a recipe from your collections</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnCollectionRecipePickerClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Select Collection</label>
          <select id="collectionRecipePickerSelect">
            <option value="">-- Choose a collection --</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>
      <div id="collectionRecipePickerList" class="list" style="max-height: 60vh; overflow:auto;">
        <div class="muted">Select a collection to view recipes</div>
      </div>
    </div>
  </div>

  <!-- ASSIGN TO PLANNER MODAL -->
  <div class="modalBack" id="assignToPlannerBack" style="z-index: 105;">
    <div class="modal" style="max-width: 500px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">Assign to Planner</div>
          <div class="muted" id="assignToPlannerRecipeTitle"></div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnAssignToPlannerClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-6">
          <label>Date</label>
          <input type="date" id="assignToPlannerDate">
        </div>
        <div class="col-6">
          <label>Meal Slot</label>
          <select id="assignToPlannerSlot">
            <option value="Breakfast">Breakfast</option>
            <option value="Lunch">Lunch</option>
            <option value="Dinner">Dinner</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <div class="actions">
        <button class="primary" id="btnConfirmAssignToPlanner">Assign to Planner</button>
        <span class="muted" id="assignToPlannerStatus"></span>
      </div>
    </div>
  </div>

  <!-- COLLECTION MODAL -->
  <div class="modalBack" id="collectionModalBack" style="z-index: 105;">
    <div class="modal" style="max-width: 700px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;" id="collectionModalTitle">Create Collection</div>
          <div class="muted">Organize recipes into custom collections</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnCollectionModalClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Collection Name</label>
          <input id="collectionName" placeholder="e.g., Quick Weeknight Dinners">
        </div>
        <div class="col-12">
          <label>Description (optional)</label>
          <textarea id="collectionDescription" placeholder="Brief description..." rows="3"></textarea>
        </div>
      </div>

      <div class="hr"></div>

      <div class="actions">
        <button class="primary" id="btnSaveCollection">Save Collection</button>
        <button class="danger" id="btnDeleteCollection" style="display:none;">Delete Collection</button>
        <span class="muted" id="collectionModalStatus"></span>
      </div>
    </div>
  </div>

  <!-- ASSIGN RECIPES TO COLLECTION MODAL -->
  <div class="modalBack" id="assignRecipesModalBack" style="z-index: 106;">
    <div class="modal">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;" id="assignRecipesModalTitle">Assign Recipes to Collection</div>
          <div class="muted" id="assignRecipesModalSubtitle"></div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnAssignRecipesModalClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Search recipes</label>
          <input id="assignRecipesSearch" placeholder="Type to search...">
        </div>
      </div>

      <div class="hr"></div>
      <div id="assignRecipesList" class="list" style="max-height: 60vh; overflow:auto;"></div>
    </div>
  </div>

  <!-- SHOPPING LIST PREVIEW MODAL -->
  <div class="modalBack" id="shoppingListPreviewBack" style="z-index: 107;">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">üõí Shopping List Preview</div>
          <div class="muted" id="shoppingListPreviewSubtitle">Review before printing</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnShoppingListPreviewClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div id="shoppingListPreviewContent" style="flex: 1; overflow-y: auto; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px; border: 1px solid var(--line);">
        <!-- Preview content will be inserted here -->
      </div>

      <div class="hr"></div>

      <div class="actions">
        <button class="primary" id="btnConfirmPrintShopping" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üñ®Ô∏è Print</button>
        <button class="ghost" id="btnCancelPrintShopping">Cancel</button>
      </div>
    </div>
  </div>

  <!-- IMPORT RECIPE FROM URL MODAL -->
  <div class="modalBack" id="importRecipeModalBack" style="z-index: 107;">
    <div class="modal" style="max-width: 800px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">üîó Import Recipe from URL</div>
          <div class="muted">Paste a recipe URL to auto-import ingredients and instructions</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnImportRecipeModalClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="col-12">
          <label>Recipe URL</label>
          <input id="importRecipeUrl" type="url" placeholder="https://www.allrecipes.com/recipe/...">
          <div class="muted" style="margin-top:6px;">Supports: AllRecipes, NYT Cooking, Food Network, Serious Eats, Bon App√©tit, and more</div>
        </div>
        <div class="col-12">
          <div class="actions">
            <button class="primary" id="btnFetchRecipe">Fetch Recipe</button>
            <span class="muted" id="importRecipeStatus"></span>
          </div>
        </div>
      </div>

      <div class="hr" id="importPreviewDivider" style="display:none;"></div>

      <!-- Preview Section -->
      <div id="importRecipePreview" style="display:none;">
        <div style="font-weight:600; margin-bottom:12px;">Preview - Review before saving</div>
        
        <div class="row">
          <div class="col-8">
            <label>Recipe Title</label>
            <input id="importPreviewTitle" type="text">
          </div>
          <div class="col-4">
            <label>Servings</label>
            <input id="importPreviewServings" type="number" min="1" value="4">
          </div>
          <div class="col-6">
            <label>Cuisine</label>
            <select id="importPreviewCuisine">
              <option value="">Unknown</option>
            </select>
          </div>
          <div class="col-6">
            <label>Meal Type</label>
            <select id="importPreviewMealType">
              <option value="Any">Any</option>
              <option value="Breakfast">Breakfast</option>
              <option value="Brunch">Brunch</option>
              <option value="Lunch">Lunch</option>
              <option value="Dinner">Dinner</option>
              <option value="Side Dish">Side Dish</option>
              <option value="Appetizer">Appetizer</option>
              <option value="Snack">Snack</option>
              <option value="Dessert">Dessert</option>
              <option value="Beverage">Beverage</option>
            </select>
          </div>
          <div class="col-12">
            <label>Instructions</label>
            <textarea id="importPreviewInstructions" rows="6"></textarea>
          </div>
          <div class="col-12">
            <label>Ingredients (one per line)</label>
            <textarea id="importPreviewIngredients" rows="10" placeholder="1 cup flour&#10;2 eggs&#10;1/2 cup milk"></textarea>
            <div class="muted" style="margin-top:4px;">Format: quantity + unit + ingredient name (e.g., "2 cups all-purpose flour")</div>
          </div>
          <div class="col-12">
            <label>Image URL (optional)</label>
            <input id="importPreviewImageUrl" type="url">
          </div>
        </div>

        <div class="hr"></div>

        <div class="actions">
          <button class="primary" id="btnSaveImportedRecipe">Save Recipe</button>
          <button class="ghost" id="btnCancelImport">Cancel</button>
          <span class="muted" id="importSaveStatus"></span>
        </div>
      </div>
    </div>
  </div>

  <!-- MEAL PLANNER PREFERENCES MODAL -->
  <div class="modalBack" id="mealPlannerPrefsBack" style="z-index: 108;">
    <div class="modal" style="max-width: 700px;">
      <div class="modalHead">
        <div>
          <div style="font-weight:700;">‚öôÔ∏è Smart Meal Planner Preferences</div>
          <div class="muted">Customize how the AI generates your weekly meal plan</div>
        </div>
        <div class="actions">
          <button class="ghost" id="btnMealPlannerPrefsClose">Close</button>
        </div>
      </div>

      <div class="hr"></div>

      <!-- Favorite Cuisines Section -->
      <div class="prefs-section">
        <div class="prefs-section-title">
          <span>üåç Favorite Cuisines</span>
        </div>
        <div class="cuisine-grid" id="cuisineGrid">
          <!-- Dynamically populated from database -->
        </div>
      </div>

      <!-- Variety Settings Section -->
      <div class="prefs-section">
        <div class="prefs-section-title"><span>üéØ Variety Settings</span></div>
        <div class="variety-options">
          <label class="variety-option">
            <input type="checkbox" id="prefAvoidRepeat" checked>
            <div class="variety-option-content">
              <div class="variety-option-title">Avoid Repeating Cuisines</div>
              <div class="variety-option-desc">Don't use the same cuisine on consecutive days</div>
            </div>
          </label>
          
          <label class="variety-option">
            <input type="checkbox" id="prefAvoidRecipeRepeat">
            <div class="variety-option-content">
              <div class="variety-option-title">Avoid Repeating Recipes</div>
              <div class="variety-option-desc">Don't use the same recipe within a specified number of days</div>
            </div>
          </label>
          
          <div id="recipeRepeatOptions" style="margin-left: 40px; display: none; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px; border: 1px solid rgba(255,255,255,0.08);">
            <div style="margin-bottom: 12px;">
              <label style="display: block; font-size: 13px; color: var(--text); margin-bottom: 6px;">
                Don't repeat recipes within
                <input type="number" id="prefRecipeRepeatDays" min="1" max="7" value="3" style="width: 60px; padding: 4px 8px; margin: 0 4px; display: inline-block; min-height: auto;">
                days
              </label>
            </div>
            <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Exclude from this rule:</div>
            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: var(--text);">
                <input type="checkbox" id="prefExcludeBreakfast" style="cursor: pointer; width: 16px; height: 16px; min-height: 16px; margin: 0;">
                <span>Breakfast</span>
              </label>
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: var(--text);">
                <input type="checkbox" id="prefExcludeLunch" style="cursor: pointer; width: 16px; height: 16px; min-height: 16px; margin: 0;">
                <span>Lunch</span>
              </label>
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: var(--text);">
                <input type="checkbox" id="prefExcludeDinner" style="cursor: pointer; width: 16px; height: 16px; min-height: 16px; margin: 0;">
                <span>Dinner</span>
              </label>
            </div>
          </div>
          
          <label class="variety-option">
            <input type="checkbox" id="prefUsePantry" checked>
            <div class="variety-option-content">
              <div class="variety-option-title">Prioritize Pantry Ingredients</div>
              <div class="variety-option-desc">Suggest recipes that use ingredients you already have</div>
            </div>
          </label>
          <label class="variety-option">
            <input type="checkbox" id="prefFavoritesOnly">
            <div class="variety-option-content">
              <div class="variety-option-title">Favorites Only</div>
              <div class="variety-option-desc">Only suggest from recipes marked as favorites</div>
            </div>
          </label>
        </div>
      </div>

      <!-- Breakfast Preference Section -->
      <div class="prefs-section">
        <div class="prefs-section-title"><span>üç≥ Breakfast Preference</span></div>
        <div class="breakfast-select-wrapper">
          <select id="prefBreakfastStyle">
            <option value="varied">Varied - Different breakfast each day</option>
            <option value="simple">Simple - Quick and easy recipes only</option>
            <option value="same">Same - Use one recipe all week</option>
            <option value="skip">Skip - Don't plan breakfasts</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <div class="prefs-save-section">
        <button class="primary" id="btnSaveMealPlannerPrefs">üíæ Save Preferences</button>
        <span class="muted" id="mealPlannerPrefsStatus"></span>
      </div>
    </div>
  </div>

  <script>
    // ---------- utilities ----------
    function api(fn, payload) {
      return window.Foodie.api(fn, payload);
    }

    // ---------- META / common options ----------
    const DEFAULT_ING_CATEGORIES = ['Produce','Dairy','Meat','Seafood','Pantry','Snacks','Frozen','Bakery','Deli','Beverages','Household','Spice','Other'];

    const META = {
      qtyNumOptions: ['', '0.25','0.5','0.75','1','1.5','2','3','4','5','6','8','10','12'],
      unitOptions: ['', 'tsp','tbsp','cup','oz','lb','g','kg','ml','l','pinch','clove','can','jar','package','bunch','slice','piece'],
      categories: [''].concat(DEFAULT_ING_CATEGORIES)
    };

    function optionHtml_(vals, selected){
      const s = String(selected ?? '');
      const list = Array.isArray(vals) ? vals.slice() : [];
      if (s && !list.some(v => String(v) === s)) list.push(s);
      return (list || []).map(v => {
        const vv = String(v);
        return `<option value="${escapeAttr(vv)}"${vv===s ? ' selected' : ''}>${escapeHtml(vv)}</option>`;
      }).join('');
    }

    function ensureDatalist_(id, values){
      let dl = document.getElementById(id);
      if (!dl) {
        dl = document.createElement('datalist');
        dl.id = id;
        document.body.appendChild(dl);
      }
      dl.innerHTML = (values||[]).map(v => `<option value="${escapeAttr(String(v))}"></option>`).join('');
      return dl;
    }
    async function pantryModal_(opts){
      const overlay = document.getElementById('pantryModalOverlay');
      const titleEl = document.getElementById('pantryModalTitle');
      const btnClose = document.getElementById('pantryModalClose');
      const btnCancel = document.getElementById('pantryModalCancel');
      const btnSave = document.getElementById('pantryModalSave');
      const errEl = document.getElementById('pantryModalError');

      const nameEl = document.getElementById('pantryModalName');
      const qtyNumEl = document.getElementById('pantryModalQtyNum');
      const unitEl = document.getElementById('pantryModalUnit');
      const categoryEl = document.getElementById('pantryModalCategory');
      const qtyTextEl = document.getElementById('pantryModalQtyText');
      const lowStockEl = document.getElementById('pantryModalLowStock');
      const expirationEl = document.getElementById('pantryModalExpiration');
      const storeIdEl = document.getElementById('pantryModalStoreId');
      const notesEl = document.getElementById('pantryModalNotes');

      titleEl.textContent = (opts && opts.title) ? String(opts.title) : 'Pantry Item';
      const init = (opts && opts.initial) ? opts.initial : {};

      // populate datalists with common options
      ensureDatalist_('dlPantryQtyNum', META.qtyNumOptions);
      ensureDatalist_('dlPantryUnit', META.unitOptions);
      qtyNumEl.setAttribute('list', 'dlPantryQtyNum');
      unitEl.setAttribute('list', 'dlPantryUnit');

      // category options mirror ingredient categories
      if (categoryEl) {
        categoryEl.innerHTML = optionHtml_(META.categories, String(init.Category || ''));
        categoryEl.value = String(init.Category || '');
      }

      // populate store dropdown
      if (storeIdEl) {
        const storeNames = STORES.map(s => s.Name);
        const storeIds = STORES.map(s => s.StoreId);
        storeIdEl.innerHTML = '<option value="">-- None --</option>' + 
          STORES.map(s => `<option value="${escapeAttr(s.StoreId)}">${escapeHtml(s.Name)}</option>`).join('');
        storeIdEl.value = String(init.StoreId || '');
      }

      nameEl.value = String(init.Name || '');
      qtyNumEl.value = (init.QtyNum === null || init.QtyNum === undefined) ? '' : String(init.QtyNum);
      unitEl.value = String(init.Unit || '');
      if (categoryEl) categoryEl.value = String(init.Category || '');
      qtyTextEl.value = String(init.QtyText || '');
      if (lowStockEl) lowStockEl.value = (init.low_stock_threshold === null || init.low_stock_threshold === undefined) ? '' : String(init.low_stock_threshold);
      if (expirationEl) expirationEl.value = String(init.expiration_date || '');
      if (storeIdEl) storeIdEl.value = String(init.StoreId || '');
      notesEl.value = String(init.Notes || '');
      errEl.textContent = '';

      overlay.style.display = 'flex';

      return await new Promise((resolve) => {
        function close_(res){
          overlay.style.display = 'none';
          btnClose.removeEventListener('click', onCancel);
          btnCancel.removeEventListener('click', onCancel);
          btnSave.removeEventListener('click', onSave);
          resolve(res);
        }
        function onCancel(){ close_({ ok:false, cancelled:true }); }
        async function onSave(){
          const name = String(nameEl.value||'').trim();
          if (!name) { errEl.textContent = 'Name is required.'; return; }
          const qtyNum = qtyNumEl.value === '' ? null : Number(qtyNumEl.value);
          if (qtyNumEl.value !== '' && !Number.isFinite(qtyNum)) { errEl.textContent = 'Qty number must be numeric.'; return; }
          if (lowStockEl && lowStockEl.value !== '') {
            const t = Number(lowStockEl.value);
            if (!Number.isFinite(t) || t < 0) { errEl.textContent = 'Low stock threshold must be a non-negative number.'; return; }
          }
          const payload = {
            ItemId: init.ItemId || init.PantryId || null,
            Name: name,
            QtyNum: qtyNum,
            Unit: String(unitEl.value||'').trim(),
            Category: categoryEl ? String(categoryEl.value||'').trim() : '',
            low_stock_threshold: lowStockEl ? String(lowStockEl.value||'').trim() : '',
            expiration_date: expirationEl ? String(expirationEl.value||'').trim() : '',
            QtyText: String(qtyTextEl.value||'').trim(),
            StoreId: String(storeIdEl.value||'').trim(),
            Notes: String(notesEl.value||'').trim(),
          };
          const r = await api('upsertPantryItem', payload);
          if (!r.ok) { errEl.textContent = r.error || 'Save error'; return; }
          close_({ ok:true });
        }

        btnClose.addEventListener('click', onCancel);
        btnCancel.addEventListener('click', onCancel);
        btnSave.addEventListener('click', onSave);
      });
    }

function escapeHtml(s){ return String(s||'').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'})[c]); }
    function escapeAttr(s){ return escapeHtml(s).replace(/"/g,'&quot;'); }

    // Debounce utility for auto-categorization
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function ymd(d){
      const dt = (d instanceof Date) ? d : new Date(d);
      const y = dt.getFullYear();
      const m = String(dt.getMonth()+1).padStart(2,'0');
      const da = String(dt.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    function addDays(dateYmd, days){
      const [y,m,d] = dateYmd.split('-').map(Number);
      const dt = new Date(y, m-1, d);
      dt.setDate(dt.getDate() + Number(days||0));
      return ymd(dt);
    }

    function daysInclusive(startYmd, endYmd){
      if (!startYmd || !endYmd) return 0;
      const [sy,sm,sd] = String(startYmd).split('-').map(Number);
      const [ey,em,ed] = String(endYmd).split('-').map(Number);
      const s = new Date(sy, sm-1, sd);
      const e = new Date(ey, em-1, ed);
      const diff = Math.floor((e - s) / (24*60*60*1000));
      return diff + 1;
    }

    // ---------- global state ----------
    let STORES = [];
    let STORE_ID_TO_NAME = {};
    let RECIPES = [];
    let CURRENT_QUERY = '';
    let LOADING = false;

    // modal state (recipes)
    let CURRENT_RECIPE_ID = '';
    let ING_ROWS = [];
    let recipeModalMode = 'view'; // view|edit|new
    
    // Recipe scaling state
    let RECIPE_SCALE = 1.0;
    let RECIPE_BASE_SERVINGS = 4; // Default base servings
    let RECIPE_ORIGINAL_ING_ROWS = []; // Store original quantities for scaling

    // Auto-categorization debounce timer
    let autoCatDebounceTimer = null;

    // meal picker state
    let MP = { open:false, date:'', slot:'', q:'', recipes:[] };

    // planner state
    let PLAN = { start:'', days:14, plansByDate:{}, viewMode:'grid' };

    // Phase 3: Recipe Collections state
    let COLLECTIONS = [];
    let CURRENT_COLLECTION_ID = '';
    let COLLECTION_RECIPES = [];

    // Phase 3: Grid view drag state
    let DRAG_SOURCE = null;

    // Phase 3: Meal pattern templates (stored in localStorage)
    const MEAL_PATTERN_KEY = 'foodieMealPattern';

    // admin state
    let BF = { token:'', totalUpdated:0, totalScanned:0 };
    let CL = { token:'', totalDeleted:0, totalScanned:0 };

    // ---------- tabbing ----------
    async function setTab(tabName){
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
      document.querySelectorAll('section[id^="tab-"]').forEach(s => s.style.display = 'none');
      document.getElementById('tab-' + tabName).style.display = '';
      
      // Load cuisine management UI when Admin tab is shown
      if (tabName === 'admin') {
        await renderCuisineManagementUI();
      }
    }
    document.getElementById('tabs').addEventListener('click', (e) => {
      const t = e.target.closest('.tab');
      if (!t) return;
      setTab(t.dataset.tab);
    });

    // ---------- stores ----------
    async function loadStores() {
      const res = await api('listStores', {});
      if (!res.ok) throw new Error(res.error || 'listStores failed');
      STORES = res.stores || [];
      STORE_ID_TO_NAME = {};
      for (const s of STORES) STORE_ID_TO_NAME[String(s.StoreId)] = String(s.Name || '');
      renderStoreList();
    }
    function getStoreNameById(id) { return STORE_ID_TO_NAME[String(id||'')] || ''; }

    // Get default store ID for Kroger (used for ingredient defaults)
    function getDefaultStoreId() {
      const k = (STORES || []).find(s => String(s.Name||'').trim().toLowerCase() === 'kroger');
      return k ? String(k.StoreId) : '';
    }

    function renderStoreList(){
      const box = document.getElementById('storeList');
      if (!box) return;
      if (!STORES.length) { box.innerHTML = `<div class="muted">No stores yet. Add one above.</div>`; return; }
      box.innerHTML = `
        <div style="display:grid;grid-template-columns:1fr auto;gap:8px;padding:8px 10px;font-size:12px;font-weight:600;color:var(--muted);border-bottom:1px solid var(--line);margin-bottom:4px;">
          <div>STORE NAME</div>
          <div>ACTION</div>
        </div>
        ${STORES.map(s => `
          <div class="item" style="display:grid;grid-template-columns:1fr auto;gap:10px;padding:10px 10px;align-items:center;">
            <div>
              <strong>${escapeHtml(s.Name)}</strong>
              <span class="muted" style="margin-left:8px;">(${escapeHtml(s.StoreId)})</span>
            </div>
            <button class="danger" data-action="store-delete" data-storeid="${escapeAttr(s.StoreId)}" data-storename="${escapeAttr(s.Name)}" style="padding:6px 10px;font-size:12px;">Delete</button>
          </div>
        `).join('')}
      `;
    }

    // ---------- recipes (local: load all, no pagination) ----------
    async function resetAndLoadRecipes() {
      if (LOADING) return;
      LOADING = true;
      try {
        document.getElementById('recipeStatus').textContent = 'Loading...';
        const res = await api('listRecipesAll', { q: CURRENT_QUERY });
        if (!res.ok) throw new Error(res.error || 'listRecipesAll failed');
        RECIPES = res.recipes || [];
        RECIPES.sort((a,b) => String(a.TitleLower||a.Title||'').localeCompare(String(b.TitleLower||b.Title||'')));
        renderRecipes();
        populateBreakfastRecipeDropdown();
        document.getElementById('pillCount').textContent = `Loaded: ${RECIPES.length}`;
        document.getElementById('recipeStatus').textContent = RECIPES.length ? 'Loaded.' : 'No matches.';
      } catch (e) {
        document.getElementById('recipeStatus').textContent = `Error: ${String(e && e.message ? e.message : e)}`;
      } finally {
        LOADING = false;
      }
    }

    function renderRecipes() {
      const box = document.getElementById('recipesList');
      const showFavoritesOnly = document.getElementById('recipeFavoritesOnly')?.checked || false;
      const cuisineFilter = document.getElementById('recipeCuisineFilter')?.value || '';
      
      // Filter recipes by favorites and cuisine
      let recipesToShow = RECIPES;
      if (showFavoritesOnly) {
        recipesToShow = recipesToShow.filter(r => {
          // Handle both boolean true and numeric 1
          return r.is_favorite === true || r.is_favorite === 1 || r.is_favorite === '1';
        });
      }
      if (cuisineFilter) {
        recipesToShow = recipesToShow.filter(r => {
          return r.Cuisine === cuisineFilter;
        });
      }
      
      if (!recipesToShow.length) {
        const filterMsg = showFavoritesOnly && cuisineFilter 
          ? `No ${cuisineFilter} favorite recipes found.` 
          : showFavoritesOnly 
            ? 'No favorite recipes found.' 
            : cuisineFilter 
              ? `No ${cuisineFilter} recipes found.`
              : 'No recipes loaded.';
        box.innerHTML = `<div class="muted">${filterMsg}</div>`;
        return;
      }

      // Group recipes by first letter with anchor IDs
      const letterGroups = {};
      recipesToShow.forEach(r => {
        const title = r.Title || '';
        const firstLetter = title.charAt(0).toUpperCase();
        const key = firstLetter.match(/[A-Z]/) ? firstLetter : '#';
        if (!letterGroups[key]) letterGroups[key] = [];
        letterGroups[key].push(r);
      });

      // Render in order: A-Z, then # for non-letter starts
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      const sortedKeys = [...letters.filter(l => letterGroups[l]), ...(letterGroups['#'] ? ['#'] : [])];

      box.innerHTML = sortedKeys.map(letter => `
        <div id="letter-${letter.toLowerCase()}">
          <div class="letter-header">
            ${letter === '#' ? 'Other' : letter}
          </div>
          ${letterGroups[letter].map(r => {
            // Handle both boolean true and numeric 1 for is_favorite
            const isFavorite = r.is_favorite === true || r.is_favorite === 1 || r.is_favorite === '1';
            const starIcon = isFavorite ? '‚≠ê' : '‚òÜ';
            const starColor = isFavorite ? '#ffd700' : 'var(--muted)';
            return `
            <div class="item">
              <div style="display:flex; justify-content:space-between; gap:10px; align-items:start;">
                <div style="flex:1;">
                  <div style="display:flex; align-items:center; gap:8px;">
                    <button class="ghost" data-action="recipe-favorite" data-rid="${escapeAttr(r.RecipeId)}" 
                            title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}"
                            style="padding:4px 8px; font-size:18px; line-height:1; border:none; background:transparent; cursor:pointer; color:${starColor};">
                      ${starIcon}
                    </button>
                    <strong>${escapeHtml(r.Title || '')}</strong>
                  </div>
                  <div class="muted">${escapeHtml(r.MealType || 'Any')} ‚Ä¢ ${escapeHtml(r.Cuisine || '')}</div>
                  <div class="muted">${r.URL ? `<a href="${escapeAttr(r.URL)}" target="_blank" rel="noreferrer">open link</a>` : ''}</div>
                </div>
                <div class="actions">
                  <button class="ghost" data-action="recipe-view" data-rid="${escapeAttr(r.RecipeId)}">View</button>
                  <button class="ghost" data-action="recipe-edit" data-rid="${escapeAttr(r.RecipeId)}">Edit</button>
                  <button class="ghost" data-action="recipe-print" data-rid="${escapeAttr(r.RecipeId)}">Print</button>
                </div>
              </div>
            </div>
            `;
          }).join('')}
        </div>
      `).join('');
    }

    // ---------- recipe modal ----------
    function openRecipeModal() { document.getElementById('recipeModalBack').style.display = 'flex'; }
    function closeRecipeModal() { 
      document.getElementById('recipeModalBack').style.display = 'none'; 
      // Reset scale when closing modal
      resetRecipeScale();
    }

    function setRecipeModalMode(mode) {
      recipeModalMode = mode;
      const editable = (mode === 'edit' || mode === 'new');

      document.getElementById('rmTitle').textContent =
        mode === 'view' ? 'View Recipe' : (mode === 'new' ? 'Add Recipe' : 'Edit Recipe');
      document.getElementById('btnModalToggleEdit').textContent = (mode === 'view') ? 'Edit' : 'View';

      ['rTitle','rUrl','rCuisine','rMealType','rInstructions','rNotes'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = !editable;
      });

      document.getElementById('modalActions').style.display = editable ? '' : 'none';
      document.getElementById('viewModeActions').style.display = editable ? 'none' : '';

      const url = (document.getElementById('rUrl').value || '').trim();
      document.getElementById('rUrlView').innerHTML = url ? `<a href="${escapeAttr(url)}" target="_blank" rel="noreferrer">Open recipe link</a>` : '';

      renderIngredientsTable();
    }

    function toggleRecipeModalMode() {
      if (recipeModalMode === 'view') setRecipeModalMode('edit');
      else setRecipeModalMode('view');
    }

    async function openRecipeModalNew() {
      CURRENT_RECIPE_ID = '';
      document.getElementById('rTitle').value = '';
      document.getElementById('rUrl').value = '';
      setCuisineSelect_('');
      document.getElementById('rMealType').value = 'Any';
      document.getElementById('rNotes').value = '';
      document.getElementById('rInstructions').value = '';
      ING_ROWS = [];
      RECIPE_ORIGINAL_ING_ROWS = [];
      RECIPE_SCALE = 1.0;
      updateScaleDisplay();
      openRecipeModal();
      setRecipeModalMode('new');
    }

    async function openRecipeModalView(recipeId) {
      const res = await api('getRecipe', { recipeId });
      if (!res.ok) { alert(res.error || 'Failed'); return; }
      const r = res.recipe || {};
      CURRENT_RECIPE_ID = r.RecipeId || '';

      document.getElementById('rTitle').value = r.Title || '';
      document.getElementById('rUrl').value = r.URL || '';
      setCuisineSelect_(r.Cuisine || '');
      document.getElementById('rMealType').value = r.MealType || 'Any';
      document.getElementById('rNotes').value = r.Notes || '';
      document.getElementById('rInstructions').value = r.Instructions || '';

      await loadIngredientsForCurrentRecipe();

      openRecipeModal();
      setRecipeModalMode('view');
    }

    async function openRecipeModalEdit(recipeId) {
      await openRecipeModalView(recipeId);
      setRecipeModalMode('edit');
    }

    async function loadIngredientsForCurrentRecipe() {
      ING_ROWS = [];
      if (!CURRENT_RECIPE_ID) { 
        RECIPE_ORIGINAL_ING_ROWS = [];
        RECIPE_SCALE = 1.0;
        updateScaleDisplay();
        renderIngredientsTable(); 
        return; 
      }

      const res = await api('listRecipeIngredients', { recipeId: CURRENT_RECIPE_ID });
      if (!res.ok) { 
        RECIPE_ORIGINAL_ING_ROWS = [];
        RECIPE_SCALE = 1.0;
        updateScaleDisplay();
        renderIngredientsTable(); 
        return; 
      }

      ING_ROWS = (res.items || []).map(x => ({
        IngredientNorm: x.IngredientNorm || '',
        IngredientRaw: x.IngredientRaw || '',
        Notes: x.Notes || '',
        QtyNum: (x.QtyNum === '' || x.QtyNum === null || x.QtyNum === undefined) ? '' : String(x.QtyNum),
        QtyText: cleanQtyText(x.QtyText || ''),  // Clean date strings from QtyText
        StoreId: x.StoreId || getDefaultStoreId() || '',
        Unit: x.Unit || '',
        Category: x.Category || '',
        idx: (x.idx === '' || x.idx === null || x.idx === undefined) ? '' : Number(x.idx),
      }));
      
      // Auto-categorize all ingredients (even if they have a category, to ensure consistency)
      document.getElementById('rmStatus').textContent = 'Categorizing ingredients...';
      
      let categorized = 0;
      for (let i = 0; i < ING_ROWS.length; i++) {
        const row = ING_ROWS[i];
        const name = row.IngredientRaw || row.IngredientNorm;
        if (name && name.trim().length >= 2) {
          const catRes = await api('classifyIngredient', { name });
          if (catRes.ok && catRes.category) {
            ING_ROWS[i].Category = catRes.category;
            categorized++;
          }
        }
        // Small delay to avoid overwhelming the API
        await new Promise(r => setTimeout(r, 5));
      }
      
      // CRITICAL: Auto-save ingredients with categories to database
      // This ensures categories persist and show up in shopping list
      try {
        const saveResult = await api('upsertRecipeWithIngredients', {
          recipe: { RecipeId: CURRENT_RECIPE_ID, Title: (document.getElementById('rTitle') ? String(document.getElementById('rTitle').value||'').trim() : '') },
          items: ING_ROWS.map(x => ({
            IngredientNorm: x.IngredientNorm,
            IngredientRaw: x.IngredientRaw,
            Notes: x.Notes,
            QtyNum: x.QtyNum === '' ? null : Number(x.QtyNum),
            QtyText: x.QtyText,
            StoreId: x.StoreId,
            Unit: x.Unit,
            Category: x.Category || ''
          }))
        });
        
        if (saveResult.ok) {
          console.log(`Auto-saved ${categorized} categorized ingredients`);
        } else {
          console.error('Auto-save failed:', saveResult.error);
          document.getElementById('rmStatus').textContent = 'Warning: Categories may not have saved';
        }
      } catch (err) {
        console.error('Auto-save error:', err);
        document.getElementById('rmStatus').textContent = 'Warning: Categories may not have saved';
      }
      
      // Store original rows for scaling
      RECIPE_ORIGINAL_ING_ROWS = JSON.parse(JSON.stringify(ING_ROWS));
      RECIPE_SCALE = 1.0;
      updateScaleDisplay();
      renderIngredientsTable();
      document.getElementById('rmStatus').textContent = '';
    }

    // Apply current scale to ING_ROWS (used for printing scaled quantities)
    function applyCurrentScaleToDisplay(forceRefresh = false) {
      // Always re-apply if forceRefresh is true (e.g., for print operations)
      if (forceRefresh) {
        ING_ROWS = RECIPE_ORIGINAL_ING_ROWS.map(row => {
          const scaled = { ...row };
          if (row.QtyNum !== '' && row.QtyNum !== null && row.QtyNum !== undefined) {
            const originalNum = parseFloat(row.QtyNum);
            if (!isNaN(originalNum)) {
              scaled.QtyNum = String(Math.round(originalNum * RECIPE_SCALE * 100) / 100);
            }
          }
          return scaled;
        });
        renderIngredientsTable();
        return;
      }
      
      // Check if scaling is needed: if RECIPE_SCALE is 1.0, no scaling needed
      if (RECIPE_SCALE === 1.0) {
        return; // No scaling needed, ING_ROWS already has original values
      }
      
      // Only apply scale if ING_ROWS matches original (not already scaled)
      // Compare first row's QtyNum to detect if already scaled
      const originalFirst = RECIPE_ORIGINAL_ING_ROWS[0];
      const currentFirst = ING_ROWS[0];
      
      if (originalFirst && currentFirst) {
        const originalNum = originalFirst.QtyNum ? parseFloat(originalFirst.QtyNum) : null;
        const currentNum = currentFirst.QtyNum ? parseFloat(currentFirst.QtyNum) : null;
        
        // If current already matches scaled value, don't re-scale
        if (originalNum !== null && currentNum !== null) {
          const expectedScaled = Math.round(originalNum * RECIPE_SCALE * 100) / 100;
          if (Math.abs(currentNum - expectedScaled) < 0.001) {
            return; // Already scaled, no need to re-apply
          }
        }
      }
      
      // Apply scaling from original
      ING_ROWS = RECIPE_ORIGINAL_ING_ROWS.map(row => {
        const scaled = { ...row };
        if (row.QtyNum !== '' && row.QtyNum !== null && row.QtyNum !== undefined) {
          const originalNum = parseFloat(row.QtyNum);
          if (!isNaN(originalNum)) {
            scaled.QtyNum = String(Math.round(originalNum * RECIPE_SCALE * 100) / 100);
          }
        }
        return scaled;
      });
      renderIngredientsTable();
    }

    // ---------- Recipe Scaling ----------
    function updateScaleDisplay() {
      const scaleValueEl = document.getElementById('scaleValue');
      if (scaleValueEl) {
        scaleValueEl.textContent = RECIPE_SCALE.toFixed(1) + 'x';
      }
    }

    function scaleRecipe(factor) {
      const newScale = Math.round((RECIPE_SCALE + factor) * 10) / 10;
      if (newScale < 0.1 || newScale > 10) return; // Limit scale range
      
      RECIPE_SCALE = newScale;
      
      // Scale the displayed quantities
      ING_ROWS = RECIPE_ORIGINAL_ING_ROWS.map(row => {
        const scaled = { ...row };
        if (row.QtyNum !== '' && row.QtyNum !== null && row.QtyNum !== undefined) {
          const originalNum = parseFloat(row.QtyNum);
          if (!isNaN(originalNum)) {
            scaled.QtyNum = String(Math.round(originalNum * RECIPE_SCALE * 100) / 100);
          }
        }
        return scaled;
      });
      
      updateScaleDisplay();
      renderIngredientsTable();
    }

    function resetRecipeScale() {
      RECIPE_SCALE = 1.0;
      ING_ROWS = JSON.parse(JSON.stringify(RECIPE_ORIGINAL_ING_ROWS));
      updateScaleDisplay();
      renderIngredientsTable();
    }

    // ---------- Auto-Categorization ----------
    // Debounce timer reference for cleanup (declared in global state)

    const debouncedClassify = debounce(async (idx, ingredientName) => {
      if (!ingredientName || ingredientName.trim().length < 2) return;
      if (recipeModalMode === 'view') return;
      
      const res = await api('classifyIngredient', { name: ingredientName });
      if (res.ok && res.category && ING_ROWS[idx]) {
        // Only auto-set if current category is empty/default
        if (!ING_ROWS[idx].Category || ING_ROWS[idx].Category === '') {
          ING_ROWS[idx].Category = res.category;
          renderIngredientsTable();
        }
      }
    }, 500); // 500ms debounce

    function triggerAutoClassify(idx, ingredientName) {
      debouncedClassify(idx, ingredientName);
    }

    // Auto-categorize ALL ingredients (called when loading recipe and when clicking Categorize All)
    async function categorizeAllIngredients() {
      if (recipeModalMode === 'view') return;
      
      const statusEl = document.getElementById('rmStatus');
      statusEl.textContent = 'Categorizing...';
      
      let categorized = 0;
      let failed = 0;
      
      for (let i = 0; i < ING_ROWS.length; i++) {
        const row = ING_ROWS[i];
        const name = row.IngredientRaw || row.IngredientNorm;
        if (!name || name.trim().length < 2) continue;
        
        // Always classify, even if category already exists (to update/fix)
        const res = await api('classifyIngredient', { name });
        console.log(`Categorizing "${name}":`, res);
        
        if (res.ok && res.category) {
          ING_ROWS[i].Category = res.category;
          categorized++;
        } else {
          failed++;
        }
        
        // Small delay to avoid overwhelming the API
        await new Promise(r => setTimeout(r, 10));
      }
      
      renderIngredientsTable();
      
      if (categorized > 0) {
        statusEl.textContent = `Categorized ${categorized} ingredient(s).${failed > 0 ? ` (${failed} failed)` : ''}`;
      } else if (failed > 0) {
        statusEl.textContent = 'Could not categorize ingredients.';
      } else {
        statusEl.textContent = 'All ingredients already categorized.';
      }
      
      // Clear status after 3 seconds
      setTimeout(() => { if (statusEl.textContent.includes('Categorized')) statusEl.textContent = ''; }, 3000);
    }

    // Train category for an ingredient
    async function trainIngredientCategory(idx, ingredientName, category) {
      if (!ingredientName || !category || recipeModalMode === 'view') return;
      
      const res = await api('trainIngredientCategory', { name: ingredientName, category });
      if (res.ok) {
        console.log(`Learned: "${ingredientName}" ‚Üí "${category}"`);
      }
    }

    // Helper to clean date strings from QtyText (fractions like 1/2 were parsed as dates)
    function cleanQtyText(qtyText) {
      if (!qtyText) return '';
      // Remove date strings that were mistakenly parsed from fractions
      // Pattern matches: "Fri Jan 02 2026 00:00:00 GMT-0500 (Eastern Standard Time)" or similar
      const datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}\s+\d{4}\s+\d{2}:\d{2}:\d{2}\s+GMT[-+]\d{4}\s+\([^)]+\)\s*/i;
      return qtyText.replace(datePattern, '').trim();
    }

    function renderIngredientsTable() {
      const wrap = document.getElementById('ingTableWrap');
      if (!wrap) return;

      if (!ING_ROWS.length) {
        wrap.innerHTML = `<div class="muted">No ingredients yet.</div>`;
        return;
      }

      const isView = (recipeModalMode === 'view');
      const disabledAttr = isView ? 'disabled' : '';

      wrap.innerHTML = ING_ROWS.map((r, idx) => {
        const effectiveStoreId = String(r.StoreId || '').trim() || (getDefaultStoreId() || '');
        const catIndicator = (r.Category && r.Category !== '') ? `<span class="auto-cat-indicator auto-cat-active">‚úì</span>` : '';
        const cleanedQtyText = cleanQtyText(r.QtyText || '');
        return `
          <div class="item ingGrid" data-idx="${idx}">
            <div class="row">
              <div class="col-4">
                <label>Name${catIndicator}</label>
                <input ${disabledAttr} value="${escapeAttr(r.IngredientRaw||r.IngredientNorm||r.Name||'')}" data-action="ing-set" data-idx="${idx}" data-key="IngredientRaw" placeholder="e.g., chicken breast">
              </div>
              <div class="col-2">
                <label>Qty #</label>
                <input ${disabledAttr} list="dlQtyNum" value="${escapeAttr(r.QtyNum ?? '')}" data-action="ing-set" data-idx="${idx}" data-key="QtyNum">
              </div>
              <div class="col-2">
                <label>Unit</label>
                <input ${disabledAttr} list="dlUnit" value="${escapeAttr(r.Unit||'')}" data-action="ing-set" data-idx="${idx}" data-key="Unit">
              </div>
              <div class="col-4">
                <label>Qty Text</label>
                <input ${disabledAttr} value="${escapeAttr(cleanedQtyText)}" data-action="ing-set" data-idx="${idx}" data-key="QtyText">
              </div>
              <div class="col-4">
                <label>Category</label>
                <select ${disabledAttr} data-action="ing-set" data-action-cat="ing-category" data-idx="${idx}" data-key="Category">
                  ${optionHtml_(META.categories, r.Category||'')}
                </select>
              </div>
              <div class="col-4">
                <label>Store</label>
                <select ${disabledAttr} data-action="ing-store" data-idx="${idx}">
                  ${storeOptionsHtml_(effectiveStoreId)}
                </select>
              </div>
              <div class="col-4">
                <label>Ingredient Norm</label>
                <input ${disabledAttr} value="${escapeAttr(r.IngredientNorm||'')}" data-action="ing-set" data-idx="${idx}" data-key="IngredientNorm">
              </div>
              ${isView ? '' : `
              <div class="col-12" style="margin-top:6px;">
                <div class="actions">
                  <button class="danger" data-action="ing-del" data-idx="${idx}">Remove</button>
                </div>
              </div>
              `}
            </div>
          </div>
        `;
      }).join('');

      ensureDatalist_('dlQtyNum', META.qtyNumOptions);
      ensureDatalist_('dlUnit', META.unitOptions);
    }


    function addIngredientRow() {
      ING_ROWS.push({ IngredientNorm:'', IngredientRaw:'', Notes:'', QtyNum:'', QtyText:'', StoreId:(getDefaultStoreId() || ''), Unit:'', Category:'', idx:'' });
      renderIngredientsTable();
    }
    function removeIngredientRow(idx) { ING_ROWS.splice(idx, 1); renderIngredientsTable(); }

    async function saveRecipeAndIngredients() {
      if (recipeModalMode === 'view') return;
      document.getElementById('rmStatus').textContent = 'Saving...';

      const title = document.getElementById('rTitle').value.trim();
      if (!title) { alert('Title is required.'); document.getElementById('rmStatus').textContent=''; return; }

      // Auto-categorize all ingredients before saving (ensures categories persist)
      await categorizeAllIngredients();

      const recipe = {
        RecipeId: CURRENT_RECIPE_ID || '',
        Title: title,
        URL: document.getElementById('rUrl').value.trim(),
        Cuisine: document.getElementById('rCuisine').value.trim(),
        MealType: document.getElementById('rMealType').value.trim() || 'Any',
        Notes: document.getElementById('rNotes').value || '',
        Instructions: document.getElementById('rInstructions').value || '',
      };

      const items = ING_ROWS.map(x => ({
          IngredientNorm: (x.IngredientNorm||'').trim(),
          IngredientRaw: (x.IngredientRaw||'').trim(),
          Notes: (x.Notes||'').trim(),
          QtyNum: (x.QtyNum === '' ? '' : Number(x.QtyNum)),
          QtyText: (x.QtyText||'').trim(),
          StoreId: (x.StoreId||'').trim(),
          Unit: (x.Unit||'').trim(),
          Category: (x.Category||'').trim(),
        }))
        .filter(x => x.IngredientRaw);

      const res = await api('upsertRecipeWithIngredients', { recipe, items });
      if (!res.ok) {
        alert(res.error || 'Save failed');
        document.getElementById('rmStatus').textContent = '';
        return;
      }
      CURRENT_RECIPE_ID = res.RecipeId;

      // Reset scale after save (use original values for the view)
      resetRecipeScale();
      document.getElementById('rmStatus').textContent = 'Saved.';
      await resetAndLoadRecipes();
      await openRecipeModalView(CURRENT_RECIPE_ID);
    }

    async function deleteRecipeUi() {
      if (!CURRENT_RECIPE_ID) { alert('Open an existing recipe to delete.'); return; }
      if (!confirm('Delete this recipe and its ingredients?')) return;

      const res = await api('deleteRecipeCascade', { recipeId: CURRENT_RECIPE_ID });
      if (!res.ok) { alert(res.error || 'Delete failed'); return; }

      closeRecipeModal();
      await resetAndLoadRecipes();
    }

    // ---------- delegated handlers ----------
    document.addEventListener('click', async (e) => {
      const rv = e.target.closest('[data-action="recipe-view"]');
      if (rv) { const rid = rv.getAttribute('data-rid'); if (rid) await openRecipeModalView(rid); return; }

      const re = e.target.closest('[data-action="recipe-edit"]');
      if (re) { const rid = re.getAttribute('data-rid'); if (rid) await openRecipeModalEdit(rid); return; }


      const rp = e.target.closest('[data-action="recipe-print"]');
      if (rp) { 
        const rid = rp.getAttribute('data-rid'); 
        if (rid) {
          // Load recipe first, wait for it to fully load with categories
          await openRecipeModalView(rid);
          // Apply current scale to display before printing (force refresh)
          applyCurrentScaleToDisplay(true);
          // Now print with whatever quantities are displayed (including any scaling)
          await printRecipeWithQuantities();
        }
        return; 
      }

      const removeFromCol = e.target.closest('[data-action="remove-from-collection"]');
      if (removeFromCol) {
        const rid = removeFromCol.getAttribute('data-rid');
        if (rid && CURRENT_COLLECTION_ID) {
          if (confirm('Remove this recipe from the collection?')) {
            const res = await api('removeRecipeFromCollection', {
              collectionId: CURRENT_COLLECTION_ID,
              recipeId: rid
            });
            if (res.ok) {
              await loadCollectionRecipes(CURRENT_COLLECTION_ID);
            } else {
              alert(res.error || 'Failed to remove recipe');
            }
          }
        }
        return;
      }

      const assignToPlanner = e.target.closest('[data-action="assign-to-planner"]');
      if (assignToPlanner) {
        const rid = assignToPlanner.getAttribute('data-rid');
        const title = assignToPlanner.getAttribute('data-title');
        if (rid && title) {
          openAssignToPlannerModal(rid, title);
        }
        return;
      }

      const toggleMainDish = e.target.closest('[data-action="toggle-main-dish"]');
      if (toggleMainDish) {
        const recipeId = toggleMainDish.getAttribute('data-rid');
        const isChecked = toggleMainDish.checked;
        
        if (recipeId && CURRENT_COLLECTION_ID) {
          const res = await api('setMainDishInCollection', {
            collectionId: CURRENT_COLLECTION_ID,
            recipeId: recipeId,
            isMainDish: isChecked
          });
          
          if (res.ok) {
            // Reload collection recipes to refresh UI (main dish will appear first)
            await loadCollectionRecipes(CURRENT_COLLECTION_ID);
            
            // Update planner if this collection is currently assigned to any meal slots
            await updatePlannerForCollection(CURRENT_COLLECTION_ID);
          } else {
            alert(res.error || 'Failed to update main dish');
            // Revert checkbox state on error
            toggleMainDish.checked = !isChecked;
          }
        }
        return;
      }

      const ir = e.target.closest('[data-action="ing-del"]');
      if (ir) { if (recipeModalMode === 'view') return; removeIngredientRow(Number(ir.getAttribute('data-idx'))); return; }

      // Scale controls handlers
      const scaleDown = e.target.closest('[data-action="scale-down"]');
      if (scaleDown) { scaleRecipe(-0.5); return; }

      const scaleUp = e.target.closest('[data-action="scale-up"]');
      if (scaleUp) { scaleRecipe(0.5); return; }

      const scaleReset = e.target.closest('[data-action="scale-reset"]');
      if (scaleReset) { resetRecipeScale(); return; }
    });

    document.addEventListener('input', (e) => {
      const s = e.target.closest('[data-action="ing-set"]');
      if (s) {
        if (recipeModalMode === 'view') return;
        const idx = Number(s.getAttribute('data-idx'));
        const key = s.getAttribute('data-key');
        if (!Number.isFinite(idx) || !key || !ING_ROWS[idx]) return;
        ING_ROWS[idx][key] = e.target.value;
        
        // Trigger auto-categorization when typing ingredient name
        if (key === 'IngredientRaw' && e.target.value && e.target.value.length >= 2) {
          triggerAutoClassify(idx, e.target.value);
        }
      }
    });

    document.addEventListener('change', (e) => {
      const sel = e.target.closest('[data-action="ing-store"]');
      if (sel) {
        if (recipeModalMode === 'view') return;
        const idx = Number(sel.getAttribute('data-idx'));
        if (!Number.isFinite(idx) || !ING_ROWS[idx]) return;
        ING_ROWS[idx].StoreId = sel.value;
      }

      // Train classifier when category is manually set
      const catSel = e.target.closest('[data-action-cat="ing-category"]');
      if (catSel) {
        if (recipeModalMode === 'view') return;
        const idx = Number(catSel.getAttribute('data-idx'));
        const newCategory = catSel.value;
        if (!Number.isFinite(idx) || !ING_ROWS[idx] || !newCategory) return;
        
        const oldCategory = ING_ROWS[idx].Category;
        ING_ROWS[idx].Category = newCategory;
        
        // Train the classifier if the user explicitly set a category
        const ingredientName = ING_ROWS[idx].IngredientRaw || ING_ROWS[idx].IngredientNorm;
        if (ingredientName && ingredientName.length >= 2) {
          trainIngredientCategory(idx, ingredientName, newCategory);
        }
      }
    });

    // ---------- meal picker ----------
    
    function openMealPicker(date, slot){
      MP = { open:true, date, slot, q:'', recipes:[] };
      document.getElementById('mpTitle').textContent = `Select a recipe for ${slot}`;
      document.getElementById('mpSub').textContent = `Date: ${date}`;
      document.getElementById('mpSearch').value = '';
      document.getElementById('mpStatus').textContent = '';
      document.getElementById('mpList').innerHTML = '';
      document.getElementById('mealPickerBack').style.display = 'flex';
      mealPickerLoad(true);
    }

    function closeMealPicker(){ document.getElementById('mealPickerBack').style.display = 'none'; MP.open=false; }
    async function mealPickerLoad(reset){
      if (!MP.open) return;
      if (reset) { MP.recipes=[]; document.getElementById('mpList').innerHTML=''; }
      document.getElementById('mpStatus').textContent = 'Loading...';
      const res = await api('listRecipesAll', { q: MP.q });
      if (!res.ok) { document.getElementById('mpStatus').textContent = res.error || 'Error'; return; }
      MP.recipes = res.recipes || [];
      renderMealPickerList();
      document.getElementById('mpStatus').textContent = MP.recipes.length ? `Loaded ${MP.recipes.length}.` : 'No matches.';
    }


    
    function renderMealPickerList(){
      const box = document.getElementById('mpList');
      if (!box) return;
      box.innerHTML = (MP.recipes || []).map(r => `
        <div class="item" style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
          <div>
            <div><strong>${escapeHtml(r.Title || '')}</strong></div>
            <div class="muted">${escapeHtml(r.Cuisine || '')}</div>
          </div>
          <div class="actions">
            <button class="primary" data-action="mp-select" data-rid="${escapeAttr(r.RecipeId)}" data-title="${escapeAttr(r.Title||'')}">Select</button>
              <button class="ghost" data-action="mp-view" data-rid="${escapeAttr(r.RecipeId)}">View</button>
          </div>
        </div>
      `).join('');
    }


    document.getElementById('mealPickerBack').addEventListener('click', async (e) => {
            const viewBtn = e.target.closest('[data-action="mp-view"]');
      if (viewBtn) {
        const rid = viewBtn.getAttribute('data-rid');
        if (rid) {
          await openRecipeModalView(rid);
        }
        return;
      }

const pick = e.target.closest('[data-action="mp-select"]');
      if (pick) {
        const rid = pick.getAttribute('data-rid');
        const title = pick.getAttribute('data-title');
        await api('upsertPlanMeal', { date: MP.date, slot: MP.slot, meal: { RecipeId: rid, Title: title }});
        await loadPlansIntoUi(PLAN.start, PLAN.days);
        await loadPantry(); // Refresh pantry after planning meal
        closeMealPicker();
        return;
      }
    });

    // ---------- plans ----------
    async function loadPlansIntoUi(start, days){
      console.log('[loadPlansIntoUi] start:', start, 'days:', days);
      PLAN.start = start;
      PLAN.days = days;
      const end = addDays(start, days-1);
      console.log('[loadPlansIntoUi] PLAN.start set to:', PLAN.start, 'PLAN.days:', PLAN.days);

      const res = await api('getPlansRange', { start, end });
      if (!res.ok) { 
        console.error('[loadPlansIntoUi] API error:', res.error);
        document.getElementById('topStatus').textContent = res.error || 'Plan load error'; 
        return; 
      }
      console.log('[loadPlansIntoUi] API returned plans:', res.plans?.length || 0);
      PLAN.plansByDate = {};
      for (const p of (res.plans || [])) {
        PLAN.plansByDate[p.Date] = p;
        // Debug: log any meals with their fields
        for (const slot of ['Breakfast','Lunch','Dinner']) {
          if (p[slot]) {
            console.log(`Loaded ${p.Date} ${slot}:`, JSON.stringify(p[slot]));
          }
        }
      }

      renderPlanner('planList', start, days, true);
      // Bulk planner UI may be removed/hidden; do not fail if container is absent.
      renderPlanner('bulkList', start, days, false);
      
      // Render grid view if it's the active view mode
      console.log('[loadPlansIntoUi] PLAN.viewMode:', PLAN.viewMode);
      if (PLAN.viewMode === 'grid') {
        console.log('[loadPlansIntoUi] Calling renderPlanGrid');
        renderPlanGrid();
      }
      
      document.getElementById('topStatus').textContent = `Loaded plans: ${start} ‚Üí ${end}`;
    }

    
    // Helper function to fetch and render additional items for a meal slot
    async function renderAdditionalItemsAsync_(date, slot) {
      try {
        const result = await api('getAdditionalItems', { date, slot });
        if (!result.ok || !result.items || result.items.length === 0) {
          return '';
        }

        const items = result.items;
        const itemsHtml = items.map(item => `
          <div class="additional-item" style="display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid rgba(77,163,255,0.1);">
            <span class="item-type-badge" style="background:#4da3ff;color:white;padding:3px 8px;border-radius:4px;font-size:10px;text-transform:uppercase;font-weight:600;">${escapeHtml(item.ItemType || 'side')}</span>
            <span class="item-title" style="flex:1;font-size:13px;color:#374151;">${escapeHtml(item.Title || '')}</span>
            <button class="ghost" data-action="planner-view" data-rid="${escapeAttr(item.RecipeId)}" style="padding:4px 8px;font-size:11px;">View</button>
            <button class="btn-remove-additional" data-id="${item.id}" style="background:none;border:none;color:#ef4444;cursor:pointer;font-size:14px;padding:4px 8px;" title="Remove">√ó</button>
          </div>
        `).join('');

        return `
          <div class="additional-items" style="margin-top:10px;padding:12px;background:rgba(77,163,255,0.05);border:1px solid rgba(77,163,255,0.2);border-radius:8px;">
            <div class="additional-items-header" style="font-size:12px;color:#6b7280;font-weight:600;margin-bottom:8px;">
              + ${items.length} additional item(s)
            </div>
            <div class="additional-items-list">
              ${itemsHtml}
            </div>
            <button class="btn-add-additional" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" style="margin-top:10px;padding:8px 16px;background:#4da3ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;">
              + Add Side/Dessert
            </button>
          </div>
        `;
      } catch (e) {
        console.warn('Error loading additional items:', e);
        return '';
      }
    }

    function slotLine(date, slot, meal){
      const hasRecipe = !!(meal && meal.RecipeId);
      const title = hasRecipe ? meal.Title : '(empty)';
      const rid = hasRecipe ? meal.RecipeId : '';
      const useLeft = !!(meal && (meal.UseLeftovers === true || meal.UseLeftovers === 1 || meal.UseLeftovers === 'true'));
      const from = meal && meal.From ? meal.From : '';
      
      // DEBUG: Log to console for debugging
      if (useLeft) {
        console.log('Leftovers meal detected:', { date, slot, title, useLeft, from });
      }
      
      // Parse the from field to extract meal info (format: "YYYY-MM-DD Slot ‚Äî Title")
      let sourceTitle = '';
      let sourceSlotInfo = '';
      if (from) {
        const match = from.match(/^(\d{4}-\d{2}-\d{2})\s+(\w+)\s+[‚Äî‚Äì-]\s+(.+)$/);
        if (match) {
          sourceSlotInfo = `${match[1]} ${match[2]}`;
          sourceTitle = match[3];
        }
      }
      
      // Display title - show the source meal title when it's a leftovers slot
      let displayTitle = escapeHtml(title);
      if (useLeft) {
        if (sourceTitle) {
          // Has source meal info - show arrow and badge
          displayTitle = `<span style="color:#4da3ff;font-weight:600;">‚Ü≥ ${escapeHtml(sourceTitle)}</span> <span style="color:#fbbf24;font-size:11px;font-weight:600;background:rgba(251,191,36,0.2);padding:2px 6px;border-radius:4px;margin-left:6px;">LEFTOVERS</span>`;
        } else {
          // No source info but marked as leftovers - still show badge
          displayTitle = `<span style="color:#fbbf24;font-size:11px;font-weight:600;background:rgba(251,191,36,0.2);padding:2px 6px;border-radius:4px;margin-right:6px;">LEFTOVERS</span> ${escapeHtml(title)}`;
        }
      }
      
      // From info display
      const fromHtml = from ? `<div class="muted" style="margin-top:4px;font-size:11px;display:flex;align-items:center;gap:6px;"><span style="color:#4da3ff;">‚Ü±</span> <span>From: ${escapeHtml(sourceSlotInfo)}</span></div>` : '';
      
      // Style for the leftovers button - blue background when active for visibility
      const leftoversBtnStyle = useLeft 
        ? "background:#1e40af;color:#ffffff;font-weight:600;border:2px solid #1e40af;" 
        : "background:#dbeafe;color:#1e40af;border:2px solid #3b82f6;";
      
      // Button is always enabled now to allow selecting leftovers for empty slots
      
      return `
        <div class="item" style="margin-top:8px;${useLeft ? 'border-left:4px solid #3b82f6;padding-left:12px;background:linear-gradient(90deg, rgba(59,130,246,0.08) 0%, transparent 30%);' : ''}">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
            <div style="min-width:0;">
              <div><strong>${escapeHtml(slot)}:</strong> ${displayTitle}</div>
              ${fromHtml}
            </div>
            <div class="actions" style="flex-wrap:wrap;">
              <button class="primary" data-action="select-meal" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}">Select</button>
              <button class="ghost" data-action="planner-view" data-rid="${escapeAttr(rid)}" ${hasRecipe ? '' : 'disabled'}>View</button>
              <button class="ghost" data-action="planner-edit" data-rid="${escapeAttr(rid)}" ${hasRecipe ? '' : 'disabled'}>Edit</button>
              <button class="ghost" data-action="planner-print" data-rid="${escapeAttr(rid)}" ${hasRecipe ? '' : 'disabled'}>Print</button>
              <button style="${leftoversBtnStyle}padding:8px 12px;border-radius:8px;cursor:pointer;font-size:12px;" data-action="planner-leftovers" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" data-rid="${escapeAttr(rid)}" data-title="${escapeAttr(hasRecipe ? title : '')}">${useLeft ? '‚úì Leftovers' : 'Use leftovers'}</button>
            </div>
          </div>
          ${hasRecipe ? `
          <details style="margin-top:10px; padding:8px; background:rgba(77,163,255,0.05); border:1px solid rgba(77,163,255,0.2); border-radius:6px;">
            <summary style="cursor:pointer; font-size:12px; font-weight:600; color:var(--accent); user-select:none;">üìä Pantry Impact</summary>
            <div class="pantry-depletion-content" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" data-rid="${escapeAttr(rid)}" style="margin-top:8px; font-size:12px;">
              <div class="muted">Loading...</div>
            </div>
          </details>
          ` : ''}
          <div class="additional-items-container" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}"></div>
          ${hasRecipe || !hasRecipe ? `
          <div style="display:flex;gap:8px;margin-top:10px;">
            <button class="btn-add-additional-main" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" style="flex:1;padding:8px 16px;background:#4da3ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;">
              + Add Side/Dessert
            </button>
            <button class="btn-assign-collection" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" style="flex:1;padding:8px 16px;background:#10b981;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;">
              üìö Assign Collection
            </button>
          </div>
          ` : ''}
        </div>
      `;
    }


    async function loadPantryDepletionForMeal(date, slot, rid) {
      // This would ideally call an API to get depletion data for this specific meal
      // For now, we'll fetch the recipe ingredients and simulate the depletion
      const res = await api('listRecipeIngredients', { recipeId: rid });
      if (!res.ok || !res.items) {
        return '<div class="muted">Unable to load pantry impact data.</div>';
      }
      
      const ingredients = res.items || [];
      if (ingredients.length === 0) {
        return '<div class="muted">No ingredients tracked for this recipe.</div>';
      }
      
      // Fetch current pantry to show remaining levels
      const pantryRes = await api('listPantry', { q: '' });
      const pantryItems = (pantryRes.ok && pantryRes.items) ? pantryRes.items : [];
      const pantryMap = {};
      for (const p of pantryItems) {
        const key = String(p.Name || '').trim().toLowerCase();
        pantryMap[key] = p;
      }
      
      let html = '<div style="margin-top:6px;">';
      let hasDeductions = false;
      
      for (const ing of ingredients) {
        const ingName = ing.IngredientNorm || ing.IngredientRaw || '';
        if (!ingName) continue;
        
        const qtyDisplay = [ing.QtyText || ing.QtyNum || '', ing.Unit || ''].filter(Boolean).join(' ').trim();
        if (!qtyDisplay) continue;
        
        // Check if we have this in pantry
        const pantryKey = ingName.toLowerCase();
        const pantryItem = pantryMap[pantryKey];
        
        if (pantryItem) {
          hasDeductions = true;
          const currentQty = pantryItem.QtyNum || 0;
          const unit = pantryItem.Unit || '';
          const remaining = currentQty;
          const lowThreshold = pantryItem.low_stock_threshold || 0;
          const isLow = remaining <= lowThreshold && lowThreshold > 0;
          const warningStyle = isLow ? 'color: #d32f2f; font-weight: 600;' : '';
          
          html += `
            <div style="padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
              <div style="display:flex; justify-content:space-between; align-items:center;">
                <span>${escapeHtml(ingName)}</span>
                <span class="muted" style="font-size:11px;">Uses: ${escapeHtml(qtyDisplay)}</span>
              </div>
              <div style="margin-top:2px; display:flex; justify-content:space-between; font-size:11px;">
                <span class="muted">Pantry remaining:</span>
                <span style="${warningStyle}">${remaining} ${unit}${isLow ? ' ‚ö†Ô∏è LOW' : ''}</span>
              </div>
            </div>
          `;
        }
      }
      
      if (!hasDeductions) {
        html += '<div class="muted">No pantry items affected by this meal.</div>';
      }
      
      html += '</div>';
      return html;
    }

    
    function renderPlanner(containerId, start, days, includeSwap){
      const box = document.getElementById(containerId);
      if (!box) return;
      const dates = [];
      for (let i=0;i<days;i++) dates.push(addDays(start, i));

      box.innerHTML = dates.map(date => {
        const p = PLAN.plansByDate[date] || { Date: date, Breakfast:null, Lunch:null, Dinner:null };
        return `
          <details open class="item" data-day="${escapeAttr(date)}">
            <summary>${escapeHtml(date)}</summary>
            <div style="margin-top:10px;">
              ${slotLine(date,'Breakfast', p.Breakfast)}
              ${slotLine(date,'Lunch', p.Lunch)}
              ${slotLine(date,'Dinner', p.Dinner)}
              ${includeSwap ? `
                <div class="hr"></div>
                <div class="actions">
                  <button style="background:#4da3ff;color:#000;border:none;padding:10px 16px;border-radius:8px;font-weight:600;cursor:pointer;" data-action="swap" data-date="${escapeAttr(date)}" data-a="Breakfast" data-b="Lunch">üîÑ Swap Breakfast/Lunch</button>
                  <button style="background:#4da3ff;color:#000;border:none;padding:10px 16px;border-radius:8px;font-weight:600;cursor:pointer;" data-action="swap" data-date="${escapeAttr(date)}" data-a="Lunch" data-b="Dinner">üîÑ Swap Lunch/Dinner</button>
                  <button style="background:#4da3ff;color:#000;border:none;padding:10px 16px;border-radius:8px;font-weight:600;cursor:pointer;" data-action="swap" data-date="${escapeAttr(date)}" data-a="Breakfast" data-b="Dinner">üîÑ Swap Breakfast/Dinner</button>
                </div>
              ` : ''}
            </div>
          </details>
        `;
      }).join('');
      
      // Load additional items for all slots after rendering
      setTimeout(async () => {
        const containers = box.querySelectorAll('.additional-items-container');
        for (const container of containers) {
          const date = container.dataset.date;
          const slot = container.dataset.slot;
          const html = await renderAdditionalItemsAsync_(date, slot);
          container.innerHTML = html;
        }
      }, 0);
    }


    
    // Pick which prior meal/day the leftovers come from, for annotation.
    async function pickLeftoversSourceAsync_(targetDate, targetSlot){
      const opts = [];
      const dates = [];
      for (let i=0;i<PLAN.days;i++) dates.push(addDays(PLAN.start, i));

      for (const d of dates) {
        if (d >= targetDate) continue;
        const day = PLAN.plansByDate[d];
        if (!day) continue;
        for (const slot of ['Breakfast','Lunch','Dinner']) {
          const m = day[slot];
          if (!m || !m.RecipeId || !m.Title) continue;
          // Only show meals that are NOT already marked as leftovers
          if (m.UseLeftovers) continue;
          opts.push({ 
            value: `${d} ${slot} ‚Äî ${m.Title}`, 
            label: `${d} ${slot}: ${m.Title}`,
            recipeId: m.RecipeId,
            title: m.Title
          });
        }
      }
      if (!opts.length) {
        alert('No previous meals found to use as leftovers.\n\nTip: First plan some regular meals, then come back and mark them as leftovers for future days.');
        return null;
      }

      return await new Promise((resolve) => {
        const ov = document.createElement('div');
        ov.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:9999;';

        const card = document.createElement('div');
        card.style.cssText = 'background:#ffffff;border-radius:16px;padding:28px;max-width:480px;width:90%;box-shadow:0 25px 80px rgba(0,0,0,0.5);';

        card.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
            <div style="font-size:20px;font-weight:700;color:#111;">üçΩÔ∏è Select Meal to Reuse</div>
            <button id="lofClose" style="padding:10px 16px;border-radius:50%;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:18px;color:#6b7280;">‚úï</button>
          </div>
          <div style="font-size:15px;color:#111111;line-height:1.6;margin-bottom:20px;padding:16px;background:#f3f4f6;border-radius:10px;">
            <strong style="color:#111111;">${escapeHtml(targetDate)} ${escapeHtml(targetSlot)}</strong><br>
            Choose which meal to reuse as leftovers:
          </div>
          <select id="lofSel" style="width:100%;padding:14px 16px;border:2px solid #3b82f6;border-radius:10px;font-size:15px;margin-bottom:20px;background:#fff;cursor:pointer;color:#111;">
            ${opts.map(o => `<option value="${escapeAttr(o.value)}" style="color:#111;">${escapeHtml(o.label)}</option>`).join('')}
          </select>
          <div style="display:flex;justify-content:flex-end;gap:12px;">
            <button id="lofSkip" style="padding:14px 24px;border-radius:10px;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:14px;color:#374151;">Cancel</button>
            <button id="lofOk" style="padding:14px 28px;border-radius:10px;font-weight:600;background:#2563eb;color:#ffffff;border:none;cursor:pointer;font-size:14px;box-shadow:0 4px 12px rgba(37,99,235,0.3);">Use This Meal</button>
          </div>
        `;

        ov.appendChild(card);
        document.body.appendChild(ov);

        function cleanup(val){
          try { document.body.removeChild(ov); } catch(_) {}
          resolve(val);
        }

        card.querySelector('#lofClose').addEventListener('click', () => cleanup(null));
        card.querySelector('#lofSkip').addEventListener('click', () => cleanup(null));
        card.querySelector('#lofOk').addEventListener('click', () => {
          const sel = card.querySelector('#lofSel');
          const selectedOption = opts[sel.selectedIndex];
          // Return object with string value for parsing and recipe details for the meal
          cleanup(selectedOption ? {
            value: sel.value,
            recipeId: selectedOption.recipeId,
            title: selectedOption.title
          } : null);
        });
        ov.addEventListener('click', (ev) => { if (ev.target === ov) cleanup(null); });
      });
    }

    // Show modal to add additional item (side, dessert, etc.) to a meal slot
    async function showAddAdditionalItemModal(date, slot) {
      console.log('[showAddAdditionalItemModal] Opening modal for', date, slot);
      console.log('[showAddAdditionalItemModal] RECIPES array length:', RECIPES ? RECIPES.length : 'undefined');
      
      return new Promise((resolve) => {
        const ov = document.createElement('div');
        ov.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:9999;';

        const card = document.createElement('div');
        card.style.cssText = 'background:#ffffff;border-radius:16px;padding:28px;max-width:600px;width:90%;box-shadow:0 25px 80px rgba(0,0,0,0.5);max-height:80vh;overflow-y:auto;';
        
        console.log('[showAddAdditionalItemModal] Modal elements created');

        card.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
            <div style="font-size:20px;font-weight:700;color:#111;">üçΩÔ∏è Add Side/Dessert</div>
            <button id="addItemClose" style="padding:10px 16px;border-radius:50%;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:18px;color:#6b7280;">‚úï</button>
          </div>
          <div style="font-size:15px;color:#111111;line-height:1.6;margin-bottom:20px;padding:16px;background:#f3f4f6;border-radius:10px;">
            <strong style="color:#111111;">${escapeHtml(date)} ${escapeHtml(slot)}</strong><br>
            Search for a recipe to add as a side dish, dessert, appetizer, or beverage:
          </div>
          
          <div style="margin-bottom:20px;">
            <input type="text" id="addItemSearch" placeholder="Search recipes..." style="width:100%;padding:14px 16px;border:2px solid #3b82f6;border-radius:10px;font-size:15px;margin-bottom:10px;color:#111111;" />
            <div style="margin-bottom:10px;">
              <label style="display:block;margin-bottom:4px;font-size:13px;font-weight:600;color:#374151;">Filter by Meal Type:</label>
              <select id="addItemMealTypeFilter" style="width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;background:#fff;cursor:pointer;color:#111;">
                <option value="">All Recipes</option>
                <option value="Side">Side Dish</option>
                <option value="Dessert">Dessert</option>
                <option value="Appetizer">Appetizer</option>
                <option value="Beverage">Beverage</option>
                <option value="Salad">Salad</option>
                <option value="Soup">Soup</option>
                <option value="Breakfast">Breakfast</option>
                <option value="Lunch">Lunch</option>
                <option value="Dinner">Dinner</option>
              </select>
            </div>
            <div id="addItemResults" style="max-height:300px;overflow-y:auto;border:1px solid #e5e7eb;border-radius:8px;"></div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block;margin-bottom:8px;font-size:14px;font-weight:600;color:#374151;">Item Type:</label>
            <select id="addItemType" style="width:100%;padding:14px 16px;border:2px solid #3b82f6;border-radius:10px;font-size:15px;background:#fff;cursor:pointer;color:#111;">
              <option value="side">Side Dish</option>
              <option value="dessert">Dessert</option>
              <option value="appetizer">Appetizer</option>
              <option value="beverage">Beverage</option>
              <option value="salad">Salad</option>
              <option value="soup">Soup</option>
            </select>
          </div>

          <div style="display:flex;justify-content:flex-end;gap:12px;">
            <button id="addItemCancel" style="padding:14px 24px;border-radius:10px;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:14px;color:#374151;">Cancel</button>
            <button id="addItemOk" disabled style="padding:14px 28px;border-radius:10px;font-weight:600;background:#2563eb;color:#ffffff;border:none;cursor:pointer;font-size:14px;box-shadow:0 4px 12px rgba(37,99,235,0.3);opacity:0.5;">Add Item</button>
          </div>
        `;

        ov.appendChild(card);
        document.body.appendChild(ov);

        console.log('[showAddAdditionalItemModal] Card appended to DOM');
        console.log('[showAddAdditionalItemModal] Card.innerHTML length:', card.innerHTML.length);
        console.log('[showAddAdditionalItemModal] First 1000 chars of HTML:', card.innerHTML.substring(0, 1000));
        console.log('[showAddAdditionalItemModal] ov element:', ov);
        console.log('[showAddAdditionalItemModal] Is ov in document?', document.body.contains(ov));
        console.log('[showAddAdditionalItemModal] Looking for #addItemSearch...');

        let selectedRecipe = null;

        function cleanup(val) {
          console.log('[showAddAdditionalItemModal] cleanup called with:', val);
          try { document.body.removeChild(ov); } catch(_) {}
          resolve(val);
        }

        // Search functionality
        const searchInput = card.querySelector('#addItemSearch');
        const resultsDiv = card.querySelector('#addItemResults');
        const okBtn = card.querySelector('#addItemOk');
        const mealTypeFilter = card.querySelector('#addItemMealTypeFilter');

        console.log('[showAddAdditionalItemModal] searchInput element:', searchInput);
        console.log('[showAddAdditionalItemModal] resultsDiv element:', resultsDiv);
        
        if (!searchInput || !resultsDiv || !okBtn) {
          console.error('[showAddAdditionalItemModal] CRITICAL: Elements not found!');
          console.error('[showAddAdditionalItemModal] card.innerHTML:', card.innerHTML.substring(0, 500));
          alert('Error: Modal failed to initialize. Check console for details.');
          cleanup(null);
          return;
        }
        
        // Test that input is working
        searchInput.addEventListener('focus', () => {
          console.log('[addItemSearch] Input field focused');
        });

        // Check if RECIPES is loaded
        if (!RECIPES || RECIPES.length === 0) {
          resultsDiv.innerHTML = '<div style="padding:12px;color:#f59e0b;">Loading recipes... Please go to Recipes tab first to load the recipe database.</div>';
        }

        // Function to perform search with current filters
        function performSearch() {
          const q = searchInput.value.trim();
          const mealTypeFilterValue = mealTypeFilter.value;
          
          if (!q && !mealTypeFilterValue) {
            resultsDiv.innerHTML = '';
            return;
          }

          console.log('[addItemSearch] Searching for:', q, 'MealType filter:', mealTypeFilterValue, 'in', RECIPES.length, 'recipes');

          // Search in already loaded RECIPES array for performance
          const lowerQ = q.toLowerCase();
          let matchedRecipes = RECIPES.filter(recipe => {
            const titleMatch = !q || (recipe.Title || '').toLowerCase().includes(lowerQ);
            const cuisineMatch = !q || (recipe.Cuisine || '').toLowerCase().includes(lowerQ);
            const textMatch = titleMatch || cuisineMatch;
            
            // Apply meal type filter
            const mealTypeMatch = !mealTypeFilterValue || (recipe.MealType || '').toLowerCase() === mealTypeFilterValue.toLowerCase();
            
            return textMatch && mealTypeMatch;
          }).slice(0, 20);

          console.log('[addItemSearch] Found', matchedRecipes.length, 'matches');

          if (matchedRecipes.length > 0) {
            resultsDiv.innerHTML = matchedRecipes.map(recipe => `
              <div class="recipe-result-item" data-recipe-id="${escapeAttr(recipe.RecipeId)}" data-recipe-title="${escapeAttr(recipe.Title)}" style="padding:12px;border-bottom:1px solid #e5e7eb;cursor:pointer;display:flex;justify-content:space-between;align-items:center;">
                <div>
                  <div style="font-weight:600;color:#111;">${escapeHtml(recipe.Title)}</div>
                  <div style="font-size:12px;color:#6b7280;">
                    ${recipe.MealType ? `<span style="background:#e0f2fe;color:#0369a1;padding:2px 6px;border-radius:3px;margin-right:4px;">${escapeHtml(recipe.MealType)}</span>` : ''}
                    ${recipe.Cuisine ? escapeHtml(recipe.Cuisine) : ''}
                  </div>
                </div>
                <button class="select-recipe-btn" style="padding:6px 12px;background:#4da3ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;">Select</button>
              </div>
            `).join('');
          } else {
            resultsDiv.innerHTML = '<div style="padding:12px;color:#6b7280;">No recipes found</div>';
          }
        }

        let searchTimeout;
        searchInput.addEventListener('input', (event) => {
          console.log('[addItemSearch] Input event fired, value:', event.target.value);
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(performSearch, 300);
        });

        // Trigger search when meal type filter changes
        mealTypeFilter.addEventListener('change', () => {
          console.log('[addItemSearch] Meal type filter changed to:', mealTypeFilter.value);
          performSearch();
        });

        // Recipe selection
        resultsDiv.addEventListener('click', (e) => {
          console.log('[addItemSearch] Click event:', e.target);
          const resultItem = e.target.closest('.recipe-result-item');
          if (resultItem) {
            console.log('[addItemSearch] Selected recipe:', resultItem.dataset.recipeId, resultItem.dataset.recipeTitle);
            selectedRecipe = {
              recipeId: resultItem.dataset.recipeId,
              title: resultItem.dataset.recipeTitle
            };
            
            // Highlight selected
            resultsDiv.querySelectorAll('.recipe-result-item').forEach(item => {
              item.style.background = '';
            });
            resultItem.style.background = 'rgba(77,163,255,0.1)';
            
            okBtn.disabled = false;
            okBtn.style.opacity = '1';
          }
        });

        card.querySelector('#addItemClose').addEventListener('click', () => cleanup(null));
        card.querySelector('#addItemCancel').addEventListener('click', () => cleanup(null));
        card.querySelector('#addItemOk').addEventListener('click', async () => {
          if (!selectedRecipe) return;
          
          const itemType = card.querySelector('#addItemType').value;
          
          const result = await api('addAdditionalItem', {
            date,
            slot,
            recipeId: selectedRecipe.recipeId,
            title: selectedRecipe.title,
            itemType
          });
          
          if (result.ok) {
            await loadPlansIntoUi(PLAN.start, PLAN.days);
            cleanup(true);
          } else {
            alert('Error adding item: ' + (result.message || 'Unknown error'));
          }
        });
        
        // Prevent clicks on card from closing modal
        card.addEventListener('click', (ev) => {
          ev.stopPropagation();
        });
        
        ov.addEventListener('click', (ev) => { 
          console.log('[showAddAdditionalItemModal] Overlay clicked, target:', ev.target);
          if (ev.target === ov) {
            console.log('[showAddAdditionalItemModal] Closing modal from overlay click');
            cleanup(null);
          }
        });
      });
    }

    // Show popover for additional items in grid view
    async function showGridAdditionalItemsPopover(buttonEl, date, slot) {
      // Remove any existing popover
      const existing = document.querySelector('.grid-additional-popover');
      if (existing) existing.remove();

      // Fetch additional items
      const result = await api('getAdditionalItems', { date, slot });
      if (!result.ok || !result.items || result.items.length === 0) {
        return;
      }

      const items = result.items;
      
      // Create popover
      const popover = document.createElement('div');
      popover.className = 'grid-additional-popover';
      popover.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
          <div style="font-weight:600;color:#111;">Additional Items</div>
          <button class="popover-close-btn" style="background:none;border:none;color:#6b7280;cursor:pointer;font-size:18px;padding:4px;line-height:1;">√ó</button>
        </div>
        ${items.map(item => `
          <div class="popover-item" style="padding:8px 0;border-bottom:1px solid #e5e7eb;display:flex;align-items:center;gap:8px;">
            <span class="item-type-badge" style="background:#4da3ff;color:white;padding:3px 8px;border-radius:4px;font-size:10px;text-transform:uppercase;font-weight:600;">${escapeHtml(item.ItemType || 'side')}</span>
            <span style="flex:1;font-size:13px;color:#374151;">${escapeHtml(item.Title || '')}</span>
            <button class="ghost" data-action="planner-view" data-rid="${escapeAttr(item.RecipeId)}" style="padding:4px 8px;font-size:11px;">View</button>
          </div>
        `).join('')}
        <button class="btn-add-additional" data-date="${escapeAttr(date)}" data-slot="${escapeAttr(slot)}" style="margin-top:10px;width:100%;padding:8px 16px;background:#4da3ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;">
          + Add More
        </button>
      `;

      document.body.appendChild(popover);

      // Position the popover below the button
      const rect = buttonEl.getBoundingClientRect();
      popover.style.position = 'fixed';
      popover.style.top = `${rect.bottom + 5}px`;
      popover.style.left = `${rect.left}px`;
      popover.style.zIndex = '10000';

      // Function to close popover
      const closePopover = () => {
        popover.remove();
        document.removeEventListener('click', clickOutsideHandler);
      };

      // Close button handler
      popover.querySelector('.popover-close-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        closePopover();
      });

      // Close when "Add More" is clicked (will open the modal)
      popover.querySelector('.btn-add-additional').addEventListener('click', () => {
        closePopover();
      });

      // Close popover when clicking outside
      const clickOutsideHandler = (e) => {
        if (!popover.contains(e.target) && !buttonEl.contains(e.target)) {
          closePopover();
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', clickOutsideHandler);
      }, 0);
    }

    // Show modal to assign a collection to a meal slot
    async function showAssignCollectionModal(date, slot) {
      return new Promise(async (resolve) => {
        // Load collections first
        const collectionsResult = await api('listCollections', {});
        if (!collectionsResult.ok || !collectionsResult.collections || collectionsResult.collections.length === 0) {
          alert('No collections found. Please create a collection first in the Collections tab.');
          resolve(null);
          return;
        }

        const collections = collectionsResult.collections;

        const ov = document.createElement('div');
        ov.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:9999;';

        const card = document.createElement('div');
        card.style.cssText = 'background:#ffffff;border-radius:16px;padding:28px;max-width:500px;width:90%;box-shadow:0 25px 80px rgba(0,0,0,0.5);';

        card.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;">
            <div style="font-size:20px;font-weight:700;color:#111;">üìö Assign Collection</div>
            <button id="assignCollectionClose" style="padding:10px 16px;border-radius:50%;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:18px;color:#6b7280;">‚úï</button>
          </div>
          <div style="font-size:15px;color:#111111;line-height:1.6;margin-bottom:20px;padding:16px;background:#f3f4f6;border-radius:10px;">
            <strong style="color:#111111;">${escapeHtml(date)} ${escapeHtml(slot)}</strong><br>
            Select a collection to assign to this meal slot. The first recipe will become the main meal, and the rest will be added as sides/desserts.
          </div>
          
          <div style="margin-bottom:20px;">
            <label style="display:block;margin-bottom:8px;font-size:14px;font-weight:600;color:#374151;">Select Collection:</label>
            <select id="collectionSelect" style="width:100%;padding:14px 16px;border:2px solid #3b82f6;border-radius:10px;font-size:15px;background:#fff;cursor:pointer;color:#111;">
              <option value="">-- Choose a collection --</option>
              ${collections.map(c => `<option value="${escapeAttr(c.CollectionId)}">${escapeHtml(c.Name)}</option>`).join('')}
            </select>
          </div>

          <div style="display:flex;justify-content:flex-end;gap:12px;">
            <button id="assignCollectionCancel" style="padding:14px 24px;border-radius:10px;border:1px solid #e5e7eb;background:#f9fafb;cursor:pointer;font-size:14px;color:#374151;">Cancel</button>
            <button id="assignCollectionOk" disabled style="padding:14px 28px;border-radius:10px;font-weight:600;background:#2563eb;color:#ffffff;border:none;cursor:pointer;font-size:14px;box-shadow:0 4px 12px rgba(37,99,235,0.3);opacity:0.5;">Assign Collection</button>
          </div>
        `;

        ov.appendChild(card);
        document.body.appendChild(ov);

        function cleanup(val) {
          try { document.body.removeChild(ov); } catch(_) {}
          resolve(val);
        }

        const selectEl = card.querySelector('#collectionSelect');
        const okBtn = card.querySelector('#assignCollectionOk');

        selectEl.addEventListener('change', () => {
          if (selectEl.value) {
            okBtn.disabled = false;
            okBtn.style.opacity = '1';
          } else {
            okBtn.disabled = true;
            okBtn.style.opacity = '0.5';
          }
        });

        card.querySelector('#assignCollectionClose').addEventListener('click', () => cleanup(null));
        card.querySelector('#assignCollectionCancel').addEventListener('click', () => cleanup(null));
        card.querySelector('#assignCollectionOk').addEventListener('click', async () => {
          const collectionId = selectEl.value;
          if (!collectionId) return;

          console.log('[assignCollectionModal] Assigning collection', collectionId, 'to', date, slot);

          const result = await api('assignCollectionToSlot', {
            date,
            slot,
            collectionId
          });

          console.log('[assignCollectionModal] API result:', result);

          if (result.ok) {
            // Get collection name before cleanup
            const collectionName = selectEl.options[selectEl.selectedIndex].text;
            
            // Reload the current planner view to show changes FIRST
            console.log('[assignCollectionModal] Reloading planner view');
            await loadPlansIntoUi(PLAN.start, PLAN.days);
            
            // Wait a moment for render to complete (includes additional items timeout)
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Force scroll to the assigned date if in list view
            if (PLAN.viewMode === 'list') {
              const dayElement = document.querySelector(`#planList [data-day="${date}"]`);
              if (dayElement) {
                dayElement.open = true;  // Ensure details is expanded
                dayElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }
            
            // Then cleanup modal
            cleanup(true);
            
            // Show success message after everything is done
            alert(`Collection "${collectionName}" assigned to ${slot} on ${date}`);
          } else {
            alert('Error assigning collection: ' + (result.error || 'Unknown error'));
          }
        });

        ov.addEventListener('click', (ev) => { if (ev.target === ov) cleanup(null); });
      });
    }

    // Show modal to assign collection from Collections tab - prompts for date and slot
    async function showAssignCollectionFromCollectionsTab(collectionId, collectionName) {
      const cleanup = (ok) => {
        if (card) card.remove();
        if (ov) ov.remove();
      };

      const ov = document.createElement('div');
      ov.className = 'modal-overlay';
      ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:9999;display:flex;align-items:center;justify-content:center;';
      
      const card = document.createElement('div');
      card.className = 'modal-card';
      card.style.cssText = 'background:#fff;border-radius:12px;padding:24px;min-width:400px;max-width:90vw;box-shadow:0 8px 32px rgba(0,0,0,0.3);';
      card.innerHTML = `
        <h3 style="margin-top:0;margin-bottom:16px;color:#111;font-size:20px;">Assign Collection to Meal Plan</h3>
        <p style="margin-bottom:16px;color:#374151;font-size:14px;">
          Collection: <strong>${escapeHtml(collectionName)}</strong>
        </p>
        
        <div style="margin-bottom:16px;">
          <label style="display:block;margin-bottom:4px;font-size:13px;font-weight:600;color:#374151;">Select Date:</label>
          <input type="date" id="assignCollectionDate" style="width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;color:#111111;color-scheme:light;" />
        </div>
        
        <div style="margin-bottom:20px;">
          <label style="display:block;margin-bottom:4px;font-size:13px;font-weight:600;color:#374151;">Select Meal Slot:</label>
          <select id="assignCollectionSlot" style="width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;background:#fff;cursor:pointer;color:#111111;">
            <option value="">-- Choose a slot --</option>
            <option value="Breakfast">Breakfast</option>
            <option value="Lunch">Lunch</option>
            <option value="Dinner">Dinner</option>
          </select>
        </div>
        
        <div style="display:flex;gap:10px;justify-content:flex-end;">
          <button id="assignCollectionCancel" style="padding:10px 20px;background:#e5e7eb;color:#374151;border:none;border-radius:8px;cursor:pointer;font-weight:600;">Cancel</button>
          <button id="assignCollectionOk" style="padding:10px 20px;background:#10b981;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:600;" disabled>Assign Collection</button>
        </div>
      `;
      
      ov.appendChild(card);
      document.body.appendChild(ov);
      
      const dateInput = card.querySelector('#assignCollectionDate');
      const slotSelect = card.querySelector('#assignCollectionSlot');
      const okBtn = card.querySelector('#assignCollectionOk');
      
      // Set default date to today
      const today = new Date();
      dateInput.value = today.toISOString().split('T')[0];
      
      // Enable OK button when slot is selected
      const validateForm = () => {
        okBtn.disabled = !dateInput.value || !slotSelect.value;
      };
      
      dateInput.addEventListener('change', validateForm);
      slotSelect.addEventListener('change', validateForm);
      
      card.querySelector('#assignCollectionCancel').addEventListener('click', () => cleanup(false));
      
      card.querySelector('#assignCollectionOk').addEventListener('click', async () => {
        const date = dateInput.value;
        const slot = slotSelect.value;
        
        if (!date || !slot) return;
        
        console.log('[assignCollectionFromCollectionsTab] Assigning collection', collectionId, 'to', date, slot);
        
        const result = await api('assignCollectionToSlot', {
          date,
          slot,
          collectionId
        });
        
        console.log('[assignCollectionFromCollectionsTab] API result:', result);
        
        if (result.ok) {
          // Switch to Meal Planner tab FIRST
          document.querySelector('[data-tab="planner"]').click();
          
          // Wait for tab switch to complete
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // Determine the best start date for the view
          // If the assigned date is within the current view, keep current view
          // Otherwise, start from today or the assigned date (whichever is earlier)
          const currentStart = PLAN.start || ymd(new Date());
          const currentDays = PLAN.days || 7;
          const assignedDate = new Date(date);
          const currentStartDate = new Date(currentStart);
          const currentEndDate = new Date(currentStartDate);
          currentEndDate.setDate(currentEndDate.getDate() + currentDays - 1);
          
          let startDate;
          let days;
          
          // Check if assigned date is within current view
          if (assignedDate >= currentStartDate && assignedDate <= currentEndDate) {
            // Keep current view - assigned date is already visible
            startDate = currentStart;
            days = currentDays;
            console.log('[assignCollectionFromCollectionsTab] Assigned date within current view, keeping view:', startDate);
          } else {
            // Assigned date is outside current view
            // Start from today or assigned date (whichever is earlier) to show context
            const today = new Date();
            const earliestDate = assignedDate < today ? assignedDate : today;
            startDate = ymd(earliestDate);
            days = 7;
            console.log('[assignCollectionFromCollectionsTab] Assigned date outside view, adjusting to:', startDate);
          }
          
          await loadPlansIntoUi(startDate, days);
          
          // Wait for render to complete (includes additional items timeout)
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Force scroll to the assigned date and expand the details
          const dayElement = document.querySelector(`#planList [data-day="${date}"]`);
          if (dayElement) {
            dayElement.open = true;  // Ensure details is expanded
            dayElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          
          // Close modal
          cleanup(true);
          
          // Show success message
          alert(`Collection "${collectionName}" assigned to ${slot} on ${date}`);
        } else {
          alert('Error assigning collection: ' + (result.error || 'Unknown error'));
        }
      });
      
      ov.addEventListener('click', (ev) => { if (ev.target === ov) cleanup(false); });
    }

document.addEventListener('click', async (e) => {
      // Planner: Select / Replace opens the recipe picker
      const sel = e.target.closest('[data-action="select-meal"]');
      if (sel) { openMealPicker(sel.dataset.date, sel.dataset.slot); return; }

      // Backwards compatibility: older markup
      const pick = e.target.closest('[data-action="pick-meal"]');
      if (pick) { openMealPicker(pick.dataset.date, pick.dataset.slot); return; }

      // Planner: View/Edit/Print
      const pv = e.target.closest('[data-action="planner-view"],[data-action="view-meal"]');
      if (pv) { const rid = pv.dataset.rid; if (rid) await openRecipeModalView(rid); return; }

      const pe = e.target.closest('[data-action="planner-edit"],[data-action="edit-meal"]');
      if (pe) { const rid = pe.dataset.rid; if (rid) await openRecipeModalEdit(rid); return; }

      const pp = e.target.closest('[data-action="planner-print"],[data-action="print-meal"]');
      if (pp) { 
        const rid = pp.dataset.rid; 
        if (rid) {
          // Load recipe first, wait for it to fully load with categories
          await openRecipeModalView(rid);
          // Now print with whatever quantities are displayed
          printRecipeWithQuantities();
        }
        return; 
      }

      // Planner: Clear
      const clear = e.target.closest('[data-action="clear-meal"]');
      if (clear) {
        await api('upsertPlanMeal', { date: clear.dataset.date, slot: clear.dataset.slot, meal: null });
        await loadPlansIntoUi(PLAN.start, PLAN.days);
        await loadPantry(); // Refresh pantry after clearing meal
        return;
      }

      // Additional Items: Add Side/Dessert button
      const btnAdd = e.target.closest('.btn-add-additional,.btn-add-additional-main');
      if (btnAdd) {
        console.log('[Click Handler] Add Side/Dessert button clicked', btnAdd.dataset);
        const date = btnAdd.dataset.date;
        const slot = btnAdd.dataset.slot;
        console.log('[Click Handler] Calling showAddAdditionalItemModal with', date, slot);
        await showAddAdditionalItemModal(date, slot);
        return;
      }

      // Additional Items: Remove button
      const btnRemove = e.target.closest('.btn-remove-additional');
      if (btnRemove) {
        const id = btnRemove.dataset.id;
        if (confirm('Remove this additional item?')) {
          await api('removeAdditionalItem', { id });
          await loadPlansIntoUi(PLAN.start, PLAN.days);
        }
        return;
      }

      // Assign Collection button
      const btnAssignCollection = e.target.closest('.btn-assign-collection');
      if (btnAssignCollection) {
        const date = btnAssignCollection.dataset.date;
        const slot = btnAssignCollection.dataset.slot;
        await showAssignCollectionModal(date, slot);
        return;
      }

      // Grid View: Expand button for additional items
      const expandBtn = e.target.closest('.grid-expand-btn');
      if (expandBtn) {
        e.stopPropagation(); // Prevent dragging
        const date = expandBtn.dataset.date;
        const slot = expandBtn.dataset.slot;
        await showGridAdditionalItemsPopover(expandBtn, date, slot);
        return;
      }
    });

    // ---------- shopping list ----------
    const SHOP = { start:'', end:'', groups: [] };

    function normalizeShopTitle_(s){
      const str = String(s || '').trim();
      const denOk = new Set(['2','3','4','8','16']);
      let out = str.replace(/^(\d+)\s+(\d+)\s+(\d+)\b/, (m,a,b,c)=> denOk.has(c) ? `${a} ${b}/${c}` : m);
      out = out.replace(/^(\d+)\s+(\d+)\b/, (m,a,b)=> denOk.has(b) ? `${a}/${b}` : m);
      return out;
    }


    function shopQtyDisplay_(it){
      // Prefer numeric quantity when present; format as common cooking fractions for display.
      const qnRaw = (it && (it.QtyNum !== null && it.QtyNum !== undefined && it.QtyNum !== '')) ? Number(it.QtyNum) : null;
      const qn = (qnRaw !== null && Number.isFinite(qnRaw)) ? qnRaw : null;

      // If QtyText exists and looks meaningful, keep it (this mirrors ingredients behavior).
      // However, some legacy rows may have malformed QtyText; in that case, prefer QtyNum formatting.
      const qt = String((it && it.QtyText) || '').trim();

      function normalizeLostSlash_(s){
        const denOk = new Set(['2','3','4','8','16']);
        // "2 1 2 ..." => "2 1/2 ..."
        s = s.replace(/^(\d+)\s+(\d+)\s+(\d+)\b/, (m,a,b,c)=> denOk.has(c) ? `${a} ${b}/${c}` : m);
        // "1 2 ..." => "1/2 ..."
        s = s.replace(/^(\d+)\s+(\d+)\b/, (m,a,b)=> denOk.has(b) ? `${a}/${b}` : m);
        return s;
      }

      function fracFromNumber_(x){
        const sign = x < 0 ? -1 : 1;
        let v = Math.abs(x);

        const whole = Math.floor(v + 1e-12);
        const frac = v - whole;

        // Candidate denominators (common in recipes)
        const denoms = [2,3,4,8,16];
        let best = null;
        for (const d of denoms){
          const n = Math.round(frac * d);
          const approx = n / d;
          const err = Math.abs(approx - frac);
          if (!best || err < best.err){
            best = { n, d, err };
          }
        }

        // Relaxed threshold so common cooking decimals display correctly.
        if (!best || best.err > 0.02){
          return null;
        }

        let n = best.n;
        let d = best.d;
        if (n === 0){
          return sign * whole;
        }
        if (n === d){
          return sign * (whole + 1);
        }

        // Reduce fraction
        const gcd = (a,b)=> b ? gcd(b, a%b) : a;
        const g = gcd(n, d);
        n = n / g; d = d / g;

        const w = whole;
        const prefix = (sign < 0) ? '-' : '';
        if (w === 0){
          return `${prefix}${n}/${d}`;
        }
        return `${prefix}${w} ${n}/${d}`;
      }

      if (qn !== null){
        const asFrac = fracFromNumber_(qn);
        if (asFrac !== null){
          return String(asFrac);
        }
        // If it is effectively an integer, show as integer
        if (Math.abs(qn - Math.round(qn)) < 1e-9) return String(Math.round(qn));
        // Otherwise, fall back to up to 3 decimals without trailing zeros
        return String(Number(qn.toFixed(3))).replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
      }

      if (qt) return normalizeLostSlash_(qt);
      return '';
    }

    function storeOptionsHtml_(selectedId){
      const sid0 = String(selectedId || '');
      const sid = (!sid0 || sid0 === 'unassigned') ? (getDefaultStoreId() || '') : sid0;

      const opts = (STORES || []).map(s => {
        const v = String(s.StoreId);
        const sel = (v === sid) ? 'selected' : '';
        return `<option value="${escapeAttr(v)}" ${sel}>${escapeHtml(s.Name || v)}</option>`;
      }).join('');

      const unSel = (!sid) ? 'selected' : '';
      return `<option value="" ${unSel}>Unassigned</option>` + opts;
    }


    function cuisineOptionsHtml_(selectedCuisine){
      const cur = String(selectedCuisine || '').trim();

      // Use comprehensive cuisine list
      const items = COMPREHENSIVE_CUISINES.slice();
      
      // Add current value if not in list
      if (cur && !items.includes(cur)) {
        items.push(cur);
        items.sort((a,b) => a.localeCompare(b));
      }

      const noneSel = (!cur) ? 'selected' : '';
      return [`<option value="" ${noneSel}>(None)</option>`].concat(items.map(c => {
        const sel = (c === cur) ? 'selected' : '';
        return `<option value="${escapeAttr(c)}" ${sel}>${escapeHtml(c)}</option>`;
      })).join('');
    }

    function setCuisineSelect_(value){
      const el = document.getElementById('rCuisine');
      if (!el) return;
      el.innerHTML = cuisineOptionsHtml_(value);
      el.value = String(value || '').trim();
    }

    function renderShop_(groups){
      SHOP.groups = Array.isArray(groups) ? groups : [];
      const out = document.getElementById('shopOut');
      if (!SHOP.groups.length) {
        out.innerHTML = `<div class="muted">No items. Plan meals first.</div>`;
        return;
      }
      
      // Load bought status from localStorage
      let boughtItems = {};
      try {
        const saved = localStorage.getItem('foodieShoppingBought');
        if (saved) boughtItems = JSON.parse(saved);
      } catch (_) {}
      
      // Count total items
      const totalItems = SHOP.groups.reduce((sum, g) => sum + g.Items.length, 0);
      const boughtCount = Object.values(boughtItems).filter(Boolean).length;
      
      // Add summary at the top
      out.innerHTML = `
        <div style="background:rgba(77,163,255,0.1); border:1px solid rgba(77,163,255,0.3); border-radius:10px; padding:12px; margin-bottom:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <span style="font-weight:600;">üìù Shopping Summary</span>
            <span>${totalItems} item${totalItems !== 1 ? 's' : ''} across ${SHOP.groups.length} store${SHOP.groups.length !== 1 ? 's' : ''}</span>
          </div>
          <div style="margin-top:6px; font-size:13px; color:var(--muted);">
            ‚úì Purchased: ${boughtCount} / ${totalItems} items
          </div>
        </div>
      ` + SHOP.groups.map(g => {
        const storeName = getStoreNameById(g.StoreId) || (g.StoreId === 'unassigned' ? 'Unassigned' : g.StoreId);
        const isUnassigned = (g.StoreId === 'unassigned');

        // Group items by category (normalize to Title Case for display)
        const categoriesMap = {};
        const allCategories = new Set();
        
        // Helper to normalize category to Title Case
        const normalizeCategory = (cat) => {
          if (!cat || !cat.trim()) return 'Other';
          return String(cat).trim().charAt(0).toUpperCase() + String(cat).trim().slice(1).toLowerCase();
        };

        g.Items.forEach(item => {
          const cat = normalizeCategory(item.Category);
          allCategories.add(cat);
          if (!categoriesMap[cat]) categoriesMap[cat] = [];
          categoriesMap[cat].push(item);
        });

        // Sort categories: use META.categories order, put unknown categories at the end
        // Create lowercase set for case-insensitive matching
        const metaCategoriesLower = new Set((META.categories || []).map(c => String(c || '').toLowerCase()));
        const sortedCategories = (META.categories || []).filter(c => c && allCategories.has(c));
        const unknownCategories = [...allCategories].filter(c => !metaCategoriesLower.has(String(c || '').toLowerCase())).sort();
        const finalCategories = [...sortedCategories, ...unknownCategories];

        const categoriesHtml = finalCategories.map(cat => {
          const catItems = categoriesMap[cat] || [];
          return `
            <div style="margin-top: 12px;">
              <div style="font-size: 13px; font-weight: 600; color: var(--accent); padding: 6px 0; border-bottom: 1px solid var(--line); margin-bottom: 8px;">
                ${escapeHtml(cat || 'Other')}
              </div>
              <div style="display:flex; flex-direction:column; gap:8px;">
                ${catItems.map(it => {
                  const storeIdForItem = (g.StoreId === 'unassigned') ? '' : g.StoreId;
                  const itemKey = `${it.IngredientNorm}_${it.Unit || ''}`;
                  const isBought = boughtItems[itemKey] || false;
                  const itemStyle = isBought ? 'opacity:0.5; text-decoration:line-through;' : '';
                  return `
                    <div class="item" style="padding:10px; ${itemStyle}">
                      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
                        <div style="display:flex; align-items:center; gap:10px;">
                          <input type="checkbox" 
                                 data-action="shop-item-toggle" 
                                 data-itemkey="${escapeAttr(itemKey)}"
                                 ${isBought ? 'checked' : ''}
                                 style="width:18px; height:18px; cursor:pointer;">
                          <div>
                            <div><strong>${escapeHtml(normalizeShopTitle_(it.IngredientNorm))}</strong> <span class="muted">x${escapeHtml(it.Count)}</span></div>
                            <div class="muted">${(it.Examples||[]).map(x => escapeHtml(x)).join(' ‚Ä¢ ')}</div>
                            <div class="muted">Qty: ${escapeHtml(shopQtyDisplay_(it) || '')} ${escapeHtml(it.Unit || '')}</div>
                          </div>
                        </div>
                        <div style="min-width:220px;">
                          <label style="margin:0 0 6px 0;">Store</label>
                          <select data-action="shop-item-store" data-ingredient="${escapeAttr(it.IngredientNorm)}" data-unit="${escapeAttr(it.Unit||'')}" data-storeid="${escapeAttr(storeIdForItem)}">
                            ${storeOptionsHtml_(storeIdForItem)}
                          </select>
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }).join('');

        return `
          <details open class="item" style="padding:10px;">
            <summary style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
              <span>${escapeHtml(storeName)} (${g.Items.length})</span>
              <span class="actions" style="margin-left:auto;">
                <button class="ghost" data-action="shop-print-store" data-storeid="${escapeAttr(g.StoreId)}">Print</button>
              </span>
            </summary>
            <div style="margin-top:10px;">
              ${categoriesHtml}
              ${isUnassigned ? `<div class="muted" style="margin-top: 12px;">Unassigned items must be assigned a store before printing a complete by-store list.</div>` : ``}
            </div>
          </details>
        `;
      }).join('');
    }

    function persistShop_(){
      try {
        localStorage.setItem('foodieShoppingLast', JSON.stringify({ start: SHOP.start, end: SHOP.end, groups: SHOP.groups }));
      } catch (_) {}
    }
    function loadPersistedShop_(){
      try {
        const raw = localStorage.getItem('foodieShoppingLast');
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (obj && Array.isArray(obj.groups)) {
          SHOP.start = String(obj.start || '');
          SHOP.end = String(obj.end || '');
          renderShop_(obj.groups);
        }
      } catch (_) {}
    }

    async function buildShop(){
      const start = document.getElementById('shopStart').value;
      const end = document.getElementById('shopEnd').value;
      if (!start || !end) {
        document.getElementById('shopOut').innerHTML = `<div class="muted">Please select start and end dates.</div>`;
        return;
      }
      SHOP.start = start;
      SHOP.end = end;

      const out = document.getElementById('shopOut');
      out.innerHTML = `<div class="muted">Generating...</div>`;
      const includeLowStock = document.getElementById('shopIncludeLowStock').checked;
      
      // Build main shopping list from date range
      const res = await api('buildShoppingList', { start, end, excludeLeftovers: true, includeLowStock });
      if (!res.ok) { 
        out.innerHTML = `<div class="muted">Error: ${escapeHtml(res.error||'')}</div>`; 
        return; 
      }
      
      let groups = res.groups || [];
      
      // Check if collections should be included
      const includeCollections = document.getElementById('shopIncludeCollections').checked;
      if (includeCollections) {
        const selectedCollections = getSelectedCollections();
        
        if (selectedCollections.length > 0) {
          // Get existing recipe IDs from the main shopping list to avoid duplicates
          const existingRecipeIds = new Set();
          for (const group of groups) {
            for (const item of group.Items || []) {
              for (const ex of item.Examples || []) {
                // Extract recipe ID from examples if available (not implemented in current schema)
                // For now, we'll deduplicate by ingredient name
              }
            }
          }
          
          // Aggregate ingredients from selected collections
          for (const collectionId of selectedCollections) {
            const collRes = await api('listCollectionRecipes', { collectionId });
            if (!collRes.ok || !collRes.recipes) continue;
            
            for (const recipe of collRes.recipes) {
              const ingRes = await api('listRecipeIngredients', { recipeId: recipe.RecipeId });
              if (!ingRes.ok || !ingRes.items) continue;
              
              // Merge ingredients into groups
              for (const ing of ingRes.items) {
                const storeId = ing.StoreId || '';
                const category = ing.Category || 'Other';
                const ingredientNorm = (ing.IngredientNorm || '').toLowerCase();
                const unit = (ing.Unit || '').toLowerCase();
                
                if (!ingredientNorm) continue;
                
                // Find or create store group
                let storeGroup = groups.find(g => g.StoreId === storeId);
                if (!storeGroup) {
                  storeGroup = {
                    StoreId: storeId,
                    StoreName: getStoreNameById(storeId) || storeId || 'No Store',
                    Items: []
                  };
                  groups.push(storeGroup);
                }
                
                // Find or create category bucket
                const key = `${ingredientNorm}|${unit}`;
                let bucket = storeGroup.Items.find(b => 
                  b.IngredientNorm.toLowerCase() === ingredientNorm && 
                  (b.Unit || '').toLowerCase() === unit
                );
                
                if (!bucket) {
                  bucket = {
                    Category: category,
                    IngredientNorm: ingredientNorm,
                    Unit: ing.Unit || '',
                    QtyNum: 0,
                    QtyText: '',
                    Examples: []
                  };
                  storeGroup.Items.push(bucket);
                }
                
                // Aggregate quantity
                if (ing.QtyNum && Number.isFinite(Number(ing.QtyNum))) {
                  bucket.QtyNum += Number(ing.QtyNum);
                }
                
                // Add example
                const example = ing.IngredientRaw || `${ing.QtyText || ''} ${ing.Unit || ''} ${ingredientNorm}`.trim();
                if (example && bucket.Examples.length < 3 && !bucket.Examples.includes(example)) {
                  bucket.Examples.push(example);
                }
              }
            }
          }
        }
      }

      renderShop_(groups);
      persistShop_();
    }
    
    function getSelectedCollections() {
      const select = document.getElementById('shopCollectionSelect');
      const selected = [];
      for (const option of select.options) {
        if (option.selected) {
          selected.push(option.value);
        }
      }
      return selected;
    }
    
    function populateShoppingCollectionsDropdown() {
      const select = document.getElementById('shopCollectionSelect');
      select.innerHTML = COLLECTIONS.map(c => 
        `<option value="${escapeAttr(c.CollectionId)}">${escapeHtml(c.Name)}</option>`
      ).join('');
    }
    
    // Generate shopping list from a recipe collection
    async function generateCollectionShoppingList(collectionId) {
      console.log('[generateCollectionShoppingList] CollectionId:', collectionId);
      console.log('[generateCollectionShoppingList] COLLECTIONS:', COLLECTIONS);
      
      // Reload collections to ensure we have the latest data
      await loadCollections();
      
      // Convert to number for comparison (dataset values are strings)
      const cid = Number(collectionId);
      const collection = COLLECTIONS.find(c => Number(c.CollectionId) === cid);
      console.log('[generateCollectionShoppingList] Found collection:', collection);
      
      if (!collection) {
        alert(`Collection not found. ID: ${collectionId}`);
        return;
      }
      
      // Get all recipes in the collection
      const res = await api('listCollectionRecipes', { collectionId });
      if (!res.ok || !res.recipes || res.recipes.length === 0) {
        alert(`No recipes found in "${collection.Name}"`);
        return;
      }
      
      const recipes = res.recipes;
      
      // Aggregate ingredients from all recipes in the collection
      const ingredientMap = new Map(); // key: ingredientNorm, value: { items: [...], qtyNum total, unit }
      
      for (const recipe of recipes) {
        // Get ingredients for this recipe
        const ingRes = await api('listRecipeIngredients', { recipeId: recipe.RecipeId });
        if (!ingRes.ok || !ingRes.items) continue;
        
        for (const item of ingRes.items) {
          const norm = (item.IngredientNorm || '').toLowerCase().trim();
          if (!norm) continue;
          
          const key = norm;
          if (!ingredientMap.has(key)) {
            ingredientMap.set(key, {
              IngredientNorm: norm,
              IngredientRaw: item.IngredientRaw || norm,
              items: [],
              totalQty: 0,
              unit: item.Unit || '',
              StoreId: item.StoreId || '',
              Category: item.Category || 'Other'
            });
          }
          
          const entry = ingredientMap.get(key);
          entry.items.push({
            recipe: recipe.Title,
            qty: item.QtyNum || 0,
            qtyText: item.QtyText || '',
            unit: item.Unit || ''
          });
          
          // Aggregate quantity
          if (item.QtyNum && Number(item.QtyNum) > 0) {
            entry.totalQty += Number(item.QtyNum);
          }
        }
      }
      
      // Convert to array and apply pantry depletion
      const allItems = Array.from(ingredientMap.values());
      
      // Apply pantry depletion (similar to buildShoppingList in backend)
      const pantryRes = await api('listPantry', {});
      const pantryItems = (pantryRes.ok && pantryRes.items) ? pantryRes.items : [];
      
      for (const item of allItems) {
        // Find matching pantry item
        const pantryItem = pantryItems.find(p => {
          const pName = (p.NameLower || p.Name || '').toLowerCase().trim();
          return pName === item.IngredientNorm;
        });
        
        if (pantryItem) {
          const pantryQty = Number(pantryItem.QtyNum || 0);
          if (pantryQty > 0 && item.totalQty > 0) {
            // Deduct pantry quantity
            const needed = Math.max(0, item.totalQty - pantryQty);
            item.totalQty = needed;
            item.pantryDeducted = pantryQty;
          }
        }
      }
      
      // Filter out items with zero quantity after pantry depletion
      const neededItems = allItems.filter(item => item.totalQty > 0 || !item.totalQty);
      
      // Group by store
      const groupsByStore = {};
      for (const item of neededItems) {
        const storeId = item.StoreId || 'unassigned';
        if (!groupsByStore[storeId]) {
          groupsByStore[storeId] = {
            StoreId: storeId,
            Items: []
          };
        }
        groupsByStore[storeId].Items.push({
          IngredientNorm: item.IngredientNorm,
          IngredientRaw: item.IngredientRaw,
          QtyNum: item.totalQty,
          QtyText: item.totalQty > 0 ? `${item.totalQty} ${item.unit}`.trim() : '',
          Unit: item.unit,
          Category: item.Category,
          recipes: item.items.map(i => i.recipe).join(', ')
        });
      }
      
      const groups = Object.values(groupsByStore);
      
      // Print the shopping list
      if (groups.length === 0) {
        alert(`All ingredients for "${collection.Name}" are already in your pantry!`);
        return;
      }
      
      // Format for printing (print all stores at once for collections)
      const allStoreItems = [];
      for (const group of groups) {
        const storeName = getStoreNameById(group.StoreId) || 'Unassigned';
        allStoreItems.push({ storeName, items: group.Items });
      }
      
      // Create a formatted list for printing
      let printContent = `Shopping List: ${collection.Name}\n`;
      printContent += `Generated: ${new Date().toLocaleDateString()}\n`;
      printContent += `Recipes: ${recipes.length}\n\n`;
      
      for (const store of allStoreItems) {
        printContent += `\n${store.storeName.toUpperCase()}\n`;
        printContent += '='.repeat(40) + '\n';
        
        // Group by category
        const byCategory = {};
        for (const item of store.items) {
          const cat = item.Category || 'Other';
          if (!byCategory[cat]) byCategory[cat] = [];
          byCategory[cat].push(item);
        }
        
        for (const [category, items] of Object.entries(byCategory)) {
          printContent += `\n${category}:\n`;
          for (const item of items) {
            const qty = item.QtyText || (item.QtyNum ? `${item.QtyNum} ${item.Unit}`.trim() : '');
            printContent += `  [ ] ${item.IngredientRaw}${qty ? ` - ${qty}` : ''}\n`;
          }
        }
      }
      
      // Use the existing print function
      const items = groups.flatMap(g => g.Items).map(it => ({
        IngredientNorm: it.IngredientNorm,
        QtyDisplay: it.QtyText || (it.QtyNum ? `${it.QtyNum} ${it.Unit}`.trim() : ''),
        QtyText: it.QtyText,
        Unit: it.Unit,
        Category: it.Category
      }));
      
      // Show preview before printing
      showShoppingListPreview(`${collection.Name} Collection`, items, groups);
    }

    // Shopping List Preview
    let SHOPPING_LIST_PREVIEW_DATA = { title: '', items: [], groups: [] };

    function showShoppingListPreview(title, items, groups) {
      SHOPPING_LIST_PREVIEW_DATA = { title, items, groups };
      
      document.getElementById('shoppingListPreviewSubtitle').textContent = title;
      
      // Build preview HTML
      const content = document.getElementById('shoppingListPreviewContent');
      let html = `<div style="font-size: 14px; line-height: 1.6;">`;
      html += `<div style="font-weight: 700; font-size: 16px; margin-bottom: 12px;">${escapeHtml(title)}</div>`;
      html += `<div style="color: var(--muted); margin-bottom: 20px;">Generated: ${new Date().toLocaleDateString()}</div>`;
      
      if (groups && groups.length > 0) {
        for (const group of groups) {
          const storeName = getStoreNameById(group.StoreId) || 'Unassigned';
          html += `<div style="margin-bottom: 24px;">`;
          html += `<div style="font-weight: 700; font-size: 15px; margin-bottom: 8px; color: var(--accent);">${escapeHtml(storeName)}</div>`;
          
          // Group by category
          const byCategory = {};
          for (const item of group.Items) {
            const cat = item.Category || 'Other';
            if (!byCategory[cat]) byCategory[cat] = [];
            byCategory[cat].push(item);
          }
          
          for (const [category, catItems] of Object.entries(byCategory)) {
            html += `<div style="margin-left: 12px; margin-bottom: 12px;">`;
            html += `<div style="font-weight: 600; font-size: 13px; margin-bottom: 6px; color: var(--text);">${escapeHtml(category)}</div>`;
            html += `<div style="margin-left: 12px;">`;
            for (const item of catItems) {
              const qty = item.QtyText || (item.QtyNum ? `${item.QtyNum} ${item.Unit}`.trim() : '');
              html += `<div style="margin-bottom: 4px;">‚òê ${escapeHtml(item.IngredientRaw || item.IngredientNorm)}${qty ? ` ‚Äî ${escapeHtml(qty)}` : ''}</div>`;
            }
            html += `</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
      } else {
        // Flat list (no groups)
        html += `<div style="margin-left: 12px;">`;
        for (const item of items) {
          html += `<div style="margin-bottom: 4px;">‚òê ${escapeHtml(item.IngredientNorm)} ‚Äî ${escapeHtml(item.QtyDisplay)}</div>`;
        }
        html += `</div>`;
      }
      
      html += `</div>`;
      content.innerHTML = html;
      
      document.getElementById('shoppingListPreviewBack').style.display = 'flex';
    }

    async function confirmPrintShoppingList() {
      const { title, items } = SHOPPING_LIST_PREVIEW_DATA;
      document.getElementById('shoppingListPreviewBack').style.display = 'none';
      await window.Foodie.printShopping(title, items);
    }

    function clearShopUi() {
      SHOP.groups = [];
      SHOP.start = '';
      SHOP.end = '';
      document.getElementById('shopOut').innerHTML = `<div class="muted">List cleared.</div>`;
      persistShop_();
    }

    document.addEventListener('click', async (e) => {
      const ps = e.target.closest('[data-action="shop-print-store"]');
      if (ps) {
        const storeId = String(ps.dataset.storeid || '');
        if (storeId === 'unassigned') { alert('Please assign stores for unassigned items before printing.'); return; }
        const g = (SHOP.groups || []).find(x => String(x.StoreId) === storeId);
        if (!g) { alert('Nothing to print for this store.'); return; }
        const storeName = getStoreNameById(storeId) || storeId;
        const items = (g.Items||[]).map(it => ({
          IngredientNorm: it.IngredientNorm,
          QtyDisplay: shopQtyDisplay_(it),
          QtyText: it.QtyText,
          Unit: it.Unit
        }));
        await window.Foodie.printShopping(storeName, items);
        return;
      }
    });

    document.addEventListener('change', async (e) => {
      // Handle shopping item bought toggle
      const toggle = e.target.closest('[data-action="shop-item-toggle"]');
      if (toggle) {
        const itemKey = toggle.dataset.itemkey;
        const isChecked = toggle.checked;
        
        // Load current bought items
        let boughtItems = {};
        try {
          const saved = localStorage.getItem('foodieShoppingBought');
          if (saved) boughtItems = JSON.parse(saved);
        } catch (_) {}
        
        // Update bought status
        if (isChecked) {
          boughtItems[itemKey] = true;
        } else {
          delete boughtItems[itemKey];
        }
        
        // Save to localStorage
        try {
          localStorage.setItem('foodieShoppingBought', JSON.stringify(boughtItems));
        } catch (_) {}
        
        // Re-render to update counts and styling
        renderShop_(SHOP.groups);
        return;
      }
      
      // Handle store assignment
      const sel = e.target.closest('[data-action="shop-item-store"]');
      if (!sel) return;
      const ingredientNorm = String(sel.dataset.ingredient || '').trim();
      const unit = String(sel.dataset.unit || '').trim();
      const storeId = String(sel.value || '').trim();
      if (!SHOP.start || !SHOP.end) {
        alert('Please generate the shopping list first.');
        return;
      }
      const res = await api('assignShoppingItemStore', { start: SHOP.start, end: SHOP.end, ingredientNorm, unit, storeId });
      if (!res.ok) { alert(res.error||'Failed to assign store.'); return; }
      // Refresh grouping immediately
      await buildShop();
    });

    // ---------- pantry ----------
    async function checkExpiringItems() {
      const widget = document.getElementById('expiringItemsWidget');
      const listEl = document.getElementById('expiringItemsList');
      
      const today = new Date();
      const sevenDaysFromNow = new Date(today);
      sevenDaysFromNow.setDate(today.getDate() + 7);
      
      const res = await api('getExpiringPantryItems', { days: 7 });
      if (!res.ok || !res.items || res.items.length === 0) {
        widget.style.display = 'none';
        return;
      }
      
      const items = res.items;
      listEl.innerHTML = items.map(it => {
        const expDate = new Date(it.expiration_date);
        const daysUntil = Math.ceil((expDate - today) / (24 * 60 * 60 * 1000));
        const urgency = daysUntil <= 2 ? 'color: #d32f2f; font-weight: 700;' : '';
        return `<div style="padding: 4px 0;">
          <span style="${urgency}">${escapeHtml(it.Name)}</span> 
          <span class="muted">- expires in ${daysUntil} day${daysUntil !== 1 ? 's' : ''}</span>
        </div>`;
      }).join('');
      
      widget.style.display = '';
    }
    
    async function loadPantry(){
      const q = (document.getElementById('pantrySearch').value || '').trim().toLowerCase();
      const filter = document.getElementById('pantryFilter').value || 'all';
      
      const res = await api('listPantry', { q });
      const box = document.getElementById('pantryList');
      if (!res.ok) { box.innerHTML = `<div class="muted">Error: ${escapeHtml(res.error||'')}</div>`; return; }
      let items = res.items || [];
      
      window.__pantryItemsById = Object.create(null);
      for (const it of items) { if (it && it.ItemId) window.__pantryItemsById[it.ItemId] = it; }
      
      // Check for expiring items (next 7 days)
      await checkExpiringItems();
      
      // Helper: check if item is low stock
      const isLowStock = (it) => {
        const qty = (it.QtyNum !== null && it.QtyNum !== undefined && String(it.QtyNum) !== '') ? Number(it.QtyNum) : null;
        const threshold = (it.low_stock_threshold !== null && it.low_stock_threshold !== undefined && String(it.low_stock_threshold) !== '') ? Number(it.low_stock_threshold) : null;
        return qty !== null && threshold !== null && Number.isFinite(qty) && Number.isFinite(threshold) && qty <= threshold;
      };
      
      // Apply filter
      if (filter === 'low') {
        items = items.filter(isLowStock);
      }
      
      box.innerHTML = items.length ? items.map(it => {
        const lowStock = isLowStock(it);
        const itemStyle = lowStock ? 'background: #fff8e1; border-left: 4px solid #ff9800; padding-left: 8px;' : '';
        const qtyDisplay = (it.QtyNum!==null && it.QtyNum!==undefined && String(it.QtyNum)!=='' ? (String(it.QtyNum) + (it.Unit?(' '+it.Unit):'')) : (it.QtyText||''));
        const qtyStyle = lowStock ? 'color: #e65100; font-weight: 700;' : '';
        const nameColor = lowStock ? '#000' : 'inherit';
        const mutedColor = lowStock ? '#666' : 'inherit';
        
        return `
        <div class="item" style="${itemStyle}">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div style="flex:1;">
              <div>
                ${lowStock ? '<span style="color: #ff6f00; font-weight: 700; margin-right: 6px; background: #ffe0b2; padding: 2px 6px; border-radius: 3px; font-size: 0.75em;">‚ö†Ô∏è LOW</span>' : ''}
                <strong style="color: ${nameColor};">${escapeHtml(it.Name)}</strong> 
                <span style="${qtyStyle}">${escapeHtml(qtyDisplay)}</span>
              </div>
              ${it.Category ? `<div class="muted" style="color: ${mutedColor};">Category: ${escapeHtml(it.Category)}</div>` : ''}
              <div class="muted" style="color: ${mutedColor};">${escapeHtml(getStoreNameById(it.StoreId)||it.StoreId||'')}</div>
              ${it.low_stock_threshold ? `<div class="muted" style="color: ${mutedColor};">Low stock threshold: ${escapeHtml(String(it.low_stock_threshold))} ${escapeHtml(it.Unit||'')}</div>` : ''}
              <div class="muted" style="color: ${mutedColor};">${escapeHtml(it.Notes||'')}</div>
            </div>
            <div class="actions">
              <button class="ghost" data-action="pantry-edit" data-id="${escapeAttr(it.ItemId)}" ${lowStock ? 'style="color: #000;"' : ''}>Edit</button>
              <button class="danger" data-action="pantry-del" data-id="${escapeAttr(it.ItemId)}" ${lowStock ? 'style="color: #d32f2f;"' : ''}>Delete</button>
            </div>
          </div>
        </div>
      `;
      }).join('') : `<div class="muted">${filter === 'low' ? 'No low stock items.' : 'No pantry items.'}</div>`;
    }

    
    // ---------- calendar ----------
    async function calSync(){
      const start = (PLAN && PLAN.start) ? PLAN.start : document.getElementById('planStart').value;
      const days = (PLAN && PLAN.days) ? Number(PLAN.days||14) : Number(document.getElementById('planDays').value || 14);
      if (!start) { document.getElementById('calStatus').textContent = 'Select a plan start date first.'; return; }
      const end = addDays(start, days-1);
      const calNameEl = document.getElementById('calId');
      const calName = (calNameEl && calNameEl.value ? calNameEl.value : 'Foodie Meal Planner').trim() || 'Foodie Meal Planner';

      document.getElementById('calStatus').textContent = 'Syncing...';
      const res = await api('calendarSyncRange', { start, end, calendarName: calName });
      if (!res.ok) { document.getElementById('calStatus').textContent = `Error: ${res.error||''}`; return; }
      document.getElementById('calStatus').textContent = `Synced. Created: ${res.created||0}, Updated: ${res.updated||0}`;
    }


    // ---------- bindings ----------
    function fillJumpLetters(){
      const sel = document.getElementById('jumpLetter');
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      sel.innerHTML = `<option value="">Jump A‚ÄìZ</option>` + letters.map(l => `<option value="${l.toLowerCase()}">${l}</option>`).join('');
    }

    function collapseExpandAll(containerId, open){
      const box = document.getElementById(containerId);
      box.querySelectorAll('details').forEach(d => d.open = !!open);
    }

    // ========== PHASE 3 HELPER FUNCTIONS ==========

    function renderPlanGrid() {
      console.log('[renderPlanGrid] Called. PLAN.start:', PLAN.start, 'PLAN.days:', PLAN.days);
      const container = document.getElementById('planGrid');
      if (!container) {
        console.error('[renderPlanGrid] Container #planGrid not found!');
        return;
      }
      if (!PLAN.start) {
        console.log('[renderPlanGrid] No PLAN.start, showing placeholder');
        container.innerHTML = '<div class="muted">Load a plan range first</div>';
        return;
      }

      // Show all days in the range (remove the 7-day limit)
      const days = PLAN.days;
      console.log('[renderPlanGrid] Rendering', days, 'days starting from', PLAN.start);
      let html = '<div class="calendar-grid">';

      for (let i = 0; i < days; i++) {
        const dateKey = addDays(PLAN.start, i);
        const plan = PLAN.plansByDate[dateKey] || {};
        const dt = new Date(dateKey);
        const dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dt.getDay()];

        html += `<div class="grid-day">`;
        html += `<div class="grid-day-header">${dayName} ${dateKey}</div>`;

        for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
          const meal = plan[slot];
          if (meal && meal.Title) {
            // Look up recipe to get cuisine
            const recipe = RECIPES.find(r => r.RecipeId === meal.RecipeId);
            const cuisine = recipe ? recipe.Cuisine : '';
            const cuisineClass = cuisine ? `cuisine-${cuisine.toLowerCase().replace(/\s+/g, '-')}` : '';
            const slotClass = slot.toLowerCase();
            html += `
              <div class="grid-meal ${slotClass} ${cuisineClass}" 
                   draggable="true"
                   data-date="${dateKey}" 
                   data-slot="${slot}"
                   data-rid="${escapeAttr(meal.RecipeId || '')}"
                   data-title="${escapeAttr(meal.Title)}">
                <div class="grid-meal-label">${slot.charAt(0)}</div>
                <div class="grid-meal-title">${escapeHtml(meal.Title)}</div>
              </div>
            `;
          } else {
            html += `
              <div class="grid-empty-slot" 
                   data-date="${dateKey}" 
                   data-slot="${slot}"
                   data-action="pick-meal">
                + ${slot}
              </div>
            `;
          }
        }

        html += `</div>`;
      }

      html += '</div>';
      container.innerHTML = html;

      // Load additional items count for each meal slot
      setTimeout(async () => {
        for (let i = 0; i < days; i++) {
          const dateKey = addDays(PLAN.start, i);
          const plan = PLAN.plansByDate[dateKey] || {};

          for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
            const meal = plan[slot];
            if (meal && meal.Title) {
              const result = await api('getAdditionalItems', { date: dateKey, slot });
              if (result.ok && result.items && result.items.length > 0) {
                const mealEl = container.querySelector(`.grid-meal[data-date="${dateKey}"][data-slot="${slot}"]`);
                if (mealEl) {
                  mealEl.dataset.hasAdditional = 'true';
                  mealEl.dataset.additionalCount = result.items.length;
                  
                  // Add badge and expand button
                  const badge = document.createElement('div');
                  badge.className = 'grid-additional-badge';
                  badge.textContent = `+${result.items.length}`;
                  mealEl.appendChild(badge);
                  
                  const expandBtn = document.createElement('button');
                  expandBtn.className = 'grid-expand-btn';
                  expandBtn.innerHTML = '<span class="expand-icon">‚åÑ</span>';
                  expandBtn.title = 'Show additional items';
                  expandBtn.dataset.date = dateKey;
                  expandBtn.dataset.slot = slot;
                  mealEl.appendChild(expandBtn);
                }
              }
            }
          }
        }
      }, 0);

      setupGridDragAndDrop();
    }

    function setupGridDragAndDrop() {
      const meals = document.querySelectorAll('.grid-meal');
      const slots = document.querySelectorAll('.grid-meal, .grid-empty-slot');

      meals.forEach(meal => {
        meal.addEventListener('dragstart', (e) => {
          meal.classList.add('dragging');
          DRAG_SOURCE = {
            date: meal.dataset.date,
            slot: meal.dataset.slot,
            recipeId: meal.dataset.rid,
            title: meal.dataset.title
          };
          e.dataTransfer.effectAllowed = 'move';
        });

        meal.addEventListener('dragend', () => {
          meal.classList.remove('dragging');
          DRAG_SOURCE = null;
        });
      });

      slots.forEach(slot => {
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          slot.classList.add('drag-over');
        });

        slot.addEventListener('dragleave', () => {
          slot.classList.remove('drag-over');
        });

        slot.addEventListener('drop', async (e) => {
          e.preventDefault();
          slot.classList.remove('drag-over');

          if (!DRAG_SOURCE) return;

          const targetDate = slot.dataset.date;
          const targetSlot = slot.dataset.slot;

          if (DRAG_SOURCE.date === targetDate && DRAG_SOURCE.slot === targetSlot) return;

          const res = await api('swapPlanMeals', {
            date1: DRAG_SOURCE.date,
            slot1: DRAG_SOURCE.slot,
            date2: targetDate,
            slot2: targetSlot
          });

          if (res.ok) {
            await loadPlansIntoUi(PLAN.start, PLAN.days);
            if (PLAN.viewMode === 'grid') renderPlanGrid();
          }
        });
      });

      document.querySelectorAll('[data-action="pick-meal"]').forEach(el => {
        el.addEventListener('click', () => {
          openMealPicker(el.dataset.date, el.dataset.slot);
        });
      });
    }

    function openLeftoverPicker() {
      if (!MP.open || !MP.date) return;

      const targetDate = new Date(MP.date);
      const meals = [];

      for (let i = 1; i <= 3; i++) {
        const pastDate = ymd(new Date(targetDate.getTime() - i * 24 * 60 * 60 * 1000));
        const plan = PLAN.plansByDate[pastDate];
        if (plan) {
          ['Dinner', 'Lunch', 'Breakfast'].forEach(slot => {
            if (plan[slot] && plan[slot].Title) {
              meals.push({
                date: pastDate,
                slot,
                title: plan[slot].Title
              });
            }
          });
        }
      }

      const container = document.getElementById('leftoverList');
      if (!meals.length) {
        container.innerHTML = '<div class="muted">No meals found in past 3 days</div>';
      } else {
        container.innerHTML = meals.map(m => `
          <div class="item" data-action="pick-leftover" 
               data-title="${escapeAttr(m.title)}"
               data-fromdate="${escapeAttr(m.date)}"
               data-fromslot="${escapeAttr(m.slot)}"
               style="cursor:pointer;">
            <strong>${escapeHtml(m.title)}</strong>
            <div class="muted">${m.date} ${m.slot}</div>
          </div>
        `).join('');
      }

      document.getElementById('leftoverPickerBack').style.display = 'flex';
    }

    // Collection Recipe Picker for Meal Planner
    function openCollectionRecipePicker() {
      if (!MP.open || !MP.date) return;

      // Populate collection dropdown
      const select = document.getElementById('collectionRecipePickerSelect');
      select.innerHTML = '<option value="">-- Choose a collection --</option>' +
        COLLECTIONS.map(c => `<option value="${escapeAttr(c.CollectionId)}">${escapeHtml(c.Name)}</option>`).join('');

      // Clear recipe list
      document.getElementById('collectionRecipePickerList').innerHTML = '<div class="muted">Select a collection to view recipes</div>';

      document.getElementById('collectionRecipePickerBack').style.display = 'flex';
    }

    async function loadCollectionRecipesForPicker(collectionId) {
      const container = document.getElementById('collectionRecipePickerList');
      
      if (!collectionId) {
        container.innerHTML = '<div class="muted">Select a collection to view recipes</div>';
        return;
      }

      container.innerHTML = '<div class="muted">Loading...</div>';

      const res = await api('listCollectionRecipes', { collectionId });
      if (!res.ok || !res.recipes || res.recipes.length === 0) {
        container.innerHTML = '<div class="muted">No recipes in this collection</div>';
        return;
      }

      const recipes = res.recipes;
      container.innerHTML = recipes.map(r => `
        <div class="item" data-action="pick-collection-recipe" 
             data-rid="${escapeAttr(r.RecipeId)}"
             data-title="${escapeAttr(r.Title)}"
             style="cursor:pointer;">
          <strong>${escapeHtml(r.Title)}</strong>
          <div class="muted">${escapeHtml(r.MealType || 'Any')} ‚Ä¢ ${escapeHtml(r.Cuisine || '')}</div>
        </div>
      `).join('');
    }

    async function loadCollections() {
      const res = await api('listCollections', {});
      if (res.ok) {
        COLLECTIONS = res.collections || [];
        renderCollections();
        updateCollectionFilter();
      }
    }

    function renderCollections() {
      const container = document.getElementById('collectionsList');
      if (!COLLECTIONS.length) {
        container.innerHTML = '<div class="muted">No collections yet. Create one above!</div>';
        return;
      }

      container.innerHTML = COLLECTIONS.map(c => `
        <div class="item">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:start;">
            <div style="flex:1;">
              <strong>${escapeHtml(c.Name)}</strong>
              ${c.Description ? `<div class="muted">${escapeHtml(c.Description)}</div>` : ''}
            </div>
            <div class="actions">
              <button class="ghost" data-action="edit-collection" data-cid="${escapeAttr(c.CollectionId)}">Edit</button>
              <button class="ghost" data-action="assign-recipes" data-cid="${escapeAttr(c.CollectionId)}">Assign Recipes</button>
              <button class="primary" data-action="assign-collection-to-planner" data-cid="${escapeAttr(c.CollectionId)}" data-cname="${escapeAttr(c.Name)}" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üìÖ Assign to Meal Plan</button>
              <button class="primary" data-action="collection-shopping-list" data-cid="${escapeAttr(c.CollectionId)}" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üõí Shopping List</button>
            </div>
          </div>
        </div>
      `).join('');
    }

    function updateCollectionFilter() {
      const filter = document.getElementById('collectionFilter');
      filter.innerHTML = '<option value="">All Recipes</option>' +
        COLLECTIONS.map(c => `<option value="${escapeAttr(c.CollectionId)}">${escapeHtml(c.Name)}</option>`).join('');
    }

    async function loadCollectionRecipes(collectionId) {
      CURRENT_COLLECTION_ID = collectionId;
      const res = await api('listCollectionRecipes', { collectionId });
      if (res.ok) {
        COLLECTION_RECIPES = res.recipes || [];
        renderCollectionRecipes();
      }
    }

    /**
     * Updates planner entries when a collection's main dish changes
     * Finds all meal slots that contain recipes from this collection and reassigns
     */
    async function updatePlannerForCollection(collectionId) {
      if (!collectionId) return;
      
      // Get all recipes in this collection
      const collectionRes = await api('listCollectionRecipes', { collectionId });
      if (!collectionRes.ok || !collectionRes.recipes) return;
      
      const recipeIds = collectionRes.recipes.map(r => r.RecipeId);
      if (recipeIds.length === 0) return;
      
      // Get current plan view dates
      const start = PLAN.start || ymd(new Date());
      const days = PLAN.days || 7;
      
      // Load plans for current view
      const plansRes = await api('listPlans', { start, days });
      if (!plansRes.ok || !plansRes.plans) return;
      
      // Find dates/slots that have any recipe from this collection
      const slotsToUpdate = [];
      for (const plan of plansRes.plans) {
        for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
          const meal = plan[slot];
          if (meal && meal.RecipeId && recipeIds.includes(meal.RecipeId)) {
            slotsToUpdate.push({ date: plan.Date, slot });
          }
        }
      }
      
      // Reassign each collection to update with new main dish
      for (const { date, slot } of slotsToUpdate) {
        await api('assignCollectionToSlot', {
          date,
          slot,
          collectionId
        });
      }
      
      // Reload planner view if any updates were made
      if (slotsToUpdate.length > 0) {
        await loadPlansIntoUi(start, days);
      }
    }

    function renderCollectionRecipes() {
      const container = document.getElementById('collectionRecipesList');
      const collection = COLLECTIONS.find(c => c.CollectionId === CURRENT_COLLECTION_ID);
      
      document.getElementById('collectionRecipesSubtitle').textContent = 
        collection ? `Recipes in "${collection.Name}"` : 'Select a collection';

      if (!COLLECTION_RECIPES.length) {
        container.innerHTML = '<div class="muted">No recipes in this collection</div>';
        return;
      }

      container.innerHTML = COLLECTION_RECIPES.map(r => `
        <div class="item">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:start;">
            <div style="display:flex; align-items:center; gap:12px; flex:1;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; user-select:none;">
                <input type="checkbox" 
                       ${r.is_main_dish ? 'checked' : ''} 
                       data-action="toggle-main-dish" 
                       data-rid="${escapeAttr(r.RecipeId)}"
                       style="width:18px; height:18px; cursor:pointer;">
                <span style="font-size:13px; color:#6b7280;">Main Dish</span>
              </label>
              <div style="flex:1;">
                <strong>${escapeHtml(r.Title)}</strong>
                <div class="muted">${escapeHtml(r.MealType || 'Any')} ‚Ä¢ ${escapeHtml(r.Cuisine || '')}</div>
              </div>
            </div>
            <div class="actions">
              <button class="ghost" data-action="recipe-view" data-rid="${escapeAttr(r.RecipeId)}">View</button>
              <button class="primary" data-action="assign-to-planner" data-rid="${escapeAttr(r.RecipeId)}" data-title="${escapeAttr(r.Title)}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üìÖ Assign to Planner</button>
              <button class="danger" data-action="remove-from-collection" data-rid="${escapeAttr(r.RecipeId)}">Remove</button>
            </div>
          </div>
        </div>
      `).join('');
    }

    function openCollectionModal(collection) {
      if (collection) {
        CURRENT_COLLECTION_ID = collection.CollectionId;
        document.getElementById('collectionModalTitle').textContent = 'Edit Collection';
        document.getElementById('collectionName').value = collection.Name || '';
        document.getElementById('collectionDescription').value = collection.Description || '';
        document.getElementById('btnDeleteCollection').style.display = '';
      } else {
        CURRENT_COLLECTION_ID = '';
        document.getElementById('collectionModalTitle').textContent = 'Create Collection';
        document.getElementById('collectionName').value = '';
        document.getElementById('collectionDescription').value = '';
        document.getElementById('btnDeleteCollection').style.display = 'none';
      }

      document.getElementById('collectionModalStatus').textContent = '';
      document.getElementById('collectionModalBack').style.display = 'flex';
    }

    // Assign to Planner Modal
    let ASSIGN_TO_PLANNER_STATE = { recipeId: '', title: '' };

    function openAssignToPlannerModal(recipeId, title) {
      ASSIGN_TO_PLANNER_STATE = { recipeId, title };
      
      document.getElementById('assignToPlannerRecipeTitle').textContent = title;
      document.getElementById('assignToPlannerDate').value = ymd(new Date());
      document.getElementById('assignToPlannerSlot').value = 'Dinner';
      document.getElementById('assignToPlannerStatus').textContent = '';
      
      document.getElementById('assignToPlannerBack').style.display = 'flex';
    }

    async function confirmAssignToPlanner() {
      const { recipeId, title } = ASSIGN_TO_PLANNER_STATE;
      const date = document.getElementById('assignToPlannerDate').value;
      const slot = document.getElementById('assignToPlannerSlot').value;
      const status = document.getElementById('assignToPlannerStatus');

      if (!date) {
        status.textContent = 'Please select a date';
        return;
      }

      status.textContent = 'Assigning...';

      const res = await api('upsertPlanMeal', {
        date,
        slot,
        recipeId,
        title
      });

      if (res.ok) {
        status.textContent = 'Assigned successfully!';
        setTimeout(() => {
          document.getElementById('assignToPlannerBack').style.display = 'none';
          // If user is on planner tab, reload it
          if (PLAN.start && PLAN.days) {
            loadPlansIntoUi(PLAN.start, PLAN.days);
          }
        }, 1000);
      } else {
        status.textContent = res.error || 'Failed to assign';
      }
    }

    function openAssignRecipesModal() {
      const collection = COLLECTIONS.find(c => c.CollectionId === CURRENT_COLLECTION_ID);
      document.getElementById('assignRecipesModalSubtitle').textContent = 
        collection ? `Assigning to: ${collection.Name}` : '';
      
      document.getElementById('assignRecipesSearch').value = '';
      renderAssignRecipesList('');
      document.getElementById('assignRecipesModalBack').style.display = 'flex';
    }

    function renderAssignRecipesList(query) {
      const container = document.getElementById('assignRecipesList');
      const collectionRecipeIds = new Set((COLLECTION_RECIPES || []).map(r => r.RecipeId));
      
      let recipesToShow = RECIPES;
      if (query) {
        recipesToShow = RECIPES.filter(r => 
          (r.Title || '').toLowerCase().includes(query) ||
          (r.Cuisine || '').toLowerCase().includes(query)
        );
      }

      container.innerHTML = recipesToShow.map(r => {
        const inCollection = collectionRecipeIds.has(r.RecipeId);
        return `
          <div class="item">
            <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
              <div style="flex:1;">
                <strong>${escapeHtml(r.Title)}</strong>
                <div class="muted">${escapeHtml(r.MealType || 'Any')} ‚Ä¢ ${escapeHtml(r.Cuisine || '')}</div>
              </div>
              <button class="${inCollection ? 'danger' : 'ghost'}" 
                      data-action="toggle-recipe-in-collection"
                      data-rid="${escapeAttr(r.RecipeId)}"
                      data-incollection="${inCollection}">
                ${inCollection ? 'Remove' : 'Add'}
              </button>
            </div>
          </div>
        `;
      }).join('');
    }

    function populateBreakfastRecipeDropdown() {
      // This function now handles the searchable dropdown
      const searchInput = document.getElementById('autoFillBreakfastSearch');
      const dropdown = document.getElementById('autoFillBreakfastDropdown');
      const hiddenInput = document.getElementById('autoFillBreakfastRecipe');
      
      if (!searchInput || !dropdown || !hiddenInput) return;
      
      const breakfastRecipes = RECIPES.filter(r => 
        (r.MealType || '').toLowerCase().includes('breakfast') || 
        (r.MealType || '').toLowerCase() === 'any'
      );
      
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim().toLowerCase();
        
        if (!query) {
          dropdown.style.display = 'none';
          return;
        }
        
        const filtered = breakfastRecipes.filter(r =>
          (r.Title || '').toLowerCase().includes(query)
        );
        
        if (!filtered.length) {
          dropdown.innerHTML = '<div style="padding:8px; color:var(--muted);">No recipes found</div>';
          dropdown.style.display = 'block';
          return;
        }
        
        dropdown.innerHTML = filtered.map(r => `
          <div class="item" data-action="select-breakfast-recipe" data-rid="${escapeAttr(r.RecipeId)}" data-title="${escapeAttr(r.Title)}"
               style="cursor:pointer; padding:8px; border-bottom:1px solid var(--line);">
            ${escapeHtml(r.Title)}
          </div>
        `).join('');
        dropdown.style.display = 'block';
      });
      
      searchInput.addEventListener('blur', () => {
        setTimeout(() => {
          dropdown.style.display = 'none';
        }, 200);
      });
      
      searchInput.addEventListener('focus', (e) => {
        if (e.target.value.trim()) {
          e.target.dispatchEvent(new Event('input'));
        }
      });
      
      dropdown.addEventListener('click', (e) => {
        const select = e.target.closest('[data-action="select-breakfast-recipe"]');
        if (select) {
          hiddenInput.value = select.dataset.rid;
          searchInput.value = select.dataset.title;
          dropdown.style.display = 'none';
        }
      });
    }

    // ============ IMPORT RECIPE FROM URL ============
    function openImportRecipeModal() {
      const modal = document.getElementById('importRecipeModalBack');
      const urlInput = document.getElementById('importRecipeUrl');
      const preview = document.getElementById('importRecipePreview');
      const divider = document.getElementById('importPreviewDivider');
      const status = document.getElementById('importRecipeStatus');
      
      // Reset
      urlInput.value = '';
      preview.style.display = 'none';
      divider.style.display = 'none';
      status.textContent = '';
      
      // Populate cuisine dropdown with comprehensive list
      populateImportCuisineDropdown();
      
      modal.style.display = 'flex';
      
      // Focus the URL input after modal is visible
      setTimeout(() => {
        urlInput.focus();
      }, 100);
    }
    
    function closeImportRecipeModal() {
      document.getElementById('importRecipeModalBack').style.display = 'none';
    }
    
    async function fetchRecipeFromUrl() {
      const url = document.getElementById('importRecipeUrl').value.trim();
      const status = document.getElementById('importRecipeStatus');
      const preview = document.getElementById('importRecipePreview');
      const divider = document.getElementById('importPreviewDivider');
      
      if (!url) {
        status.textContent = 'Please enter a URL';
        return;
      }
      
      status.textContent = 'Fetching recipe...';
      
      const result = await api('importRecipeFromUrl', { url });
      
      if (!result.ok) {
        status.textContent = 'Error: ' + (result.error || 'Failed to import');
        preview.style.display = 'none';
        divider.style.display = 'none';
        return;
      }
      
      // Populate preview
      document.getElementById('importPreviewTitle').value = result.title || '';
      document.getElementById('importPreviewInstructions').value = result.instructions || '';
      
      // Handle ingredients: if already parsed objects, convert to text; if strings, join as-is
      const ingredientsDisplay = (result.ingredients || []).map(ing => {
        if (typeof ing === 'object' && ing.IngredientRaw) {
          return ing.IngredientRaw; // Already parsed, show original
        }
        return String(ing); // String format
      }).join('\n');
      document.getElementById('importPreviewIngredients').value = ingredientsDisplay;
      
      document.getElementById('importPreviewServings').value = result.servings || 4;
      document.getElementById('importPreviewCuisine').value = result.cuisine || '';
      document.getElementById('importPreviewMealType').value = result.mealType || 'Any';
      document.getElementById('importPreviewImageUrl').value = result.imageUrl || '';
      
      // Store parsed ingredients for later use
      window._importedIngredients = result.ingredients || [];
      
      preview.style.display = 'block';
      divider.style.display = 'block';
      status.textContent = `‚úì Found recipe: ${result.title || 'Untitled'}`;
    }
    
    async function saveImportedRecipe() {
      const title = document.getElementById('importPreviewTitle').value.trim();
      const instructions = document.getElementById('importPreviewInstructions').value.trim();
      const ingredientsText = document.getElementById('importPreviewIngredients').value.trim();
      const servings = parseInt(document.getElementById('importPreviewServings').value) || 4;
      const cuisine = document.getElementById('importPreviewCuisine').value;
      const mealType = document.getElementById('importPreviewMealType').value;
      const imageUrl = document.getElementById('importPreviewImageUrl').value.trim();
      const sourceUrl = document.getElementById('importRecipeUrl').value.trim();
      const saveStatus = document.getElementById('importSaveStatus');
      
      if (!title) {
        saveStatus.textContent = 'Title is required';
        return;
      }
      
      // Use pre-parsed ingredients if available, otherwise parse manually
      let items = [];
      if (window._importedIngredients && Array.isArray(window._importedIngredients) && window._importedIngredients.length > 0) {
        // Already parsed by backend
        items = window._importedIngredients.map(ing => {
          if (typeof ing === 'object') {
            return {
              IngredientRaw: ing.IngredientRaw || '',
              IngredientName: ing.IngredientName || '',
              IngredientNorm: ing.IngredientNorm || '',
              QtyNum: ing.QtyNum,
              QtyText: ing.QtyText || '',
              Unit: ing.Unit || '',
              Notes: ing.Notes || '',
              StoreId: ing.StoreId || '',
              Category: ing.Category || ''
            };
          }
          // Fallback for string format
          return {
            IngredientRaw: String(ing),
            IngredientName: String(ing),
            IngredientNorm: String(ing).toLowerCase(),
            QtyNum: null,
            QtyText: '',
            Unit: '',
            Notes: '',
            StoreId: '',
            Category: ''
          };
        });
      } else {
        // Manual parsing (fallback)
        const ingredientLines = ingredientsText.split('\n').filter(line => line.trim());
        items = ingredientLines.map(line => {
          return {
            IngredientRaw: line,
            IngredientName: line,
            IngredientNorm: line.toLowerCase(),
            QtyNum: null,
            QtyText: '',
            Unit: '',
            Notes: '',
            StoreId: '',
            Category: ''
          };
        });
      }
      
      saveStatus.textContent = 'Saving...';
      
      const recipe = {
        Title: title,
        URL: sourceUrl,
        Cuisine: cuisine,
        MealType: mealType,
        Instructions: instructions,
        Notes: `Imported from: ${sourceUrl}`,
        Image_Name: '',
        default_servings: servings
      };
      
      const result = await api('upsertRecipeWithIngredients', { recipe, items });
      
      if (result.ok) {
        saveStatus.textContent = '‚úì Recipe saved!';
        await resetAndLoadRecipes();
        setTimeout(() => {
          closeImportRecipeModal();
        }, 1000);
      } else {
        saveStatus.textContent = 'Error: ' + (result.error || 'Failed to save');
      }
    }

    // ============ SMART WEEKLY MEAL PLANNER ============
    
    const MEAL_PLANNER_PREFS_KEY = 'foodie_meal_planner_prefs';
    
    // Load preferences from localStorage
    function loadMealPlannerPrefs() {
      try {
        const saved = localStorage.getItem(MEAL_PLANNER_PREFS_KEY);
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (e) {
        console.error('Failed to load meal planner prefs:', e);
      }
      
      // Default preferences
      return {
        favoriteCuisines: ['Italian', 'Mexican', 'American'],
        avoidRepeat: true,
        usePantry: true,
        favoritesOnly: false,
        breakfastStyle: 'varied',
        avoidRecipeRepeat: false,
        recipeRepeatDays: 3,
        excludeBreakfast: false,
        excludeLunch: false,
        excludeDinner: false
      };
    }
    
    // Save preferences to localStorage
    function saveMealPlannerPrefs(prefs) {
      try {
        localStorage.setItem(MEAL_PLANNER_PREFS_KEY, JSON.stringify(prefs));
      } catch (e) {
        console.error('Failed to save meal planner prefs:', e);
      }
    }
    
    // Open preferences modal
    function openMealPlannerPrefs() {
      const modal = document.getElementById('mealPlannerPrefsBack');
      const prefs = loadMealPlannerPrefs();
      
      // Render cuisine checkboxes from comprehensive list
      renderCuisineCheckboxes();
      
      // Set other preferences
      document.getElementById('prefAvoidRepeat').checked = prefs.avoidRepeat;
      document.getElementById('prefUsePantry').checked = prefs.usePantry;
      document.getElementById('prefFavoritesOnly').checked = prefs.favoritesOnly;
      document.getElementById('prefBreakfastStyle').value = prefs.breakfastStyle;
      
      // Set recipe repeat preferences
      document.getElementById('prefAvoidRecipeRepeat').checked = prefs.avoidRecipeRepeat || false;
      document.getElementById('prefRecipeRepeatDays').value = prefs.recipeRepeatDays || 3;
      document.getElementById('prefExcludeBreakfast').checked = prefs.excludeBreakfast || false;
      document.getElementById('prefExcludeLunch').checked = prefs.excludeLunch || false;
      document.getElementById('prefExcludeDinner').checked = prefs.excludeDinner || false;
      
      // Show/hide recipe repeat options based on checkbox
      const recipeRepeatOptions = document.getElementById('recipeRepeatOptions');
      recipeRepeatOptions.style.display = prefs.avoidRecipeRepeat ? 'block' : 'none';
      
      modal.style.display = 'flex';
    }
    
    // Close preferences modal
    function closeMealPlannerPrefs() {
      document.getElementById('mealPlannerPrefsBack').style.display = 'none';
    }
    
    // Save preferences from modal
    function saveMealPlannerPrefsFromModal() {
      const cuisines = Array.from(document.querySelectorAll('.pref-cuisine:checked')).map(cb => cb.value);
      
      const prefs = {
        favoriteCuisines: cuisines,
        avoidRepeat: document.getElementById('prefAvoidRepeat').checked,
        usePantry: document.getElementById('prefUsePantry').checked,
        favoritesOnly: document.getElementById('prefFavoritesOnly').checked,
        breakfastStyle: document.getElementById('prefBreakfastStyle').value,
        avoidRecipeRepeat: document.getElementById('prefAvoidRecipeRepeat').checked,
        recipeRepeatDays: Number(document.getElementById('prefRecipeRepeatDays').value),
        excludeBreakfast: document.getElementById('prefExcludeBreakfast').checked,
        excludeLunch: document.getElementById('prefExcludeLunch').checked,
        excludeDinner: document.getElementById('prefExcludeDinner').checked
      };
      
      saveMealPlannerPrefs(prefs);
      document.getElementById('mealPlannerPrefsStatus').textContent = '‚úì Saved!';
      
      setTimeout(() => {
        closeMealPlannerPrefs();
      }, 800);
    }

    // ============ CUISINE MANAGEMENT (Comprehensive List) ============
    
    // Comprehensive master cuisine list (single source of truth)
    const COMPREHENSIVE_CUISINES = [
      'Afghan','African','Albanian','American','Argentinian','Armenian','Asian','Australian','Austrian',
      'Bangladeshi','Barbecue','Belgian','Bolivian','Brazilian','British','Bulgarian','Cajun/Creole',
      'Cambodian','Caribbean','Chilean','Chinese','Colombian','Cuban','Czech',
      'Danish','Dominican','Dutch',
      'Ecuadorian','Egyptian','English','Ethiopian','European',
      'Filipino','Finnish','French',
      'Georgian','German','Greek','Guatemalan',
      'Haitian','Hawaiian','Hungarian',
      'Icelandic','Indian','Indonesian','Iranian','Iraqi','Irish','Israeli','Italian',
      'Jamaican','Japanese','Jewish','Jordanian',
      'Korean','Kosher',
      'Latin American','Lebanese',
      'Malaysian','Mediterranean','Mexican','Middle Eastern','Mongolian','Moroccan',
      'Nepalese','New Zealand','Nigerian','Norwegian',
      'Pakistani','Persian','Peruvian','Polish','Portuguese','Puerto Rican',
      'Romanian','Russian',
      'Salvadoran','Scandinavian','Scottish','Seafood','Serbian','Singaporean','Slovak','South African','South American','Spanish','Sri Lankan','Swedish','Swiss',
      'Taiwanese','Thai','Tibetan','Turkish',
      'Ukrainian',
      'Vegan','Vegetarian','Vietnamese',
      'Welsh'
    ];
    
    // Get cuisines currently in use in recipes
    async function getCuisinesInUse() {
      try {
        const result = await api('listUniqueCuisines', {});
        if (result.ok && Array.isArray(result.cuisines)) {
          return new Set(result.cuisines);
        }
      } catch (e) {
        console.error('Failed to load cuisines from database:', e);
      }
      return new Set();
    }
    
    // Render cuisine checkboxes in preferences modal (shows comprehensive list)
    function renderCuisineCheckboxes() {
      const grid = document.getElementById('cuisineGrid');
      const prefs = loadMealPlannerPrefs();
      
      grid.innerHTML = COMPREHENSIVE_CUISINES.map(cuisine => `
        <label class="cuisine-option">
          <input type="checkbox" class="pref-cuisine" value="${escapeAttr(cuisine)}" ${prefs.favoriteCuisines.includes(cuisine) ? 'checked' : ''}>
          <span>${escapeHtml(cuisine)}</span>
        </label>
      `).join('');
    }
    
    // Render cuisine management UI in Admin tab (shows comprehensive list with usage indicators)
    async function renderCuisineManagementUI() {
      const list = document.getElementById('cuisineManageList');
      const status = document.getElementById('cuisineManageStatus');
      
      status.textContent = 'Loading...';
      const cuisinesInUse = await getCuisinesInUse();
      status.textContent = '';
      
      list.innerHTML = COMPREHENSIVE_CUISINES.map(cuisine => {
        const inUse = cuisinesInUse.has(cuisine);
        return `
          <div class="item" style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
            <span style="flex:1;">
              ${escapeHtml(cuisine)}
              ${inUse ? '<span class="pill accent" style="margin-left:8px; font-size:11px;">In Use</span>' : '<span class="muted" style="margin-left:8px; font-size:11px;">Not Used</span>'}
            </span>
            <div style="display:flex; gap:4px;">
              ${inUse ? `<button class="ghost mini" data-action="rename-cuisine" data-cuisine="${escapeAttr(cuisine)}">Rename</button>` : ''}
              ${inUse ? `<button class="danger mini" data-action="clear-cuisine" data-cuisine="${escapeAttr(cuisine)}">Clear from Recipes</button>` : ''}
              ${!inUse ? `<button class="danger mini" data-action="delete-cuisine" data-cuisine="${escapeAttr(cuisine)}">Remove from List</button>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Clear cuisine from all recipes that use it
    async function clearCuisineFromRecipes(cuisineName) {
      if (!confirm(`Clear "${cuisineName}" from all recipes? This will remove this cuisine assignment from all recipes that use it.`)) return;
      
      const status = document.getElementById('cuisineManageStatus');
      status.textContent = 'Clearing...';
      
      const result = await api('manageCuisine', {
        action: 'delete',
        oldName: cuisineName
      });
      
      if (result.ok) {
        status.textContent = `‚úì ${result.message}`;
        setTimeout(() => { status.textContent = ''; }, 3000);
        await renderCuisineManagementUI();
      } else {
        status.textContent = `Error: ${result.error}`;
        setTimeout(() => { status.textContent = ''; }, 5000);
      }
    }
    
    // Rename a cuisine (updates all recipes using it)
    async function renameCuisine(oldName) {
      const newName = prompt(`Rename "${oldName}" to:`, oldName);
      if (!newName || newName.trim() === '') return;
      if (newName.trim() === oldName) return;
      
      const status = document.getElementById('cuisineManageStatus');
      status.textContent = 'Renaming...';
      
      const result = await api('manageCuisine', {
        action: 'rename',
        oldName: oldName,
        newName: newName.trim()
      });
      
      if (result.ok) {
        // Update the comprehensive cuisines list
        const index = COMPREHENSIVE_CUISINES.indexOf(oldName);
        if (index !== -1) {
          COMPREHENSIVE_CUISINES[index] = newName.trim();
          COMPREHENSIVE_CUISINES.sort((a, b) => a.localeCompare(b));
        }
        
        status.textContent = `‚úì ${result.message}`;
        setTimeout(() => { status.textContent = ''; }, 3000);
        
        // Refresh all UI components
        await renderCuisineManagementUI();
        populateCuisineFilter();
        renderCuisineCheckboxes();
      } else {
        status.textContent = `Error: ${result.error}`;
        setTimeout(() => { status.textContent = ''; }, 5000);
      }
    }
    
    // Add a new cuisine to the master list
    function addCuisine() {
      const input = document.getElementById('newCuisineName');
      const cuisineName = input.value.trim();
      
      if (!cuisineName) {
        document.getElementById('cuisineManageStatus').textContent = 'Please enter a cuisine name.';
        setTimeout(() => { document.getElementById('cuisineManageStatus').textContent = ''; }, 3000);
        return;
      }
      
      // Check if already exists (case-insensitive)
      const exists = COMPREHENSIVE_CUISINES.some(c => c.toLowerCase() === cuisineName.toLowerCase());
      if (exists) {
        document.getElementById('cuisineManageStatus').textContent = `"${cuisineName}" already exists in the list.`;
        setTimeout(() => { document.getElementById('cuisineManageStatus').textContent = ''; }, 3000);
        return;
      }
      
      // Add to the list
      COMPREHENSIVE_CUISINES.push(cuisineName);
      COMPREHENSIVE_CUISINES.sort((a, b) => a.localeCompare(b));
      
      // Clear input
      input.value = '';
      
      // Refresh UI
      renderCuisineManagementUI();
      populateCuisineFilter();
      renderCuisineCheckboxes();
      
      document.getElementById('cuisineManageStatus').textContent = `‚úì Added "${cuisineName}" to the cuisine list.`;
      setTimeout(() => { document.getElementById('cuisineManageStatus').textContent = ''; }, 3000);
    }
    
    // Remove a cuisine from the master list (only if not in use)
    function deleteCuisineFromList(cuisineName) {
      if (!confirm(`Remove "${cuisineName}" from the cuisine list? This only removes it from the dropdown, not from recipes.`)) return;
      
      const index = COMPREHENSIVE_CUISINES.indexOf(cuisineName);
      if (index !== -1) {
        COMPREHENSIVE_CUISINES.splice(index, 1);
      }
      
      // Refresh UI
      renderCuisineManagementUI();
      populateCuisineFilter();
      renderCuisineCheckboxes();
      
      document.getElementById('cuisineManageStatus').textContent = `‚úì Removed "${cuisineName}" from the cuisine list.`;
      setTimeout(() => { document.getElementById('cuisineManageStatus').textContent = ''; }, 3000);
    }
    
    // Populate cuisine filter dropdown with comprehensive list
    function populateCuisineFilter() {
      const select = document.getElementById('recipeCuisineFilter');
      if (!select) return;
      
      const currentValue = select.value;
      
      // Build options HTML
      const optionsHtml = ['<option value="">All Cuisines</option>'].concat(
        COMPREHENSIVE_CUISINES.map(cuisine => 
          `<option value="${escapeAttr(cuisine)}">${escapeHtml(cuisine)}</option>`
        )
      ).join('');
      
      select.innerHTML = optionsHtml;
      
      // Restore selected value if it still exists
      if (currentValue && COMPREHENSIVE_CUISINES.includes(currentValue)) {
        select.value = currentValue;
      }
    }
    
    // Populate import preview cuisine dropdown with comprehensive list
    function populateImportCuisineDropdown() {
      const select = document.getElementById('importPreviewCuisine');
      if (!select) return;
      
      const currentValue = select.value;
      
      // Build options HTML
      const optionsHtml = ['<option value="">Unknown</option>'].concat(
        COMPREHENSIVE_CUISINES.map(cuisine => 
          `<option value="${escapeAttr(cuisine)}">${escapeHtml(cuisine)}</option>`
        )
      ).join('');
      
      select.innerHTML = optionsHtml;
      
      // Restore selected value if it still exists
      if (currentValue && COMPREHENSIVE_CUISINES.includes(currentValue)) {
        select.value = currentValue;
      }
    }
    
    // Score a recipe for a given meal slot
    function scoreRecipe(recipe, context, prefs) {
      let score = 100;
      
      // Cuisine preference (+30 if favorite)
      if (prefs.favoriteCuisines.length > 0) {
        if (prefs.favoriteCuisines.includes(recipe.Cuisine)) {
          score += 30;
        } else if (recipe.Cuisine) {
          score -= 10; // Slight penalty for non-favorite cuisines
        }
      }
      
      // Favorites bonus (+40 if starred)
      if (recipe.is_favorite) {
        score += 40;
      }
      
      // Favorites only filter (hard constraint)
      if (prefs.favoritesOnly && !recipe.is_favorite) {
        return 0;
      }
      
      // Pantry ingredients match
      if (prefs.usePantry && context.pantryItems && context.pantryItems.length > 0) {
        const recipeName = (recipe.Title || '').toLowerCase();
        const matchCount = context.pantryItems.filter(p => {
          const pantryName = (p.NameLower || p.Name || '').toLowerCase();
          return pantryName && recipeName.includes(pantryName);
        }).length;
        score += matchCount * 15;
      }
      
      // Avoid cuisine repetition (same cuisine on consecutive days)
      if (prefs.avoidRepeat && context.previousDayCuisine && recipe.Cuisine) {
        if (context.previousDayCuisine === recipe.Cuisine) {
          score -= 35;
        }
      }
      
      // Avoid same-day cuisine repetition
      if (context.sameDayCuisines && recipe.Cuisine) {
        if (context.sameDayCuisines.includes(recipe.Cuisine)) {
          score -= 25;
        }
      }
      
      // Meal type match
      if (context.mealType) {
        const recipeMealType = (recipe.MealType || 'Any').toLowerCase();
        const targetMealType = context.mealType.toLowerCase();
        
        if (recipeMealType === targetMealType) {
          score += 20;
        } else if (recipeMealType === 'any') {
          score += 5; // Small bonus for flexible recipes
        } else {
          score -= 15; // Penalty for mismatch
        }
      }
      
      // Avoid recently used recipes (in last 7 days)
      if (context.recentlyUsed && context.recentlyUsed.has(recipe.RecipeId)) {
        score -= 50;
      }
      
      // Avoid recipe repetition within specified days (new feature)
      if (prefs.avoidRecipeRepeat && context.usedRecipesInWindow) {
        const recipeId = recipe.RecipeId;
        const mealType = context.mealType;
        
        // Check if this meal type is excluded from the rule
        const isExcluded = 
          (mealType === 'Breakfast' && prefs.excludeBreakfast) ||
          (mealType === 'Lunch' && prefs.excludeLunch) ||
          (mealType === 'Dinner' && prefs.excludeDinner);
        
        // Apply penalty if recipe was used recently and meal type is not excluded
        if (!isExcluded && context.usedRecipesInWindow.has(recipeId)) {
          score -= 60; // Strong penalty to avoid repeating recipes
        }
      }
      
      // Random variation to avoid always picking same top recipes
      score += Math.random() * 10;
      
      return Math.max(0, score);
    }
    
    // Get recently used recipes from plans
    async function getRecentlyUsedRecipes(daysBack = 7) {
      const endDate = ymd(new Date());
      const startDate = addDays(endDate, -daysBack);
      
      const result = await api('getPlansRange', { start: startDate, end: endDate });
      if (!result.ok || !result.plans) return new Set();
      
      const used = new Set();
      result.plans.forEach(plan => {
        if (plan.Breakfast && plan.Breakfast.RecipeId) used.add(plan.Breakfast.RecipeId);
        if (plan.Lunch && plan.Lunch.RecipeId) used.add(plan.Lunch.RecipeId);
        if (plan.Dinner && plan.Dinner.RecipeId) used.add(plan.Dinner.RecipeId);
      });
      
      return used;
    }
    
    // Generate smart weekly meal plan
    async function generateSmartWeek() {
      const status = document.getElementById('generateWeekStatus');
      status.textContent = 'Generating your week...';
      
      const prefs = loadMealPlannerPrefs();
      
      // Read date range from the main planner inputs (not modal)
      const startDateInput = document.getElementById('genStartDate').value;
      const endDateInput = document.getElementById('genEndDate').value;
      
      if (!startDateInput || !endDateInput) {
        status.textContent = 'Error: Please select start and end dates';
        setTimeout(() => { status.textContent = ''; }, 3000);
        return;
      }
      
      // Calculate number of days (inclusive of both start and end)
      const [sy, sm, sd] = startDateInput.split('-').map(Number);
      const [ey, em, ed] = endDateInput.split('-').map(Number);
      const startDateObj = new Date(sy, sm - 1, sd);
      const endDateObj = new Date(ey, em - 1, ed);
      
      if (endDateObj < startDateObj) {
        status.textContent = 'Error: End date must be after start date';
        setTimeout(() => { status.textContent = ''; }, 3000);
        return;
      }
      
      const diffTime = endDateObj.getTime() - startDateObj.getTime();
      const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end days
      
      console.log('[generateSmartWeek] Start:', startDateInput, 'End:', endDateInput, 'Days:', diffDays);
      
      if (diffDays > 60) {
        status.textContent = 'Error: Date range too large (max 60 days)';
        setTimeout(() => { status.textContent = ''; }, 3000);
        return;
      }
      
      // Get all recipes
      const recipesResult = await api('listRecipesAll', {});
      if (!recipesResult.ok || !recipesResult.recipes) {
        status.textContent = 'Error: Could not load recipes';
        return;
      }
      
      let allRecipes = recipesResult.recipes;
      
      // Get pantry items if needed
      let pantryItems = [];
      if (prefs.usePantry) {
        const pantryResult = await api('listPantry', {});
        if (pantryResult.ok && pantryResult.items) {
          pantryItems = pantryResult.items.filter(item => {
            const qty = item.QtyNum;
            return qty && Number(qty) > 0;
          });
        }
      }
      
      // Get recently used recipes
      const recentlyUsed = await getRecentlyUsedRecipes(diffDays);
      
      // Separate recipes by meal type
      const breakfastRecipes = allRecipes.filter(r => {
        const mt = (r.MealType || 'Any').toLowerCase();
        return mt === 'breakfast' || mt === 'any';
      });
      
      const lunchRecipes = allRecipes.filter(r => {
        const mt = (r.MealType || 'Any').toLowerCase();
        return mt === 'lunch' || mt === 'any';
      });
      
      const dinnerRecipes = allRecipes.filter(r => {
        const mt = (r.MealType || 'Any').toLowerCase();
        return mt === 'dinner' || mt === 'any';
      });
      
      if (breakfastRecipes.length === 0 || lunchRecipes.length === 0 || dinnerRecipes.length === 0) {
        status.textContent = 'Error: Not enough recipes. Add more recipes first.';
        return;
      }
      
      const weekPlan = [];
      let previousDayCuisine = null;
      
      // Track used recipes within the repeat window for recipe repetition avoidance
      const usedRecipesByDay = []; // Array of Sets, one per day
      
      // Generate meals for the selected date range
      for (let dayOffset = 0; dayOffset < diffDays; dayOffset++) {
        const dayDate = addDays(startDateInput, dayOffset);
        const sameDayCuisines = [];
        
        // Calculate the sliding window for recipe repetition
        const windowStart = Math.max(0, dayOffset - (prefs.recipeRepeatDays || 3) + 1);
        const usedRecipesInWindow = new Set();
        if (prefs.avoidRecipeRepeat) {
          for (let i = windowStart; i < dayOffset; i++) {
            if (usedRecipesByDay[i]) {
              usedRecipesByDay[i].forEach(rid => usedRecipesInWindow.add(rid));
            }
          }
        }
        
        // Initialize the set for tracking today's recipes
        usedRecipesByDay[dayOffset] = new Set();
        
        // Breakfast
        let breakfastRecipe = null;
        if (prefs.breakfastStyle === 'skip') {
          breakfastRecipe = null;
        } else if (prefs.breakfastStyle === 'same' && dayOffset > 0 && weekPlan[0].breakfast) {
          // Use same breakfast as day 1
          breakfastRecipe = weekPlan[0].breakfast;
        } else {
          // Score and select breakfast
          const breakfastCandidates = breakfastRecipes.map(r => ({
            recipe: r,
            score: scoreRecipe(r, {
              mealType: 'Breakfast',
              pantryItems,
              recentlyUsed,
              previousDayCuisine,
              sameDayCuisines,
              usedRecipesInWindow
            }, prefs)
          })).filter(c => c.score > 0);
          
          if (breakfastCandidates.length > 0) {
            breakfastCandidates.sort((a, b) => b.score - a.score);
            breakfastRecipe = breakfastCandidates[0].recipe;
            if (breakfastRecipe.Cuisine) sameDayCuisines.push(breakfastRecipe.Cuisine);
            if (breakfastRecipe.RecipeId) usedRecipesByDay[dayOffset].add(breakfastRecipe.RecipeId);
          }
        }
        
        // Lunch
        const lunchCandidates = lunchRecipes.map(r => ({
          recipe: r,
          score: scoreRecipe(r, {
            mealType: 'Lunch',
            pantryItems,
            recentlyUsed,
            previousDayCuisine,
            sameDayCuisines,
            usedRecipesInWindow
          }, prefs)
        })).filter(c => c.score > 0);
        
        lunchCandidates.sort((a, b) => b.score - a.score);
        const lunchRecipe = lunchCandidates.length > 0 ? lunchCandidates[0].recipe : null;
        if (lunchRecipe && lunchRecipe.Cuisine) sameDayCuisines.push(lunchRecipe.Cuisine);
        if (lunchRecipe && lunchRecipe.RecipeId) usedRecipesByDay[dayOffset].add(lunchRecipe.RecipeId);
        
        // Dinner
        const dinnerCandidates = dinnerRecipes.map(r => ({
          recipe: r,
          score: scoreRecipe(r, {
            mealType: 'Dinner',
            pantryItems,
            recentlyUsed,
            previousDayCuisine,
            sameDayCuisines,
            usedRecipesInWindow
          }, prefs)
        })).filter(c => c.score > 0);
        
        dinnerCandidates.sort((a, b) => b.score - a.score);
        const dinnerRecipe = dinnerCandidates.length > 0 ? dinnerCandidates[0].recipe : null;
        if (dinnerRecipe && dinnerRecipe.RecipeId) usedRecipesByDay[dayOffset].add(dinnerRecipe.RecipeId);
        
        weekPlan.push({
          date: dayDate,
          breakfast: breakfastRecipe,
          lunch: lunchRecipe,
          dinner: dinnerRecipe
        });
        
        // Set previous day cuisine for next iteration (use dinner cuisine as primary)
        previousDayCuisine = dinnerRecipe ? dinnerRecipe.Cuisine : (lunchRecipe ? lunchRecipe.Cuisine : (breakfastRecipe ? breakfastRecipe.Cuisine : null));
      }
      
      // Apply the plan to the database
      status.textContent = 'Applying plan...';
      
      for (const day of weekPlan) {
        if (day.breakfast) {
          await api('upsertPlanMeal', {
            date: day.date,
            slot: 'Breakfast',
            meal: {
              RecipeId: day.breakfast.RecipeId,
              Title: day.breakfast.Title,
              UseLeftovers: false,
              From: ''
            }
          });
        }
        
        if (day.lunch) {
          await api('upsertPlanMeal', {
            date: day.date,
            slot: 'Lunch',
            meal: {
              RecipeId: day.lunch.RecipeId,
              Title: day.lunch.Title,
              UseLeftovers: false,
              From: ''
            }
          });
        }
        
        if (day.dinner) {
          await api('upsertPlanMeal', {
            date: day.date,
            slot: 'Dinner',
            meal: {
              RecipeId: day.dinner.RecipeId,
              Title: day.dinner.Title,
              UseLeftovers: false,
              From: ''
            }
          });
        }
      }
      
      status.textContent = '‚úì Week generated successfully!';
      
      // Update the planner tab date inputs to match generated range (they're the same now)
      document.getElementById('planStart').value = startDateInput;
      document.getElementById('planEnd').value = endDateInput;
      
      // Reload the planner to show new meals
      await loadPlan();
      
      setTimeout(() => {
        status.textContent = `‚úì Generated ${diffDays} days of meals!`;
        setTimeout(() => {
          status.textContent = '';
        }, 5000);
      }, 500);
    }

    
    // Planner / Bulk planner - shared load function
    async function loadPlan() {
      const start = document.getElementById('planStart').value;
      console.log('[loadPlan] start:', start);
      if (!start) {
        console.log('[loadPlan] No start date, returning early');
        return;
      }
      
      // Check if end date is provided and calculate the range
      const endInput = document.getElementById('planEnd').value;
      console.log('[loadPlan] endInput:', endInput);
      let days = 1;
      
      if (endInput) {
        // Calculate days from start to end (inclusive)
        const [sy, sm, sd] = start.split('-').map(Number);
        const [ey, em, ed] = endInput.split('-').map(Number);
        const startDate = new Date(sy, sm - 1, sd);
        const endDate = new Date(ey, em - 1, ed);
        const diffTime = endDate.getTime() - startDate.getTime();
        days = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
        console.log('[loadPlan] Calculated days:', days, 'from', start, 'to', endInput);
      } else {
        // Fall back to planDays input if no end date
        days = Number(document.getElementById('planDays').value || 1);
        console.log('[loadPlan] Using planDays fallback:', days);
      }
      
      console.log('[loadPlan] Calling loadPlansIntoUi with start:', start, 'days:', days);
      await loadPlansIntoUi(start, days);
    }

    // ========== GOOGLE CALENDAR FUNCTIONS ==========
    
    async function uploadGoogleCredentials() {
      const fileInput = document.getElementById('googleCredentialsFile');
      const file = fileInput.files[0];
      if (!file) {
        document.getElementById('googleCredsStatus').textContent = 'No file selected';
        return;
      }

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const credentials = JSON.parse(e.target.result);
          const res = await api('initGoogleCalendar', { credentials });
          
          if (res.ok) {
            document.getElementById('googleCredsStatus').textContent = '‚úì Credentials loaded';
            document.getElementById('btnGoogleAuthorize').disabled = false;
            await checkGoogleCalendarStatus();
          } else {
            document.getElementById('googleCredsStatus').textContent = `Error: ${res.error}`;
          }
        } catch (err) {
          document.getElementById('googleCredsStatus').textContent = `Error: Invalid JSON file`;
        }
      };
      reader.readAsText(file);
    }

    async function authorizeGoogleCalendar() {
      const res = await api('getGoogleAuthUrl', {});
      if (!res.ok) {
        document.getElementById('googleAuthStatus').textContent = `Error: ${res.error}`;
        return;
      }

      window.open(res.authUrl, '_blank');
      
      document.getElementById('googleAuthCodeRow').style.display = 'block';
      document.getElementById('googleAuthLink').href = res.authUrl;
      document.getElementById('googleAuthLink').style.display = 'inline';
      document.getElementById('googleAuthStatus').textContent = 'Sign in with Google and paste the authorization code below';
    }

    async function submitGoogleAuthCode() {
      const code = document.getElementById('googleAuthCode').value.trim();
      if (!code) {
        document.getElementById('googleAuthStatus').textContent = 'Please enter the authorization code';
        return;
      }

      document.getElementById('googleAuthStatus').textContent = 'Authorizing...';
      const res = await api('setGoogleAuthCode', { code });
      
      if (res.ok) {
        document.getElementById('googleAuthStatus').textContent = '‚úì Authorized! Google Calendar is ready.';
        document.getElementById('googleAuthCodeRow').style.display = 'none';
        document.getElementById('googleAuthCode').value = '';
        await checkGoogleCalendarStatus();
        await listGoogleCalendars();
      } else {
        document.getElementById('googleAuthStatus').textContent = `Error: ${res.error}`;
      }
    }

    async function listGoogleCalendars() {
      const res = await api('listGoogleCalendars', {});
      if (!res.ok) {
        document.getElementById('googleSyncStatus').textContent = `Error: ${res.error}`;
        return;
      }

      const select = document.getElementById('googleCalendarSelect');
      select.innerHTML = '<option value="">-- Select calendar --</option>';
      
      for (const cal of res.calendars) {
        const option = document.createElement('option');
        option.value = cal.id;
        option.textContent = cal.name + (cal.primary ? ' (Primary)' : '');
        select.appendChild(option);
      }
      
      select.disabled = false;
      document.getElementById('btnGoogleCalSync').disabled = false;
    }

    async function syncToGoogleCalendar() {
      const start = document.getElementById('googleSyncStart').value;
      const end = document.getElementById('googleSyncEnd').value;
      const calendarId = document.getElementById('googleCalendarSelect').value;
      
      if (!start || !end) {
        document.getElementById('googleSyncStatus').textContent = 'Please set sync date range above';
        return;
      }
      
      if (!calendarId) {
        document.getElementById('googleSyncStatus').textContent = 'Please select a calendar';
        return;
      }

      await window.Foodie.setGoogleCalendarId(calendarId);

      document.getElementById('googleSyncStatus').textContent = 'Syncing...';
      console.log('[Google Calendar Sync] Start:', start, 'End:', end, 'CalendarId:', calendarId);
      
      let res;
      try {
        res = await api('googleCalendarSyncRange', { start, end, calendarId });
      } catch (err) {
        console.error('[Google Calendar Sync] Exception during API call:', err);
        document.getElementById('googleSyncStatus').textContent = `Error: ${err.message}`;
        return;
      }
      
      console.log('[Google Calendar Sync] Result:', res);
      console.log('[Google Calendar Sync] Result.ok:', res.ok);
      console.log('[Google Calendar Sync] Result.error:', res.error);
      console.log('[Google Calendar Sync] Result.created:', res.created);
      console.log('[Google Calendar Sync] Result.updated:', res.updated);
      
      if (!res || !res.ok) {
        const errorMsg = (res && res.error) ? res.error : 'Unknown error - check main process logs';
        console.error('[Google Calendar Sync] ERROR:', errorMsg);
        document.getElementById('googleSyncStatus').textContent = `Error: ${errorMsg}`;
        return;
      }
      
      document.getElementById('googleSyncStatus').textContent = `‚úì Synced. Created: ${res.created||0}, Updated: ${res.updated||0}`;
      setTimeout(() => {
        document.getElementById('googleSyncStatus').textContent = '';
      }, 5000);
    }

    async function revokeGoogleCalendar() {
      if (!confirm('This will remove Foodie\'s access to your Google Calendar. You\'ll need to re-authorize. Continue?')) {
        return;
      }

      const res = await api('revokeGoogleCalendar', {});
      if (res.ok) {
        document.getElementById('googleAuthStatus').textContent = 'Access revoked. Re-authorize to sync again.';
        document.getElementById('btnGoogleCalSync').disabled = true;
        document.getElementById('googleCalendarSelect').disabled = true;
        await checkGoogleCalendarStatus();
      }
    }

    async function checkForDuplicates() {
      const start = document.getElementById('googleSyncStart').value;
      const end = document.getElementById('googleSyncEnd').value;
      const calendarId = document.getElementById('googleCalendarSelect').value;
      
      if (!start || !end) {
        document.getElementById('googleDuplicateStatus').textContent = 'Please set sync date range first';
        return;
      }
      
      if (!calendarId) {
        document.getElementById('googleDuplicateStatus').textContent = 'Please select a calendar';
        return;
      }

      document.getElementById('googleDuplicateStatus').textContent = 'Checking for duplicates...';
      console.log('[Check Duplicates] Start:', start, 'End:', end, 'CalendarId:', calendarId);
      
      const res = await api('checkGoogleCalendarDuplicates', { start, end, calendarId });
      
      if (!res.ok) {
        document.getElementById('googleDuplicateStatus').textContent = `Error: ${res.error}`;
        return;
      }

      console.log('[Check Duplicates] Result:', res);
      
      if (res.hasDuplicates) {
        const dupList = res.duplicates.map(d => 
          `${d.date} ${d.slot} (${d.count} copies)`
        ).join(', ');
        document.getElementById('googleDuplicateStatus').innerHTML = 
          `‚ö†Ô∏è Found ${res.duplicates.length} duplicate(s):<br>${dupList}<br><span class="muted">Check your Google Calendar settings on the device showing duplicates.</span>`;
      } else {
        document.getElementById('googleDuplicateStatus').textContent = 
          `‚úì No duplicates found. Checked ${res.checked} events.`;
        setTimeout(() => {
          document.getElementById('googleDuplicateStatus').textContent = '';
        }, 5000);
      }
    }

    async function checkGoogleCalendarStatus() {
      const res = await api('getGoogleCalendarStatus', {});
      if (res.ok) {
        if (res.authenticated) {
          document.getElementById('googleCredsStatus').textContent = '‚úì Configured & Authorized';
          document.getElementById('btnListGoogleCals').disabled = false;
          document.getElementById('btnCheckDuplicates').disabled = false;
          document.getElementById('googleCalendarSelect').disabled = false;
          await listGoogleCalendars();
        } else if (res.hasCredentials) {
          document.getElementById('googleCredsStatus').textContent = 'Credentials loaded. Please authorize.';
          document.getElementById('btnGoogleAuthorize').disabled = false;
        }
      }
    }

    
    function bindUi() {
      // Recipes
      document.getElementById('btnAddRecipe').addEventListener('click', openRecipeModalNew);
      document.getElementById('btnImportRecipe').addEventListener('click', openImportRecipeModal);
      document.getElementById('btnRefresh').addEventListener('click', resetAndLoadRecipes);

      document.getElementById('btnModalClose').addEventListener('click', closeRecipeModal);
      document.getElementById('btnModalToggleEdit').addEventListener('click', toggleRecipeModalMode);
      document.getElementById('btnSaveRecipeFull').addEventListener('click', saveRecipeAndIngredients);
      document.getElementById('btnDeleteRecipe').addEventListener('click', deleteRecipeUi);
    // Print the current recipe with scaled quantities (from modal)
    async function printRecipeWithQuantities() {
      const title = document.getElementById('rTitle').value || 'Untitled Recipe';
      const instructions = document.getElementById('rInstructions').value || '';
      const url = document.getElementById('rUrl').value || '';
      
      // Helper to clean date strings from QtyText
      const cleanQtyText = (qtyText) => {
        if (!qtyText) return '';
        // Remove date strings that were mistakenly parsed from fractions
        const datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}\s+\d{4}\s+\d{2}:\d{2}:\d{2}\s+GMT[-+]\d{4}\s+\([^)]+\)\s*/i;
        return qtyText.replace(datePattern, '').trim();
      };
      
      // Build ingredients list from current ING_ROWS (includes any scaling)
      const ingredientsHtml = ING_ROWS.map(r => {
        const qtyNum = r.QtyNum !== '' ? r.QtyNum : '';
        const unit = r.Unit || '';
        const rawQtyText = r.QtyText || '';
        const cleanText = cleanQtyText(rawQtyText);
        const name = r.IngredientRaw || r.IngredientNorm || '';
        
        // Format: When scaled (RECIPE_SCALE !== 1.0), always use QtyNum + Unit
        // When NOT scaled, prefer clean QtyText if it exists, otherwise use QtyNum + unit
        let qtyDisplay = '';
        if (RECIPE_SCALE !== 1.0) {
          // Always use QtyNum and Unit when scaled
          if (qtyNum && unit) {
            qtyDisplay = `${qtyNum} ${unit}`;
          } else if (qtyNum) {
            qtyDisplay = qtyNum;
          } else if (unit) {
            qtyDisplay = unit;
          }
        } else {
          // Not scaled - prefer clean QtyText if it exists
          if (cleanText && cleanText.length > 0) {
            qtyDisplay = cleanText;
          } else if (qtyNum && unit) {
            qtyDisplay = `${qtyNum} ${unit}`;
          } else if (qtyNum) {
            qtyDisplay = qtyNum;
          } else if (unit) {
            qtyDisplay = unit;
          }
        }
        
        return `<div style="display:flex;gap:8px;margin-bottom:4px;">
          <span style="min-width:80px;text-align:right;font-weight:600;">${escapeHtml(qtyDisplay)}</span>
          <span>${escapeHtml(name)}</span>
        </div>`;
      }).join('');
      
      // Build print-friendly HTML
      const printHtml = `
        <!DOCTYPE html>
        <html>
        <head>
    <meta charset="UTF-8">
          <title>${escapeHtml(title)}</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; color: #000; }
            h1 { border-bottom: 2px solid #333; padding-bottom: 8px; font-size: 24px; }
            h3 { margin-top: 20px; margin-bottom: 10px; font-size: 16px; }
            pre { white-space: pre-wrap; font-family: inherit; line-height: 1.6; }
            @media print {
              body { padding: 0; }
              h1 { font-size: 20px; }
            }
          </style>
        </head>
        <body>
          <h1>${escapeHtml(title)}</h1>
          ${url ? `<p><a href="${escapeAttr(url)}">${escapeHtml(url)}</a></p>` : ''}
          ${instructions ? `<div><h3>Instructions</h3><pre>${escapeHtml(instructions)}</pre></div>` : ''}
          <div><h3>Ingredients</h3>${ingredientsHtml}</div>
          <script>window.onload = function() { window.print(); }<\/script>
        </body>
        </html>
      `;
      
      // Open print window
      const printWindow = window.open('', '_blank');
      printWindow.document.write(printHtml);
      printWindow.document.close();
    }

    // Print recipe from database (used when not in modal context)
    async function printRecipeFromDb(recipeId) {
      await window.Foodie.printRecipe(recipeId);
    }

    document.getElementById('btnPrintRecipe').addEventListener('click', async () => {
      if (CURRENT_RECIPE_ID) {
        // Apply current scale to display before printing (force refresh)
        applyCurrentScaleToDisplay(true);
        // Print with current scaled quantities from modal
        await printRecipeWithQuantities();
      }
    });
    
    // View mode print button
    document.getElementById('btnPrintRecipeView').addEventListener('click', async () => {
      if (CURRENT_RECIPE_ID) {
        // Apply current scale to display before printing (force refresh)
        applyCurrentScaleToDisplay(true);
        // Print with current scaled quantities from modal
        await printRecipeWithQuantities();
      }
    });
      document.getElementById('btnAddIngredientRow').addEventListener('click', () => {
        if (recipeModalMode !== 'view') addIngredientRow();
      });
      document.getElementById('btnCategorizeAll').addEventListener('click', async () => {
        if (recipeModalMode !== 'view') await categorizeAllIngredients();
      });

      document.getElementById('recipesList').addEventListener('click', async (e) => {
        const v = e.target.closest('[data-action="recipe-view"]');
        if (v) { await openRecipeModalView(v.dataset.rid); return; }
        const ed = e.target.closest('[data-action="recipe-edit"]');
        if (ed) { await openRecipeModalEdit(ed.dataset.rid); return; }
        const fav = e.target.closest('[data-action="recipe-favorite"]');
        if (fav) {
          const rid = fav.dataset.rid;
          const res = await api('toggleRecipeFavorite', { recipeId: rid });
          if (res.ok) {
            // Reload all recipes from database to get updated favorite status
            await resetAndLoadRecipes();
          }
          return;
        }
      });

      document.getElementById('recipeSearch').addEventListener('input', async () => {
        CURRENT_QUERY = (document.getElementById('recipeSearch').value || '').trim().toLowerCase();
        await resetAndLoadRecipes();
      });

      // Favorites filter
      document.getElementById('recipeFavoritesOnly').addEventListener('change', async () => {
        await resetAndLoadRecipes();
      });

      // Cuisine filter
      document.getElementById('recipeCuisineFilter').addEventListener('change', async () => {
        await resetAndLoadRecipes();
      });

      // Jump A-Z functionality
      document.getElementById('jumpLetter').addEventListener('change', async (e) => {
        const letter = e.target.value;
        CURRENT_QUERY = letter;
        await resetAndLoadRecipes();
      });

      // Meal picker
      document.getElementById('btnMealPickerClose').addEventListener('click', closeMealPicker);
      document.getElementById('mpSearch').addEventListener('input', async () => {
        MP.q = (document.getElementById('mpSearch').value || '').trim().toLowerCase();
        await mealPickerLoad(true);
      });
      document.getElementById('mpClearMeal').addEventListener('click', async () => {
        if (!MP.open) return;
        await api('upsertPlanMeal', { date: MP.date, slot: MP.slot, meal: null });
        closeMealPicker();
        await loadPlansIntoUi(PLAN.start, PLAN.days);
        await loadPantry(); // Refresh pantry after clearing meal
      });
      document.getElementById('mpList').addEventListener('click', async (e) => {
        const sel = e.target.closest('[data-action="mp-select"]');
        if (!sel || !MP.open) return;
        const meal = { RecipeId: sel.dataset.rid, Title: sel.dataset.title };
        await api('upsertPlanMeal', { date: MP.date, slot: MP.slot, meal });
        closeMealPicker();
        await loadPlansIntoUi(PLAN.start, PLAN.days);
        await loadPantry(); // Refresh pantry after planning meal
      });

      // Auto-load when date inputs change
      document.getElementById('planStart').addEventListener('change', loadPlan);
      document.getElementById('planEnd').addEventListener('change', loadPlan);
      document.getElementById('btnPlanExpandAll').addEventListener('click', () => {
        document.querySelectorAll('#planList details').forEach(d => d.open = true);
      });
      document.getElementById('btnPlanCollapseAll').addEventListener('click', () => {
        document.querySelectorAll('#planList details').forEach(d => d.open = false);
      });

      // Bulk planner handlers
      document.getElementById('btnBulkLoad').addEventListener('click', async () => {
        const start = document.getElementById('bulkStart').value;
        if (!start) return;
        
        // Check if end date is provided and extend the range
        const endInput = document.getElementById('bulkEnd').value;
        let days = Number(document.getElementById('bulkDays').value || 14);
        
        if (endInput) {
          // Calculate days from start to end
          const [sy, sm, sd] = start.split('-').map(Number);
          const [ey, em, ed] = endInput.split('-').map(Number);
          const startDate = new Date(sy, sm - 1, sd);
          const endDate = new Date(ey, em - 1, ed);
          const diffTime = endDate.getTime() - startDate.getTime();
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
          if (diffDays > days) {
            days = diffDays;
            document.getElementById('bulkDays').value = days;
          }
        }
        
        await loadPlansIntoUi(start, days);
      });
      document.getElementById('btnBulkExpandAll').addEventListener('click', () => {
        document.querySelectorAll('#bulkList details').forEach(d => d.open = true);
      });
      document.getElementById('btnBulkCollapseAll').addEventListener('click', () => {
        document.querySelectorAll('#bulkList details').forEach(d => d.open = false);
      });

      document.getElementById('planList').addEventListener('click', async (e) => {
        const sel = e.target.closest('[data-action="select-meal"]');
        if (sel) { openMealPicker(sel.dataset.date, sel.dataset.slot); return; }

        const v = e.target.closest('[data-action="planner-view"]');
        if (v && v.dataset.rid) { await openRecipeModalView(v.dataset.rid); return; }

        const ed = e.target.closest('[data-action="planner-edit"]');
        if (ed && ed.dataset.rid) { await openRecipeModalEdit(ed.dataset.rid); return; }

        const pp = e.target.closest('[data-action="planner-print"]');
        if (pp && pp.dataset.rid) { 
          await openRecipeModalView(pp.dataset.rid);
          // Apply current scale to display before printing (force refresh)
          applyCurrentScaleToDisplay(true);
          printRecipeWithQuantities();
          return; 
        }

        const sw = e.target.closest('[data-action="swap"]');
        if (sw) {
          await api('swapPlanMeals', { date: sw.dataset.date, a: sw.dataset.a, b: sw.dataset.b });
          await loadPlansIntoUi(PLAN.start, PLAN.days);
          return;
        }

        const left = e.target.closest('[data-action="planner-leftovers"]');
        if (left) {
          const date = left.dataset.date;
          const slot = left.dataset.slot;
          const p = PLAN.plansByDate[date] || {};
          const cur = p[slot] || null;
          const currently = !!(cur && cur.UseLeftovers);

          if (currently) {
            // Turn off leftovers
            await api('upsertPlanMeal', { date, slot, meal: { RecipeId: cur.RecipeId || '', Title: cur.Title || '', UseLeftovers: false, From: '' } });
            await loadPlansIntoUi(PLAN.start, PLAN.days);
            await loadPantry(); // Refresh pantry after updating meal
            return;
          }

          // Turn on leftovers - allow for empty slots too
          const source = await pickLeftoversSourceAsync_(date, slot);
          if (source === null) return; // cancelled
          if (!source) {
            alert('Please select a source meal for leftovers.');
            return;
          }
          
          // Get the string value for parsing and the recipe details
          const sourceValue = (typeof source === 'string') ? source : source.value;
          const sourceRecipeId = source.recipeId || '';
          const sourceMealTitle = source.title || '';
          
          // Parse the source string to get date and slot
          const match = sourceValue.match(/^(\d{4}-\d{2}-\d{2})\s+(\w+)\s+[‚Äî‚Äì-]\s+(.+)$/);
          const sourceDate = match ? match[1] : '';
          const sourceSlot = match ? match[2] : '';
          
          // Create the leftovers meal using the SOURCE meal's RecipeId and Title
          // For empty slots, the title indicates it's a leftovers placeholder
          const updatedMeal = {
            RecipeId: sourceRecipeId,
            Title: sourceMealTitle,
            UseLeftovers: true,
            From: sourceValue
          };
          
          console.log('Saving leftovers meal:', { date, slot, meal: updatedMeal });
          
          const res = await api('upsertPlanMeal', { date, slot, meal: updatedMeal });
          console.log('API response:', res);
          
          // Debug: Show what was saved
          if (res && res.ok) {
            console.log('Leftovers meal saved successfully!');
          } else {
            alert('Error saving leftovers: ' + (res.error || 'Unknown error'));
            return;
          }
          
          await loadPlansIntoUi(PLAN.start, PLAN.days);
          await loadPantry(); // Refresh pantry after setting leftovers
          return;
        }
      });
      
      // Load pantry depletion data when details are opened
      document.getElementById('planList').addEventListener('toggle', async (e) => {
        if (e.target.tagName === 'DETAILS' && e.target.open) {
          const contentDiv = e.target.querySelector('.pantry-depletion-content');
          if (contentDiv && contentDiv.innerHTML.includes('Loading...')) {
            const date = contentDiv.dataset.date;
            const slot = contentDiv.dataset.slot;
            const rid = contentDiv.dataset.rid;
            if (date && slot && rid) {
              const html = await loadPantryDepletionForMeal(date, slot, rid);
              contentDiv.innerHTML = html;
            }
          }
        }
      }, true); // Use capture to catch nested details

      // Calendar
      document.getElementById('btnCalSync').addEventListener('click', calSync);

      // Clear Meals
      document.getElementById('btnClearRange').addEventListener('click', async () => {
        const start = document.getElementById('clearStart').value;
        const end = document.getElementById('clearEnd').value;
        const status = document.getElementById('clearStatus');
        
        if (!start || !end) {
          status.textContent = 'Please select start and end dates.';
          return;
        }
        
        const confirmed = confirm(`Are you sure you want to clear all meals from ${start} to ${end}?\n\nThis action cannot be undone.`);
        if (!confirmed) return;
        
        status.textContent = 'Clearing meals...';
        const r = await api('clearMealsByRange', { start, end, clearAll: false });
        
        if (r.ok) {
          status.textContent = r.message || 'Meals cleared successfully!';
          // Auto-refresh the plan view
          await loadPlan();
        } else {
          status.textContent = 'Error: ' + (r.error || 'Unknown error');
        }
      });

      document.getElementById('btnClearAll').addEventListener('click', async () => {
        const status = document.getElementById('clearStatus');
        
        const confirmed = confirm('‚ö†Ô∏è WARNING ‚ö†Ô∏è\n\nAre you sure you want to clear ALL meals from the entire meal planner?\n\nThis will remove every meal from every date in your planner.\n\nThis action CANNOT be undone!\n\nClick OK only if you are absolutely certain.');
        if (!confirmed) return;
        
        // Double confirmation for safety
        const doubleConfirm = confirm('This is your FINAL WARNING.\n\nYou are about to delete ALL meals from your planner.\n\nClick OK to proceed or Cancel to abort.');
        if (!doubleConfirm) return;
        
        status.textContent = 'Clearing all meals...';
        const r = await api('clearMealsByRange', { clearAll: true });
        
        if (r.ok) {
          status.textContent = r.message || 'All meals cleared!';
          // Auto-refresh the plan view
          await loadPlan();
        } else {
          status.textContent = 'Error: ' + (r.error || 'Unknown error');
        }
      });

      // Shopping list
      document.getElementById('btnBuildShop').addEventListener('click', buildShop);
      document.getElementById('btnClearShop').addEventListener('click', clearShopUi);
      document.getElementById('btnPrintShopAll').addEventListener('click', () => window.Foodie.printShoppingList && window.Foodie.printShoppingList());
      
      // Auto-refresh shopping list when low-stock checkbox is toggled
      document.getElementById('shopIncludeLowStock').addEventListener('change', async () => {
        // Only refresh if there's already a list generated
        if (SHOP.start && SHOP.end) {
          await buildShop();
        }
      });
      
      // Collection inclusion toggle
      document.getElementById('shopIncludeCollections').addEventListener('change', (e) => {
        const options = document.getElementById('collectionInclusionOptions');
        options.style.display = e.target.checked ? 'block' : 'none';
        
        // Populate collections dropdown when first shown
        if (e.target.checked) {
          populateShoppingCollectionsDropdown();
        }
      });

      // Pantry
      document.getElementById('pantryFilter').addEventListener('change', loadPantry);
      document.getElementById('pantrySearch').addEventListener('input', loadPantry);
      
      document.getElementById('btnPantryPrint').addEventListener('click', async () => {
        const q = (document.getElementById('pantrySearch').value || '').trim().toLowerCase();
        const filter = document.getElementById('pantryFilter').value || 'all';
        const res = await api('listPantry', { q });
        if (!res.ok) { alert('Error loading pantry: ' + (res.error || '')); return; }
        
        let items = res.items || [];
        
        // Apply filter
        if (filter === 'low') {
          items = items.filter(it => {
            const qty = (it.QtyNum !== null && it.QtyNum !== undefined && String(it.QtyNum) !== '') ? Number(it.QtyNum) : null;
            const threshold = (it.low_stock_threshold !== null && it.low_stock_threshold !== undefined && String(it.low_stock_threshold) !== '') ? Number(it.low_stock_threshold) : null;
            return qty !== null && threshold !== null && Number.isFinite(qty) && Number.isFinite(threshold) && qty <= threshold;
          });
        }
        
        // Group by category
        const byCategory = {};
        for (const it of items) {
          const cat = it.Category || 'Other';
          if (!byCategory[cat]) byCategory[cat] = [];
          byCategory[cat].push({
            Name: it.Name,
            Qty: (it.QtyNum !== null && it.QtyNum !== undefined && String(it.QtyNum) !== '') ? String(it.QtyNum) + ' ' + (it.Unit || '') : it.QtyText || '',
            Store: getStoreNameById(it.StoreId) || it.StoreId || '',
            Notes: it.Notes || ''
          });
        }
        
        await window.Foodie.printPantry(byCategory, filter === 'low' ? 'Low Stock Items' : 'Pantry Inventory');
      });
      
      document.getElementById('btnPantryAdd').addEventListener('click', async () => {
        const r = await pantryModal_({ title: 'Add Pantry Item', initial: {} });
        if (r && r.ok) await loadPantry();
      });
      
      document.getElementById('btnDismissExpiring').addEventListener('click', () => {
        document.getElementById('expiringItemsWidget').style.display = 'none';
      });
      
      document.getElementById('pantryList').addEventListener('click', async (e) => {
        const ed = e.target.closest('[data-action="pantry-edit"]');
        if (ed) {
          const id = String(ed.dataset.id || '').trim();
          const cur = (window.__pantryItemsById && id && window.__pantryItemsById[id]) ? window.__pantryItemsById[id] : { ItemId: id };
          const r = await pantryModal_({ title: 'Edit Pantry Item', initial: {
            ItemId: cur.ItemId || id,
            Name: cur.Name || '',
            QtyNum: (cur.QtyNum === null || cur.QtyNum === undefined) ? null : cur.QtyNum,
            Unit: cur.Unit || '',
            QtyText: cur.QtyText || '',
            Category: cur.Category || '',
            StoreId: cur.StoreId || '',
            Notes: cur.Notes || '',
            low_stock_threshold: (cur.low_stock_threshold === null || cur.low_stock_threshold === undefined) ? '' : cur.low_stock_threshold,
            expiration_date: cur.expiration_date || ''
          }});
          if (r && r.ok) await loadPantry();
          return;
        }
        const del = e.target.closest('[data-action="pantry-del"]');
        if (del) {
          const id = del.dataset.id;
          if (!id) return;
          if (!confirm('Delete pantry item?')) return;
          await api('deletePantryItem', { PantryId: id });
          await loadPantry();
          return;
        }
      });

      // Stores
      document.getElementById('btnReloadStores').addEventListener('click', loadStores);
      document.getElementById('btnAddStore').addEventListener('click', async () => {
        const name = (document.getElementById('newStoreName').value || '').trim();
        const priority = Number(document.getElementById('newStorePriority').value || 10);
        if (!name) { document.getElementById('storeStatus').textContent = 'Enter a store name.'; return; }
        const res = await api('addStore', { name, priority });
        if (!res.ok) { document.getElementById('storeStatus').textContent = `Error: ${res.error||''}`; return; }
        document.getElementById('newStoreName').value = '';
        await loadStores();
      });

      // Store list delete handler
      document.getElementById('storeList').addEventListener('click', async (e) => {
        const del = e.target.closest('[data-action="store-delete"]');
        if (del) {
          const storeId = del.dataset.storeid;
          const storeName = del.dataset.storename;
          if (!confirm(`Delete store "${storeName}"? This may affect ingredients assigned to this store.`)) return;
          const res = await api('deleteStore', { storeId });
          if (!res.ok) { document.getElementById('storeStatus').textContent = `Error: ${res.error||''}`; return; }
          document.getElementById('storeStatus').textContent = `Store "${storeName}" deleted.`;
          await loadStores();
          return;
        }
      });

      // Admin: Export/Import
      document.getElementById('btnExportData').addEventListener('click', async () => {
        document.getElementById('adminStatus').textContent = 'Exporting...';
        const res = await window.Foodie.exportData();
        if (!res.ok) { document.getElementById('adminStatus').textContent = `Error: ${res.error||''}`; return; }
        document.getElementById('adminStatus').textContent = 'Export complete.';
        setTimeout(() => { document.getElementById('adminStatus').textContent = ''; }, 3000);
      });

      document.getElementById('btnImportData').addEventListener('click', async () => {
        if (!confirm('Import will replace your current data. Continue?')) return;
        document.getElementById('adminStatus').textContent = 'Importing...';
        const res = await window.Foodie.importData();
        if (!res.ok) { document.getElementById('adminStatus').textContent = `Error: ${res.error||''}`; return; }
        document.getElementById('adminStatus').textContent = 'Import complete. Reloading...';
        // Reload page to pick up new data
        window.location.reload();
      });

      // Admin: Fix all recipe categories
      document.getElementById('btnFixCategories').addEventListener('click', async () => {
        if (!confirm('This will re-categorize all ingredients in all recipes and save them to the database. Continue?')) return;
        
        document.getElementById('fixCategoriesStatus').textContent = 'Loading recipes...';
        const statusEl = document.getElementById('fixCategoriesStatus');
        
        try {
          // Get all recipes
          const res = await api('listRecipesAll', {});
          if (!res.ok) throw new Error(res.error || 'Failed to load recipes');
          
          const recipes = res.recipes || [];
          if (!recipes.length) {
            statusEl.textContent = 'No recipes found.';
            return;
          }
          
          let totalFixed = 0;
          let totalErrors = 0;
          
          for (const recipe of recipes) {
            statusEl.textContent = `Processing ${totalFixed + 1}/${recipes.length}: ${recipe.Title}...`;
            
            // Load ingredients for this recipe
            const ingRes = await api('listRecipeIngredients', { recipeId: recipe.RecipeId });
            if (!ingRes.ok) {
              console.error(`Failed to load ingredients for ${recipe.RecipeId}:`, ingRes.error);
              totalErrors++;
              continue;
            }
            
            const items = ingRes.items || [];
            if (!items.length) {
              // Recipe has no ingredients, skip
              continue;
            }
            
            let categorized = false;
            
            // Categorize each ingredient
            for (let i = 0; i < items.length; i++) {
              const item = items[i];
              const name = item.IngredientRaw || item.IngredientNorm;
              if (!name || name.trim().length < 2) continue;
              
              const catRes = await api('classifyIngredient', { name });
              if (catRes.ok && catRes.category) {
                items[i].Category = catRes.category;
                categorized = true;
              } else {
                items[i].Category = items[i].Category || 'Other';
              }
              
              // Small delay to avoid overwhelming the API
              await new Promise(r => setTimeout(r, 5));
            }
            
            // Only save if we actually categorized something
            if (!categorized) continue;
            
            // Save back to database - MUST include full recipe object with Title
            const saveRes = await api('upsertRecipeWithIngredients', {
              recipe: {
                RecipeId: recipe.RecipeId,
                Title: recipe.Title,
                URL: recipe.URL || '',
                Cuisine: recipe.Cuisine || '',
                MealType: recipe.MealType || 'Any',
                Notes: recipe.Notes || '',
                Instructions: recipe.Instructions || '',
                Image_Name: recipe.Image_Name || ''
              },
              items: items.map(x => ({
                IngredientNorm: x.IngredientNorm || '',
                IngredientRaw: x.IngredientRaw || '',
                Notes: x.Notes || '',
                QtyNum: (x.QtyNum === '' || x.QtyNum === null || x.QtyNum === undefined) ? null : Number(x.QtyNum),
                QtyText: x.QtyText || '',
                StoreId: x.StoreId || '',
                Unit: x.Unit || '',
                Category: x.Category || ''
              }))
            });
            
            if (saveRes.ok) {
              totalFixed++;
            } else {
              console.error(`Failed to save ${recipe.RecipeId}:`, saveRes.error);
              totalErrors++;
            }
            
            // Small delay between recipes
            await new Promise(r => setTimeout(r, 10));
          }
          
          statusEl.textContent = `Done! Fixed ${totalFixed} recipe(s).${totalErrors > 0 ? ` ${totalErrors} errors.` : ''}`;
          
          // Refresh the recipes list
          await resetAndLoadRecipes();
          
        } catch (e) {
          statusEl.textContent = `Error: ${e.message}`;
        }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Cmd/Ctrl + K: Quick search (focus recipe search)
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
          e.preventDefault();
          const tab = document.querySelector('.tab[data-tab="recipes"]');
          if (tab) tab.click();
          setTimeout(() => {
            const searchBox = document.getElementById('recipeSearch');
            if (searchBox) searchBox.focus();
          }, 100);
        }
        
        // Cmd/Ctrl + N: New recipe
        if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
          e.preventDefault();
          openRecipeModalNew();
        }
        
        // Cmd/Ctrl + P: Print current view
        if ((e.metaKey || e.ctrlKey) && e.key === 'p') {
          e.preventDefault();
          // Determine current tab and print accordingly
          const activeTab = document.querySelector('.tab.active');
          if (activeTab) {
            const tabName = activeTab.dataset.tab;
            if (tabName === 'pantry') {
              document.getElementById('btnPantryPrint').click();
            } else if (tabName === 'shop') {
              document.getElementById('btnPrintShopAll').click();
            }
          }
        }
      });

      // ========== PHASE 3: CALENDAR GRID VIEW ==========
      
      document.getElementById('btnPlanViewList').addEventListener('click', () => {
        PLAN.viewMode = 'list';
        document.getElementById('planList').style.display = '';
        document.getElementById('planGrid').style.display = 'none';
        document.getElementById('btnPlanViewList').style.borderColor = 'rgba(77,163,255,0.55)';
        document.getElementById('btnPlanViewGrid').style.borderColor = 'rgba(255,255,255,0.12)';
        
        // Collapse all details elements when switching to list view
        document.querySelectorAll('#planList details').forEach(d => d.open = false);
      });

      document.getElementById('btnPlanViewGrid').addEventListener('click', () => {
        PLAN.viewMode = 'grid';
        document.getElementById('planList').style.display = 'none';
        document.getElementById('planGrid').style.display = '';
        document.getElementById('btnPlanViewList').style.borderColor = 'rgba(255,255,255,0.12)';
        document.getElementById('btnPlanViewGrid').style.borderColor = 'rgba(77,163,255,0.55)';
        renderPlanGrid();
      });

      // ========== PHASE 3: BULK MEAL OPERATIONS ==========

      document.getElementById('btnCopyWeekForward').addEventListener('click', async () => {
        const start = PLAN.start;
        if (!start) { alert('Load a plan range first'); return; }
        const statusEl = document.getElementById('copyWeekStatus');
        statusEl.textContent = 'Copying...';
        
        try {
          for (let i = 0; i < 7; i++) {
            const srcDate = addDays(start, i);
            const dstDate = addDays(start, i + 7);
            const srcPlan = PLAN.plansByDate[srcDate];
            if (!srcPlan) continue;
            
            for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
              if (srcPlan[slot]) {
                await api('upsertPlanMeal', {
                  date: dstDate,
                  slot,
                  recipeId: srcPlan[slot].RecipeId || '',
                  title: srcPlan[slot].Title || ''
                });
              }
            }
          }
          
          const endDate = addDays(start, daysInclusive(start, PLAN.start + 13));
          await loadPlansIntoUi(start, daysInclusive(start, endDate));
          statusEl.textContent = 'Week copied!';
          setTimeout(() => { statusEl.textContent = ''; }, 3000);
        } catch (e) {
          statusEl.textContent = `Error: ${e.message}`;
        }
      });

      document.getElementById('btnCopyWeekBack').addEventListener('click', async () => {
        const start = PLAN.start;
        if (!start) { alert('Load a plan range first'); return; }
        const statusEl = document.getElementById('copyWeekStatus');
        statusEl.textContent = 'Copying...';
        
        try {
          for (let i = 0; i < 7; i++) {
            const srcDate = addDays(start, i);
            const dstDate = addDays(start, i - 7);
            const srcPlan = PLAN.plansByDate[srcDate];
            if (!srcPlan) continue;
            
            for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
              if (srcPlan[slot]) {
                await api('upsertPlanMeal', {
                  date: dstDate,
                  slot,
                  recipeId: srcPlan[slot].RecipeId || '',
                  title: srcPlan[slot].Title || ''
                });
              }
            }
          }
          
          await loadPlansIntoUi(addDays(start, -7), daysInclusive(addDays(start, -7), start));
          statusEl.textContent = 'Week copied!';
          setTimeout(() => { statusEl.textContent = ''; }, 3000);
        } catch (e) {
          statusEl.textContent = `Error: ${e.message}`;
        }
      });

      document.getElementById('btnAutoFillBreakfast').addEventListener('click', async () => {
        const recipeId = document.getElementById('autoFillBreakfastRecipe').value;
        if (!recipeId) { alert('Select a recipe first'); return; }
        
        const recipe = RECIPES.find(r => r.RecipeId === recipeId);
        if (!recipe) { alert('Recipe not found'); return; }
        
        const statusEl = document.getElementById('autoFillStatus');
        statusEl.textContent = 'Filling...';
        
        try {
          let filled = 0;
          for (const dateKey in PLAN.plansByDate) {
            const plan = PLAN.plansByDate[dateKey];
            if (!plan.Breakfast || !plan.Breakfast.Title) {
              await api('upsertPlanMeal', {
                date: dateKey,
                slot: 'Breakfast',
                recipeId: recipe.RecipeId,
                title: recipe.Title
              });
              filled++;
            }
          }
          
          await loadPlansIntoUi(PLAN.start, PLAN.days);
          statusEl.textContent = `Filled ${filled} breakfasts!`;
          setTimeout(() => { statusEl.textContent = ''; }, 3000);
        } catch (e) {
          statusEl.textContent = `Error: ${e.message}`;
        }
      });

      document.getElementById('btnSaveMealPattern').addEventListener('click', () => {
        if (!PLAN.start) { alert('Load a plan range first'); return; }
        
        const pattern = [];
        for (let i = 0; i < 7; i++) {
          const dateKey = addDays(PLAN.start, i);
          const plan = PLAN.plansByDate[dateKey] || {};
          pattern.push({
            Breakfast: plan.Breakfast || null,
            Lunch: plan.Lunch || null,
            Dinner: plan.Dinner || null
          });
        }
        
        try {
          localStorage.setItem(MEAL_PATTERN_KEY, JSON.stringify(pattern));
          document.getElementById('templateStatus').textContent = 'Template saved!';
          setTimeout(() => { document.getElementById('templateStatus').textContent = ''; }, 3000);
        } catch (e) {
          alert('Failed to save template: ' + e.message);
        }
      });

      document.getElementById('btnLoadMealPattern').addEventListener('click', async () => {
        let pattern;
        try {
          pattern = JSON.parse(localStorage.getItem(MEAL_PATTERN_KEY));
          if (!pattern || !Array.isArray(pattern)) throw new Error('No template found');
        } catch (e) {
          alert('No saved template found');
          return;
        }
        
        if (!PLAN.start) { alert('Load a plan range first'); return; }
        
        const statusEl = document.getElementById('templateStatus');
        statusEl.textContent = 'Loading template...';
        
        try {
          for (let i = 0; i < pattern.length && i < 7; i++) {
            const dateKey = addDays(PLAN.start, i);
            const day = pattern[i];
            
            for (const slot of ['Breakfast', 'Lunch', 'Dinner']) {
              if (day[slot]) {
                await api('upsertPlanMeal', {
                  date: dateKey,
                  slot,
                  recipeId: day[slot].RecipeId || '',
                  title: day[slot].Title || ''
                });
              }
            }
          }
          
          await loadPlansIntoUi(PLAN.start, PLAN.days);
          statusEl.textContent = 'Template loaded!';
          setTimeout(() => { statusEl.textContent = ''; }, 3000);
        } catch (e) {
          statusEl.textContent = `Error: ${e.message}`;
        }
      });

      // ========== PHASE 3: LEFTOVERS PICKER ==========

      document.getElementById('mpUseLeftovers').addEventListener('click', () => {
        openLeftoverPicker();
      });

      document.getElementById('btnLeftoverPickerClose').addEventListener('click', () => {
        document.getElementById('leftoverPickerBack').style.display = 'none';
      });

      document.getElementById('leftoverPickerBack').addEventListener('click', async (e) => {
        const pick = e.target.closest('[data-action="pick-leftover"]');
        if (pick) {
          const title = pick.dataset.title;
          const fromDate = pick.dataset.fromdate;
          const fromSlot = pick.dataset.fromslot;
          
          if (MP.open && MP.date && MP.slot) {
            const res = await api('upsertPlanMeal', {
              date: MP.date,
              slot: MP.slot,
              recipeId: '',
              title,
              useLeftovers: true,
              from: `${fromDate} ${fromSlot}`
            });
            
            if (res.ok) {
              await loadPlansIntoUi(PLAN.start, PLAN.days);
              document.getElementById('leftoverPickerBack').style.display = 'none';
              closeMealPicker();
            }
          }
          return;
        }
      });

      // ========== COLLECTION RECIPE PICKER FOR MEAL PLANNER ==========

      document.getElementById('mpUseCollection').addEventListener('click', () => {
        openCollectionRecipePicker();
      });

      document.getElementById('btnCollectionRecipePickerClose').addEventListener('click', () => {
        document.getElementById('collectionRecipePickerBack').style.display = 'none';
      });

      document.getElementById('collectionRecipePickerSelect').addEventListener('change', async (e) => {
        const collectionId = e.target.value;
        await loadCollectionRecipesForPicker(collectionId);
      });

      document.getElementById('collectionRecipePickerBack').addEventListener('click', async (e) => {
        const pick = e.target.closest('[data-action="pick-collection-recipe"]');
        if (pick) {
          const recipeId = pick.dataset.rid;
          const title = pick.dataset.title;
          
          if (MP.open && MP.date && MP.slot && recipeId) {
            const res = await api('upsertPlanMeal', {
              date: MP.date,
              slot: MP.slot,
              recipeId,
              title
            });
            
            if (res.ok) {
              await loadPlansIntoUi(PLAN.start, PLAN.days);
              document.getElementById('collectionRecipePickerBack').style.display = 'none';
              closeMealPicker();
            }
          }
          return;
        }
      });

      // ========== PHASE 3: RECIPE COLLECTIONS ==========

      document.getElementById('btnCreateCollection').addEventListener('click', () => {
        openCollectionModal();
      });

      document.getElementById('btnCollectionModalClose').addEventListener('click', () => {
        document.getElementById('collectionModalBack').style.display = 'none';
      });

      document.getElementById('btnSaveCollection').addEventListener('click', async () => {
        const name = document.getElementById('collectionName').value.trim();
        const description = document.getElementById('collectionDescription').value.trim();
        
        if (!name) {
          document.getElementById('collectionModalStatus').textContent = 'Name is required';
          return;
        }
        
        const res = await api('upsertCollection', {
          collectionId: CURRENT_COLLECTION_ID,
          name,
          description
        });
        
        if (res.ok) {
          await loadCollections();
          document.getElementById('collectionModalBack').style.display = 'none';
          document.getElementById('collectionModalStatus').textContent = '';
        } else {
          document.getElementById('collectionModalStatus').textContent = res.error || 'Save failed';
        }
      });

      document.getElementById('btnDeleteCollection').addEventListener('click', async () => {
        if (!CURRENT_COLLECTION_ID) return;
        if (!confirm('Delete this collection? Recipes will not be deleted.')) return;
        
        const res = await api('deleteCollection', { collectionId: CURRENT_COLLECTION_ID });
        if (res.ok) {
          await loadCollections();
          document.getElementById('collectionModalBack').style.display = 'none';
        }
      });

      document.getElementById('collectionFilter').addEventListener('change', async (e) => {
        const collectionId = e.target.value;
        if (collectionId) {
          await loadCollectionRecipes(collectionId);
        } else {
          document.getElementById('collectionRecipesList').innerHTML = '<div class="muted">Select a collection to view recipes</div>';
        }
      });

      // Import Recipe Modal
      document.getElementById('btnImportRecipeModalClose').addEventListener('click', closeImportRecipeModal);
      document.getElementById('btnFetchRecipe').addEventListener('click', fetchRecipeFromUrl);
      document.getElementById('btnSaveImportedRecipe').addEventListener('click', saveImportedRecipe);
      document.getElementById('btnCancelImport').addEventListener('click', closeImportRecipeModal);

      // Smart Weekly Meal Planner
      document.getElementById('btnGenerateWeek').addEventListener('click', generateSmartWeek);
      document.getElementById('btnMealPlannerSettings').addEventListener('click', openMealPlannerPrefs);
      document.getElementById('btnMealPlannerPrefsClose').addEventListener('click', closeMealPlannerPrefs);
      document.getElementById('btnSaveMealPlannerPrefs').addEventListener('click', saveMealPlannerPrefsFromModal);
      
      // Toggle recipe repeat options visibility
      document.getElementById('prefAvoidRecipeRepeat').addEventListener('change', (e) => {
        const options = document.getElementById('recipeRepeatOptions');
        options.style.display = e.target.checked ? 'block' : 'none';
      });

      // Admin tab - Cuisine Management (delegate event listeners on cuisineManageList)
      document.getElementById('cuisineManageList').addEventListener('click', async (e) => {
        const clearBtn = e.target.closest('[data-action="clear-cuisine"]');
        const renameBtn = e.target.closest('[data-action="rename-cuisine"]');
        const deleteBtn = e.target.closest('[data-action="delete-cuisine"]');
        
        if (clearBtn) {
          const cuisineName = clearBtn.dataset.cuisine;
          await clearCuisineFromRecipes(cuisineName);
        } else if (renameBtn) {
          const cuisineName = renameBtn.dataset.cuisine;
          await renameCuisine(cuisineName);
        } else if (deleteBtn) {
          const cuisineName = deleteBtn.dataset.cuisine;
          deleteCuisineFromList(cuisineName);
        }
      });
      
      // Add cuisine button
      document.getElementById('btnAddCuisine').addEventListener('click', addCuisine);
      
      // Allow Enter key to add cuisine
      document.getElementById('newCuisineName').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addCuisine();
        }
      });

      // Assign to Planner Modal
      document.getElementById('btnAssignToPlannerClose').addEventListener('click', () => {
        document.getElementById('assignToPlannerBack').style.display = 'none';
      });

      document.getElementById('btnConfirmAssignToPlanner').addEventListener('click', async () => {
        await confirmAssignToPlanner();
      });

      // Shopping List Preview Modal
      document.getElementById('btnShoppingListPreviewClose').addEventListener('click', () => {
        document.getElementById('shoppingListPreviewBack').style.display = 'none';
      });

      document.getElementById('btnCancelPrintShopping').addEventListener('click', () => {
        document.getElementById('shoppingListPreviewBack').style.display = 'none';
      });

      document.getElementById('btnConfirmPrintShopping').addEventListener('click', async () => {
        await confirmPrintShoppingList();
      });

      document.getElementById('btnAssignRecipesModalClose').addEventListener('click', () => {
        document.getElementById('assignRecipesModalBack').style.display = 'none';
      });

      document.getElementById('assignRecipesSearch').addEventListener('input', debounce((e) => {
        renderAssignRecipesList(e.target.value.trim().toLowerCase());
      }, 300));

      document.getElementById('assignRecipesModalBack').addEventListener('click', async (e) => {
        const toggle = e.target.closest('[data-action="toggle-recipe-in-collection"]');
        if (toggle) {
          const recipeId = toggle.dataset.rid;
          const isInCollection = toggle.dataset.incollection === 'true';
          
          let res;
          if (isInCollection) {
            res = await api('removeRecipeFromCollection', {
              collectionId: CURRENT_COLLECTION_ID,
              recipeId
            });
          } else {
            res = await api('addRecipeToCollection', {
              collectionId: CURRENT_COLLECTION_ID,
              recipeId
            });
          }
          
          if (res.ok) {
            await loadCollectionRecipes(CURRENT_COLLECTION_ID);
            renderAssignRecipesList(document.getElementById('assignRecipesSearch').value.trim().toLowerCase());
          }
        }
      });

      document.getElementById('collectionsList').addEventListener('click', async (e) => {
        const edit = e.target.closest('[data-action="edit-collection"]');
        if (edit) {
          const collectionId = edit.dataset.cid;
          const res = await api('getCollection', { collectionId });
          if (res.ok) {
            openCollectionModal(res.collection);
          }
          return;
        }

        const assign = e.target.closest('[data-action="assign-recipes"]');
        if (assign) {
          CURRENT_COLLECTION_ID = assign.dataset.cid;
          openAssignRecipesModal();
          return;
        }
        
        const shoppingList = e.target.closest('[data-action="collection-shopping-list"]');
        if (shoppingList) {
          const collectionId = shoppingList.dataset.cid;
          await generateCollectionShoppingList(collectionId);
          return;
        }

        const assignToPlanner = e.target.closest('[data-action="assign-collection-to-planner"]');
        if (assignToPlanner) {
          const collectionId = assignToPlanner.dataset.cid;
          const collectionName = assignToPlanner.dataset.cname;
          await showAssignCollectionFromCollectionsTab(collectionId, collectionName);
          return;
        }
      });
      
      // Theme toggle
      document.getElementById('btnThemeToggle').addEventListener('click', () => {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', newTheme === 'dark' ? '' : 'light');
        try {
          localStorage.setItem('foodieTheme', newTheme);
        } catch (_) {}
      });

      // Google Calendar setup
      document.getElementById('btnUploadGoogleCreds').addEventListener('click', uploadGoogleCredentials);
      document.getElementById('btnGoogleAuthorize').addEventListener('click', authorizeGoogleCalendar);
      document.getElementById('btnGoogleAuthSubmit').addEventListener('click', submitGoogleAuthCode);
      document.getElementById('btnListGoogleCals').addEventListener('click', listGoogleCalendars);
      document.getElementById('btnGoogleCalSync').addEventListener('click', syncToGoogleCalendar);
      document.getElementById('btnCheckDuplicates').addEventListener('click', checkForDuplicates);
      document.getElementById('btnRevokeGoogleCal').addEventListener('click', revokeGoogleCalendar);

      // Calendar selection change
      document.getElementById('googleCalendarSelect').addEventListener('change', async (e) => {
        const calendarId = e.target.value;
        if (calendarId) {
          await window.Foodie.setGoogleCalendarId(calendarId);
        }
      });
    }


    // ---------- init ----------
    async function init() {
      // Load saved theme
      try {
        const savedTheme = localStorage.getItem('foodieTheme');
        if (savedTheme === 'light') {
          document.documentElement.setAttribute('data-theme', 'light');
        }
      } catch (_) {}
      
      bindUi();

      // Load ingredient categories list from DB (Admin-manageable). Fall back to defaults.
      try {
        const catRes = await api('getIngredientCategories', {});
        if (catRes && catRes.ok && Array.isArray(catRes.categories) && catRes.categories.length) {
          META.categories = [''].concat(catRes.categories);
          const ta = document.getElementById('adminCategoriesText');
          if (ta) ta.value = catRes.categories.join('\n');
        } else {
          const ta = document.getElementById('adminCategoriesText');
          if (ta) ta.value = DEFAULT_ING_CATEGORIES.join('\n');
        }
      } catch (e) {
        const ta = document.getElementById('adminCategoriesText');
        if (ta) ta.value = DEFAULT_ING_CATEGORIES.join('\n');
      }

      fillJumpLetters();

      const today = ymd(new Date());
      const weekEnd = addDays(today, 6); // 6 days after today = 7 days total including today
      
      // Set default dates for main planner
      document.getElementById('planStart').value = today;
      document.getElementById('planEnd').value = weekEnd;
      
      // Set default dates for generation inputs
      document.getElementById('genStartDate').value = today;
      document.getElementById('genEndDate').value = weekEnd;
      
      // Set default dates for Google Calendar sync
      document.getElementById('googleSyncStart').value = today;
      document.getElementById('googleSyncEnd').value = weekEnd;
      
      // Set other tab defaults
      document.getElementById('bulkStart').value = today;
      document.getElementById('shopStart').value = today;
      document.getElementById('clearStart').value = today;

      try { await loadStores(); } catch (_) {}
      await resetAndLoadRecipes();
      
      // Populate cuisine filter dropdown with comprehensive list
      populateCuisineFilter();
      
      await loadPantry();

      // Phase 3: Load collections
      try { await loadCollections(); } catch (_) {}

      // Phase 3: Populate breakfast dropdown after recipes are loaded
      populateBreakfastRecipeDropdown();

      // Load the planner based on the default date range we just set
      try {
        await loadPlan();
      } catch (e) {
        console.error('Failed to load initial plan:', e);
        // Still render empty grid even if load fails
        if (PLAN.viewMode === 'grid') {
          PLAN.start = today;
          PLAN.days = 7;
          renderPlanGrid();
        }
      }

      // Check Google Calendar status on startup
      try {
        await checkGoogleCalendarStatus();
      } catch (_) {}
    }


    window.addEventListener('load', init);

  </script>

<!-- Pantry item modal (replaces window.prompt, which is not supported in this Electron configuration) -->
<div id="pantryModalOverlay" style="position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:9999;">
  <div style="background:#ffffff;color:#111111;min-width:360px;max-width:520px;width:90%;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.35);padding:16px;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;">
      <div id="pantryModalTitle" style="font-size:16px;font-weight:700;">Pantry Item</div>
      <button id="pantryModalClose" style="padding:6px 10px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;">X</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <label style="grid-column:1 / span 2;">
        <div style="font-size:12px;margin-bottom:4px;">Name</div>
        <input id="pantryModalName" type="text" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Qty (number)</div>
        <input id="pantryModalQtyNum" type="text" inputmode="decimal" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Unit</div>
        <input id="pantryModalUnit" type="text" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Low stock threshold</div>
        <input id="pantryModalLowStock" type="text" inputmode="decimal" placeholder="e.g., 1" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Expiration date (optional)</div>
        <input id="pantryModalExpiration" type="date" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;color-scheme:light;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Category</div>
        <select id="pantryModalCategory" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;">
        </select>
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Store (optional)</div>
        <select id="pantryModalStoreId" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;">
        </select>
      </label>
      <label style="grid-column:1 / span 2;">
        <div style="font-size:12px;margin-bottom:4px;">Qty text (optional)</div>
        <input id="pantryModalQtyText" type="text" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
      <label>
        <div style="font-size:12px;margin-bottom:4px;">Notes (optional)</div>
        <input id="pantryModalNotes" type="text" style="width:100%;padding:8px;border:1px solid #bbb;border-radius:6px;background:#fff;color:#111;" />
      </label>
    </div>
    <div id="pantryModalError" style="margin-top:10px;color:#b00020;font-size:12px;display:none;"></div>
    <div style="display:flex;justify-content:flex-end;gap:10px;margin-top:14px;">
      <button id="pantryModalCancel" style="padding:8px 12px;font-weight:700;background:#6b7280;border:none;border-radius:6px;cursor:pointer;color:#fff;">Cancel</button>
      <button id="pantryModalSave" style="padding:8px 12px;font-weight:700;background:#4da3ff;border:none;border-radius:6px;cursor:pointer;color:#fff;">Save</button>
    </div>
  </div>
</div>

<!-- Companion Panel for iOS Apps -->
<button class="companion-float-btn" id="companionFloatBtn" title="iOS Companion Devices">üì±</button>

<div class="companion-panel" id="companionPanel">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
    <strong>iOS Companion</strong>
    <button class="mini ghost" onclick="document.getElementById('companionPanel').classList.remove('show')">‚úï</button>
  </div>
  
  <div class="companion-status">
    <div class="companion-status-dot" id="companionStatusDot"></div>
    <div id="companionStatusText">Checking...</div>
  </div>
  
  <div class="hr"></div>
  
  <div style="margin-bottom:12px;">
    <strong style="font-size:13px;">Connected Devices</strong>
    <div id="companionDeviceList" style="margin-top:8px; min-height:40px;">
      <div class="muted" style="font-size:12px;">No devices connected</div>
    </div>
  </div>
  
  <div class="hr"></div>
  
  <div>
    <strong style="font-size:13px; display:block; margin-bottom:8px;">Quick Actions</strong>
    <button class="companion-action-btn" id="companionSendShopping" onclick="sendShoppingListToPhones()">
      üìã Send Shopping List to iPhone
    </button>
    <button class="companion-action-btn" id="companionSendMeals" onclick="sendTodaysMealsToTablets()">
      üçΩÔ∏è Send Today's Meals to iPad
    </button>
    <button class="companion-action-btn" id="companionSendRecipe" onclick="sendCurrentRecipeToTablet()" disabled>
      üë®‚Äçüç≥ Send Current Recipe to iPad
    </button>
  </div>
  
  <div class="hr"></div>
  
  <div style="font-size:12px; color:var(--text); background:rgba(77,163,255,0.1); padding:10px; border-radius:8px;">
    <div style="font-weight:600; margin-bottom:4px;">Configure iOS Apps:</div>
    <div style="font-size:11px; color:var(--muted); margin-bottom:6px;">
      iPhone: Enter full address<br>
      iPad: Enter IP only (no ws:// or :8080)
    </div>
    <code id="companionServerAddress" style="font-size:11px; background:rgba(0,0,0,0.2); padding:4px 8px; border-radius:4px; display:inline-block; font-weight:600;">Checking...</code>
  </div>
</div>

<script>
  // Companion Panel JavaScript
  let companionCurrentRecipeId = null;

  // Listen for main process logs
  Foodie.onCompanionLog((event, data) => {
    const prefix = data.level === 'error' ? '‚ùå MAIN:' : 
                   data.level === 'warn' ? '‚ö†Ô∏è  MAIN:' :
                   data.level === 'success' ? '‚úÖ MAIN:' : 'üì± MAIN:';
    console.log(prefix, data.message);
  });

  document.getElementById('companionFloatBtn').addEventListener('click', () => {
    const panel = document.getElementById('companionPanel');
    panel.classList.toggle('show');
    if (panel.classList.contains('show')) {
      updateCompanionDevices();
    }
  });

  async function updateCompanionDevices() {
    try {
      const result = await Foodie.getCompanionDevices();
      if (result.ok && result.devices) {
        const deviceList = document.getElementById('companionDeviceList');
        const statusDot = document.getElementById('companionStatusDot');
        const statusText = document.getElementById('companionStatusText');
        
        if (result.devices.length === 0) {
          deviceList.innerHTML = '<div class="muted" style="font-size:12px;">No devices connected</div>';
          statusDot.classList.add('offline');
          statusText.textContent = 'Server ready (no devices)';
        } else {
          deviceList.innerHTML = result.devices.map(d => `
            <div class="companion-device">
              ${d.type === 'iPhone' ? 'üì±' : 'üì±'} ${d.type || 'Device'}
              <div class="muted" style="font-size:11px;">${d.ip || 'Unknown IP'}</div>
            </div>
          `).join('');
          statusDot.classList.remove('offline');
          statusText.textContent = `${result.devices.length} device${result.devices.length > 1 ? 's' : ''} connected`;
        }
        
        // Update server address - show the actual local IP
        const serverAddr = document.getElementById('companionServerAddress');
        const interfaces = await getLocalIP();
        if (interfaces) {
          serverAddr.textContent = interfaces;
        } else {
          serverAddr.textContent = 'ws://[checking...]:8080';
        }
      }
    } catch (e) {
      console.error('Failed to get companion devices:', e);
    }
  }

  async function sendShoppingListToPhones() {
    console.log('üîµ RENDERER: sendShoppingListToPhones called');
    try {
      console.log('üîµ RENDERER: Calling Foodie.sendShoppingListToPhones()...');
      const result = await Foodie.sendShoppingListToPhones();
      console.log('üîµ RENDERER: Result:', result);
      if (result.ok) {
        console.log(`üîµ RENDERER: Success! Count: ${result.count}`);
        alert(`Shopping list sent to ${result.count} device(s)`);
      } else {
        console.error('üî¥ RENDERER: Failed:', result.error);
        alert('Failed to send: ' + (result.error || 'Unknown error'));
      }
    } catch (e) {
      console.error('üî¥ RENDERER: Exception:', e);
      alert('Error: ' + e.message);
    }
  }

  async function sendTodaysMealsToTablets() {
    console.log('üîµ RENDERER: sendTodaysMealsToTablets called');
    try {
      console.log('üîµ RENDERER: Calling Foodie.sendTodaysMealsToTablets()...');
      const result = await Foodie.sendTodaysMealsToTablets();
      console.log('üîµ RENDERER: Result:', result);
      if (result.ok) {
        console.log(`üîµ RENDERER: Success! Count: ${result.count}`);
        alert(`Today's meals sent to ${result.count} device(s)`);
      } else {
        console.error('üî¥ RENDERER: Failed:', result.error);
        alert('Failed to send: ' + (result.error || 'Unknown error'));
      }
    } catch (e) {
      console.error('üî¥ RENDERER: Exception:', e);
      alert('Error: ' + e.message);
    }
  }

  async function sendCurrentRecipeToTablet() {
    if (!companionCurrentRecipeId) {
      alert('No recipe selected');
      return;
    }
    try {
      const result = await Foodie.sendRecipeToTablet(companionCurrentRecipeId);
      if (result.ok) {
        alert(`Recipe sent to ${result.count} device(s)`);
      } else {
        alert('Failed to send: ' + (result.error || 'Unknown error'));
      }
    } catch (e) {
      alert('Error: ' + e.message);
    }
  }

  // Get local IP address for display
  async function getLocalIP() {
    try {
      const result = await Foodie.getServerIP();
      if (result.ok && result.ip) {
        return `ws://${result.ip}:8080`;
      }
      return 'ws://[check console]:8080';
    } catch (e) {
      return 'ws://[unavailable]:8080';
    }
  }

  // Listen for device changes
  if (typeof Foodie !== 'undefined' && Foodie.onCompanionDevicesChanged) {
    Foodie.onCompanionDevicesChanged((devices) => {
      updateCompanionDevices();
    });
  }

  // Update devices every 10 seconds if panel is open
  setInterval(() => {
    const panel = document.getElementById('companionPanel');
    if (panel && panel.classList.contains('show')) {
      updateCompanionDevices();
    }
  }, 10000);
</script>

</body>
</html>
